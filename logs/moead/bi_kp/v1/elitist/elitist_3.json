[
    {
        "algorithm": "{This heuristic selects a solution from the archive based on the highest combined objective values, then applies a novel hybrid local search that combines item swaps with a probabilistic replacement strategy, but with a focus on diversifying the search by considering both objectives separately and using a temperature-based acceptance criterion to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmax(archive_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    temperature = 1.0\n\n    # Hybrid local search with temperature-based acceptance\n    for _ in range(5):  # Increased iterations for better exploration\n        # Step 1: Randomly select items to swap or replace\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Swap one item in with one item out\n            swap_in = random.choice(items_in)\n            swap_out = random.choice(items_out)\n\n            # Check feasibility after swap\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                # Accept if better or with probability based on temperature\n                delta_value1 = value1_lst[swap_out] - value1_lst[swap_in]\n                delta_value2 = value2_lst[swap_out] - value2_lst[swap_in]\n\n                if delta_value1 > 0 or delta_value2 > 0 or random.random() < temperature:\n                    new_solution[swap_in] = 0\n                    new_solution[swap_out] = 1\n                    current_weight = new_weight\n\n        # Step 2: Probabilistic replacement with temperature adjustment\n        if random.random() < 0.4:  # Higher chance to add\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                add_item = random.choice(candidate_items)\n                if current_weight + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n                    current_weight += weight_lst[add_item]\n\n        if random.random() < 0.3:  # Higher chance to remove\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                remove_item = random.choice(candidate_items)\n                new_solution[remove_item] = 0\n                current_weight -= weight_lst[remove_item]\n\n        # Cool down temperature\n        temperature *= 0.9\n\n    return new_solution\n\n",
        "score": [
            -19.026962290436575,
            -18.70476485054651
        ]
    },
    {
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with the highest combined objective values, then applies a novel hybrid local search that combines item swaps with a probabilistic replacement strategy to explore diverse neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmax(archive_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic item swaps and replacements\n    for _ in range(3):  # Number of iterations\n        # Step 1: Randomly select items to swap or replace\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Swap one item in with one item out\n            swap_in = random.choice(items_in)\n            swap_out = random.choice(items_out)\n\n            # Check feasibility after swap\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Step 2: Probabilistic replacement (add or remove with probability)\n        if random.random() < 0.3:  # 30% chance to add an item\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                add_item = random.choice(candidate_items)\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:  # 20% chance to remove an item\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                remove_item = random.choice(candidate_items)\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.185482724098307,
            -18.5552203582161
        ]
    },
    {
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with the highest combined objective values, then applies a novel hybrid local search that combines item swaps with a probabilistic replacement strategy to explore diverse neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmax(archive_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic item swaps and replacements\n    for _ in range(3):  # Number of iterations\n        # Step 1: Randomly select items to swap or replace\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Swap one item in with one item out\n            swap_in = random.choice(items_in)\n            swap_out = random.choice(items_out)\n\n            # Check feasibility after swap\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Step 2: Probabilistic replacement (add or remove with probability)\n        if random.random() < 0.3:  # 30% chance to add an item\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                add_item = random.choice(candidate_items)\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:  # 20% chance to remove an item\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                remove_item = random.choice(candidate_items)\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.185482724098307,
            -18.5552203582161
        ]
    },
    {
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with the highest combined objective values, then applies a novel hybrid local search that combines item swaps with a probabilistic replacement strategy to explore diverse neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmax(archive_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic item swaps and replacements\n    for _ in range(3):  # Number of iterations\n        # Step 1: Randomly select items to swap or replace\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Swap one item in with one item out\n            swap_in = random.choice(items_in)\n            swap_out = random.choice(items_out)\n\n            # Check feasibility after swap\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Step 2: Probabilistic replacement (add or remove with probability)\n        if random.random() < 0.3:  # 30% chance to add an item\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                add_item = random.choice(candidate_items)\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:  # 20% chance to remove an item\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                remove_item = random.choice(candidate_items)\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.185482724098307,
            -18.5552203582161
        ]
    },
    {
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with the highest combined objective values, then applies a novel hybrid local search that combines item swaps with a probabilistic replacement strategy to explore diverse neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmax(archive_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic item swaps and replacements\n    for _ in range(3):  # Number of iterations\n        # Step 1: Randomly select items to swap or replace\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Swap one item in with one item out\n            swap_in = random.choice(items_in)\n            swap_out = random.choice(items_out)\n\n            # Check feasibility after swap\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Step 2: Probabilistic replacement (add or remove with probability)\n        if random.random() < 0.3:  # 30% chance to add an item\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                add_item = random.choice(candidate_items)\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:  # 20% chance to remove an item\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                remove_item = random.choice(candidate_items)\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.097484262240137,
            -18.630009621331194
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search strategy that combines item swaps with a dynamic threshold-based selection to explore neighbors while ensuring feasibility and balancing exploration of both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmax(archive_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Dynamic threshold-based local search\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Calculate dynamic thresholds for each objective\n    threshold1 = current_value1 * 0.9  # 10% improvement threshold for objective 1\n    threshold2 = current_value2 * 0.9  # 10% improvement threshold for objective 2\n\n    # Iteratively explore neighbors\n    for _ in range(5):  # Number of iterations\n        # Randomly select items to consider\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Try swapping items\n            swap_in = random.choice(items_in)\n            swap_out = random.choice(items_out)\n\n            # Calculate new values and weight\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n            new_value1 = current_value1 - value1_lst[swap_in] + value1_lst[swap_out]\n            new_value2 = current_value2 - value2_lst[swap_in] + value2_lst[swap_out]\n\n            # Check feasibility and improvement\n            if new_weight <= capacity and (new_value1 > threshold1 or new_value2 > threshold2):\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n                current_weight, current_value1, current_value2 = new_weight, new_value1, new_value2\n                threshold1 = current_value1 * 0.9\n                threshold2 = current_value2 * 0.9\n\n        # Probabilistic addition of items\n        if random.random() < 0.4 and len(items_out) > 0:\n            add_item = random.choice(items_out)\n            if current_weight + weight_lst[add_item] <= capacity:\n                new_value1 = current_value1 + value1_lst[add_item]\n                new_value2 = current_value2 + value2_lst[add_item]\n                if new_value1 > threshold1 or new_value2 > threshold2:\n                    new_solution[add_item] = 1\n                    current_weight += weight_lst[add_item]\n                    current_value1, current_value2 = new_value1, new_value2\n                    threshold1 = current_value1 * 0.9\n                    threshold2 = current_value2 * 0.9\n\n        # Probabilistic removal of items\n        if random.random() < 0.3 and len(items_in) > 0:\n            remove_item = random.choice(items_in)\n            new_value1 = current_value1 - value1_lst[remove_item]\n            new_value2 = current_value2 - value2_lst[remove_item]\n            if new_value1 > threshold1 or new_value2 > threshold2:\n                new_solution[remove_item] = 0\n                current_weight -= weight_lst[remove_item]\n                current_value1, current_value2 = new_value1, new_value2\n                threshold1 = current_value1 * 0.9\n                threshold2 = current_value2 * 0.9\n\n    return new_solution\n\n",
        "score": [
            -19.11770475647412,
            -18.582942881749123
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on the highest combined objective values, then applies a novel hybrid local search that combines item swaps with a probabilistic replacement strategy, but with a focus on diversifying the search by considering both objectives separately and using a temperature-based acceptance criterion to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmax(archive_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    temperature = 1.0\n\n    # Hybrid local search with temperature-based acceptance\n    for _ in range(5):  # Increased iterations for better exploration\n        # Step 1: Randomly select items to swap or replace\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Swap one item in with one item out\n            swap_in = random.choice(items_in)\n            swap_out = random.choice(items_out)\n\n            # Check feasibility after swap\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                # Accept if better or with probability based on temperature\n                delta_value1 = value1_lst[swap_out] - value1_lst[swap_in]\n                delta_value2 = value2_lst[swap_out] - value2_lst[swap_in]\n\n                if delta_value1 > 0 or delta_value2 > 0 or random.random() < temperature:\n                    new_solution[swap_in] = 0\n                    new_solution[swap_out] = 1\n                    current_weight = new_weight\n\n        # Step 2: Probabilistic replacement with temperature adjustment\n        if random.random() < 0.4:  # Higher chance to add\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                add_item = random.choice(candidate_items)\n                if current_weight + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n                    current_weight += weight_lst[add_item]\n\n        if random.random() < 0.3:  # Higher chance to remove\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                remove_item = random.choice(candidate_items)\n                new_solution[remove_item] = 0\n                current_weight -= weight_lst[remove_item]\n\n        # Cool down temperature\n        temperature *= 0.9\n\n    return new_solution\n\n",
        "score": [
            -19.026962290436575,
            -18.70476485054651
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive with the highest normalized objective values, then applies a hybrid local search that combines item swaps with a probabilistic replacement strategy, using a dynamic probability threshold that adapts based on the current solution's quality and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalize objectives and select solution with highest normalized sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    combined_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic probability threshold based on solution quality\n    current_obj = archive[selected_idx][1]\n    max_obj = np.max(objectives, axis=0)\n    quality_ratio = np.mean(current_obj / max_obj)\n    prob_add = min(0.5, 0.1 + quality_ratio * 0.3)\n    prob_remove = min(0.4, 0.05 + quality_ratio * 0.2)\n\n    # Hybrid local search with dynamic probabilities\n    for _ in range(4):\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            swap_in = random.choice(items_in)\n            swap_out = random.choice(items_out)\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        if random.random() < prob_add:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                add_item = random.choice(candidate_items)\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < prob_remove:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                remove_item = random.choice(candidate_items)\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.051043449233482,
            -18.672814681737716
        ]
    },
    {
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with the highest combined objective values, then applies a novel hybrid local search that combines item swaps with a probabilistic replacement strategy to explore diverse neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmax(archive_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic item swaps and replacements\n    for _ in range(3):  # Number of iterations\n        # Step 1: Randomly select items to swap or replace\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Swap one item in with one item out\n            swap_in = random.choice(items_in)\n            swap_out = random.choice(items_out)\n\n            # Check feasibility after swap\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Step 2: Probabilistic replacement (add or remove with probability)\n        if random.random() < 0.3:  # 30% chance to add an item\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                add_item = random.choice(candidate_items)\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:  # 20% chance to remove an item\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                remove_item = random.choice(candidate_items)\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.185482724098307,
            -18.5552203582161
        ]
    }
]