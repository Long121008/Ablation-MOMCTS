[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with high variance in objective values, then applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((o - mean) ** 2 for o in obj) / 3\n        return variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.48242544616592165,
            1.9872871041297913
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((o - mean) ** 2 for o in obj) / 3\n        return variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = sum(obj) / 3\n        return -sum((o - mean_obj) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves with objective-aware selection\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Calculate potential improvement for each move\n        def improvement(move):\n            if move == '2opt':\n                temp = new_solution.copy()\n                temp[i:j+1] = temp[i:j+1][::-1]\n                return sum(distance_matrix_1[temp[i-1], temp[i]] + distance_matrix_2[temp[i-1], temp[i]] + distance_matrix_3[temp[i-1], temp[i]] for i in range(1, n)) - sum(distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_3[base_solution[i-1], base_solution[i]] for i in range(1, n))\n            else:\n                temp = new_solution.copy()\n                temp[i:k+1] = temp[i:k+1][::-1]\n                temp[k:j+1] = temp[k:j+1][::-1]\n                return sum(distance_matrix_1[temp[i-1], temp[i]] + distance_matrix_2[temp[i-1], temp[i]] + distance_matrix_3[temp[i-1], temp[i]] for i in range(1, n)) - sum(distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_3[base_solution[i-1], base_solution[i]] for i in range(1, n))\n\n        # Select move with highest improvement\n        move = '2opt' if improvement('2opt') < improvement('3opt') else '3opt'\n\n        if move == '2opt':\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9104409288285227,
            2.3208115339279174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = sum(obj) / 3\n        return -sum((o - mean_obj) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves with objective-aware selection\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Calculate potential improvement for each move\n        def improvement(move):\n            if move == '2opt':\n                temp = new_solution.copy()\n                temp[i:j+1] = temp[i:j+1][::-1]\n                return sum(distance_matrix_1[temp[i-1], temp[i]] + distance_matrix_2[temp[i-1], temp[i]] + distance_matrix_3[temp[i-1], temp[i]] for i in range(1, n)) - sum(distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_3[base_solution[i-1], base_solution[i]] for i in range(1, n))\n            else:\n                temp = new_solution.copy()\n                temp[i:k+1] = temp[i:k+1][::-1]\n                temp[k:j+1] = temp[k:j+1][::-1]\n                return sum(distance_matrix_1[temp[i-1], temp[i]] + distance_matrix_2[temp[i-1], temp[i]] + distance_matrix_3[temp[i-1], temp[i]] for i in range(1, n)) - sum(distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_3[base_solution[i-1], base_solution[i]] for i in range(1, n))\n\n        # Select move with highest improvement\n        move = '2opt' if improvement('2opt') < improvement('3opt') else '3opt'\n\n        if move == '2opt':\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9646913656838745,
            1.543290877342224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9646913656838745,
            1.543290877342224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objective values and applies a hybrid local search operator that combines 4-opt and random segment reversal, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n        l = random.randint(k, j) if j - k >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            random.shuffle(segment)\n            new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.463802439859621,
            1.3473583221435548
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n        l = random.randint(k, j) if j - k >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            random.shuffle(segment)\n            new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with extreme objective values and applies a novel local search operator that combines edge insertion, reversal, and segment rotation moves, guided by a multi-objective improvement metric to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        move_type = random.random()\n\n        if move_type < 0.3:\n            # Edge insertion\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate((new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]))\n        elif move_type < 0.6:\n            # Segment reversal\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Segment rotation\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(1, j-i)\n            segment = new_solution[i:j+1]\n            new_solution[i:j+1] = np.concatenate((segment[k:], segment[:k]))\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.3852389833045872,
            1.4073992013931274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        move_type = random.random()\n\n        if move_type < 0.3:\n            # Edge insertion\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate((new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]))\n        elif move_type < 0.6:\n            # Segment reversal\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Segment rotation\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(1, j-i)\n            segment = new_solution[i:j+1]\n            new_solution[i:j+1] = np.concatenate((segment[k:], segment[:k]))\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 306,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with extreme objective values (either very high or very low in at least one objective) and applies a novel segment-based local search operator that combines 4-opt and relocate moves, guided by a domination-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 3 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = np.roll(new_solution[i:k+1], 1)\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.42848058504502057,
            1.023428452014923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 3 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = np.roll(new_solution[i:k+1], 1)\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    }
]