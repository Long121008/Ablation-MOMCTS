[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.40532918900017434,
            1.3282345056533813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.40532918900017434,
            1.3282345056533813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.40532918900017434,
            1.3282345056533813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt for each objective space\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three objectives to focus on for the 2-opt\n    obj_choice = np.random.choice([0, 1, 2])\n\n    # Perform 2-opt on the selected objective's distance matrix\n    if obj_choice == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        # Avoid reversing the entire tour\n        i, j = 1, n - 2\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7550461050889035,
            1.7214922904968262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt for each objective space\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three objectives to focus on for the 2-opt\n    obj_choice = np.random.choice([0, 1, 2])\n\n    # Perform 2-opt on the selected objective's distance matrix\n    if obj_choice == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        # Avoid reversing the entire tour\n        i, j = 1, n - 2\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt for each objective space\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three objectives to focus on for the 2-opt\n    obj_choice = np.random.choice([0, 1, 2])\n\n    # Perform 2-opt on the selected objective's distance matrix\n    if obj_choice == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        # Avoid reversing the entire tour\n        i, j = 1, n - 2\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7550461050889035,
            1.7214922904968262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt for each objective space\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three objectives to focus on for the 2-opt\n    obj_choice = np.random.choice([0, 1, 2])\n\n    # Perform 2-opt on the selected objective's distance matrix\n    if obj_choice == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        # Avoid reversing the entire tour\n        i, j = 1, n - 2\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1])**2 + (x[1][1] - x[1][2])**2 + (x[1][2] - x[1][0])**2)[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure valid 2-opt move\n    if i != k and j != l:\n        # Apply 2-opt\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Further refine by selecting edges that improve the worst objective\n        for _ in range(2):\n            worst_obj = np.argmax([sum(distance_matrix_1[new_solution]), sum(distance_matrix_2[new_solution]), sum(distance_matrix_3[new_solution])])\n            if worst_obj == 0:\n                mat = distance_matrix_1\n            elif worst_obj == 1:\n                mat = distance_matrix_2\n            else:\n                mat = distance_matrix_3\n\n            # Find the two edges with the highest cost in the worst objective\n            max_cost = -1\n            best_i, best_j = 0, 1\n            for i in range(n):\n                for j in range(i+1, n):\n                    cost = mat[new_solution[i-1], new_solution[i]] + mat[new_solution[j-1], new_solution[j]]\n                    if cost > max_cost:\n                        max_cost = cost\n                        best_i, best_j = i, j\n\n            # Apply 2-opt for the worst objective\n            if best_i != best_j:\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5394069086618529,
            2.934069538116455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1])**2 + (x[1][1] - x[1][2])**2 + (x[1][2] - x[1][0])**2)[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure valid 2-opt move\n    if i != k and j != l:\n        # Apply 2-opt\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Further refine by selecting edges that improve the worst objective\n        for _ in range(2):\n            worst_obj = np.argmax([sum(distance_matrix_1[new_solution]), sum(distance_matrix_2[new_solution]), sum(distance_matrix_3[new_solution])])\n            if worst_obj == 0:\n                mat = distance_matrix_1\n            elif worst_obj == 1:\n                mat = distance_matrix_2\n            else:\n                mat = distance_matrix_3\n\n            # Find the two edges with the highest cost in the worst objective\n            max_cost = -1\n            best_i, best_j = 0, 1\n            for i in range(n):\n                for j in range(i+1, n):\n                    cost = mat[new_solution[i-1], new_solution[i]] + mat[new_solution[j-1], new_solution[j]]\n                    if cost > max_cost:\n                        max_cost = cost\n                        best_i, best_j = i, j\n\n            # Apply 2-opt for the worst objective\n            if best_i != best_j:\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective diversity and solution quality, then applies a multi-objective-aware local search operator that combines insertion and inversion moves, guided by a Pareto-dominance-aware objective function to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def selection_criterion(solution):\n        obj = archive[solution][1]\n        # Weighted combination of objective diversity and solution quality\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        quality = sum(obj)\n        return diversity * 0.6 + quality * 0.4\n\n    selected_idx = max(range(len(archive)), key=lambda i: selection_criterion(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective-aware local search\n    n = len(new_solution)\n    for _ in range(5):\n        # Select a segment to modify\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Randomly choose between insertion and inversion\n        if random.random() < 0.5:\n            # Insertion move\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n            insert_pos = random.randint(0, n - (j - i + 1))\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n        else:\n            # Inversion move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.3702801632471806,
            1.3553430914878846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def selection_criterion(solution):\n        obj = archive[solution][1]\n        # Weighted combination of objective diversity and solution quality\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        quality = sum(obj)\n        return diversity * 0.6 + quality * 0.4\n\n    selected_idx = max(range(len(archive)), key=lambda i: selection_criterion(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective-aware local search\n    n = len(new_solution)\n    for _ in range(5):\n        # Select a segment to modify\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Randomly choose between insertion and inversion\n        if random.random() < 0.5:\n            # Insertion move\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n            insert_pos = random.randint(0, n - (j - i + 1))\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n        else:\n            # Inversion move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt for each objective space\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three objectives to focus on for the 2-opt\n    obj_choice = np.random.choice([0, 1, 2])\n\n    # Perform 2-opt on the selected objective's distance matrix\n    if obj_choice == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        # Avoid reversing the entire tour\n        i, j = 1, n - 2\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt for each objective space\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three objectives to focus on for the 2-opt\n    obj_choice = np.random.choice([0, 1, 2])\n\n    # Perform 2-opt on the selected objective's distance matrix\n    if obj_choice == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        # Avoid reversing the entire tour\n        i, j = 1, n - 2\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions to swap\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform three-way swap to create a new solution\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = new_solution[k]\n    new_solution[k] = temp\n\n    # Verify feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6885683866126922,
            1.5115750551223754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions to swap\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Perform three-way swap to create a new solution\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = new_solution[k]\n    new_solution[k] = temp\n\n    # Verify feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt for each objective space\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three objectives to focus on for the 2-opt\n    obj_choice = np.random.choice([0, 1, 2])\n\n    # Perform 2-opt on the selected objective's distance matrix\n    if obj_choice == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        # Avoid reversing the entire tour\n        i, j = 1, n - 2\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective diversity and Pareto-front proximity, then applies a hybrid local search that dynamically adapts between 2-opt and 4-opt moves, guided by a multi-objective improvement heuristic to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution based on combined diversity and Pareto-front metrics\n    def selection_metric(solution):\n        obj = solution[1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        pareto_score = sum(1 for sol in archive if (obj[0] <= sol[1][0] and obj[1] <= sol[1][1] and obj[2] <= sol[1][2]))\n        return diversity * pareto_score\n\n    selected_idx = max(range(len(archive)), key=lambda i: selection_metric(archive[i]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search with dynamic move selection\n    for _ in range(3):\n        # Randomly select segments for modification\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Dynamic move selection based on objective improvement potential\n        obj_improvement = []\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            current_cost = sum(dm[base_solution[i], base_solution[i+1]] for i in range(n-1)) + dm[base_solution[-1], base_solution[0]]\n\n            # Test 4-opt move\n            temp_sol = base_solution.copy()\n            temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n            temp_sol[j:k+1] = temp_sol[j:k+1][::-1]\n            new_cost = sum(dm[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + dm[temp_sol[-1], temp_sol[0]]\n            obj_improvement.append(current_cost - new_cost)\n\n        # Select move that shows most improvement across objectives\n        best_move = np.argmax(obj_improvement)\n\n        # Apply the best move\n        if best_move == 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n        elif best_move == 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            base_solution = new_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5621413941604627,
            3.4388490200042723
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution based on combined diversity and Pareto-front metrics\n    def selection_metric(solution):\n        obj = solution[1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        pareto_score = sum(1 for sol in archive if (obj[0] <= sol[1][0] and obj[1] <= sol[1][1] and obj[2] <= sol[1][2]))\n        return diversity * pareto_score\n\n    selected_idx = max(range(len(archive)), key=lambda i: selection_metric(archive[i]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search with dynamic move selection\n    for _ in range(3):\n        # Randomly select segments for modification\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Dynamic move selection based on objective improvement potential\n        obj_improvement = []\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            current_cost = sum(dm[base_solution[i], base_solution[i+1]] for i in range(n-1)) + dm[base_solution[-1], base_solution[0]]\n\n            # Test 4-opt move\n            temp_sol = base_solution.copy()\n            temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n            temp_sol[j:k+1] = temp_sol[j:k+1][::-1]\n            new_cost = sum(dm[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + dm[temp_sol[-1], temp_sol[0]]\n            obj_improvement.append(current_cost - new_cost)\n\n        # Select move that shows most improvement across objectives\n        best_move = np.argmax(obj_improvement)\n\n        # Apply the best move\n        if best_move == 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n        elif best_move == 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            base_solution = new_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines segment inversion and node reinsertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            # Segment inversion with multiple segments\n            segments = sorted(random.sample(range(n), 2))\n            new_solution[segments[0]:segments[1]+1] = new_solution[segments[0]:segments[1]+1][::-1]\n        else:\n            # Node reinsertion with multiple nodes\n            nodes_to_move = sorted(random.sample(range(n), min(3, n)))\n            for node in nodes_to_move:\n                pos = np.where(new_solution == node)[0][0]\n                new_solution = np.delete(new_solution, pos)\n                new_pos = random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, new_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4161185428082671,
            1.856674110889435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            # Segment inversion with multiple segments\n            segments = sorted(random.sample(range(n), 2))\n            new_solution[segments[0]:segments[1]+1] = new_solution[segments[0]:segments[1]+1][::-1]\n        else:\n            # Node reinsertion with multiple nodes\n            nodes_to_move = sorted(random.sample(range(n), min(3, n)))\n            for node in nodes_to_move:\n                pos = np.where(new_solution == node)[0][0]\n                new_solution = np.delete(new_solution, pos)\n                new_pos = random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, new_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt for each objective space\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three objectives to focus on for the 2-opt\n    obj_choice = np.random.choice([0, 1, 2])\n\n    # Perform 2-opt on the selected objective's distance matrix\n    if obj_choice == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        # Avoid reversing the entire tour\n        i, j = 1, n - 2\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with high objective diversity, then applies a hybrid local search that combines 2-opt moves with a novel \"objective-aware edge swapping\" operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high objective diversity\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Perform 2-opt move\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware edge swapping\n        if np.random.random() < 0.5:\n            obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights for simplicity\n            obj_weights[np.argmin(archive[selected_idx][1])] = 2.0  # Double weight for worst objective\n\n            # Find edges with high weighted cost\n            edges = [(k, (k+1)%n) for k in range(n)]\n            edge_costs = []\n            for u, v in edges:\n                cost = (obj_weights[0] * distance_matrix_1[new_solution[u], new_solution[v]] +\n                        obj_weights[1] * distance_matrix_2[new_solution[u], new_solution[v]] +\n                        obj_weights[2] * distance_matrix_3[new_solution[u], new_solution[v]])\n                edge_costs.append(cost)\n\n            # Swap the two most expensive edges\n            if len(edge_costs) >= 2:\n                expensive_edges = sorted(range(len(edge_costs)), key=lambda x: -edge_costs[x])[:2]\n                u1, v1 = edges[expensive_edges[0]]\n                u2, v2 = edges[expensive_edges[1]]\n                new_solution[u1], new_solution[v2] = new_solution[v2], new_solution[u1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.49653044180029793,
            1.902536690235138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high objective diversity\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Perform 2-opt move\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware edge swapping\n        if np.random.random() < 0.5:\n            obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights for simplicity\n            obj_weights[np.argmin(archive[selected_idx][1])] = 2.0  # Double weight for worst objective\n\n            # Find edges with high weighted cost\n            edges = [(k, (k+1)%n) for k in range(n)]\n            edge_costs = []\n            for u, v in edges:\n                cost = (obj_weights[0] * distance_matrix_1[new_solution[u], new_solution[v]] +\n                        obj_weights[1] * distance_matrix_2[new_solution[u], new_solution[v]] +\n                        obj_weights[2] * distance_matrix_3[new_solution[u], new_solution[v]])\n                edge_costs.append(cost)\n\n            # Swap the two most expensive edges\n            if len(edge_costs) >= 2:\n                expensive_edges = sorted(range(len(edge_costs)), key=lambda x: -edge_costs[x])[:2]\n                u1, v1 = edges[expensive_edges[0]]\n                u2, v2 = edges[expensive_edges[1]]\n                new_solution[u1], new_solution[v2] = new_solution[v2], new_solution[u1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines edge swaps and segment reversals, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps and segment reversals\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Edge swap with probability 0.6\n        if random.random() < 0.6:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Segment reversal with probability 0.4\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8007250218800955,
            1.4610509753227234
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps and segment reversals\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Edge swap with probability 0.6\n        if random.random() < 0.6:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Segment reversal with probability 0.4\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines edge swaps and segment reversals, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps and segment reversals\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Edge swap with probability 0.6\n        if random.random() < 0.6:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Segment reversal with probability 0.4\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8007250218800955,
            1.4610509753227234
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps and segment reversals\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Edge swap with probability 0.6\n        if random.random() < 0.6:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Segment reversal with probability 0.4\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt for each objective space\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three objectives to focus on for the 2-opt\n    obj_choice = np.random.choice([0, 1, 2])\n\n    # Perform 2-opt on the selected objective's distance matrix\n    if obj_choice == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        # Avoid reversing the entire tour\n        i, j = 1, n - 2\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt for each objective space\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three objectives to focus on for the 2-opt\n    obj_choice = np.random.choice([0, 1, 2])\n\n    # Perform 2-opt on the selected objective's distance matrix\n    if obj_choice == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        # Avoid reversing the entire tour\n        i, j = 1, n - 2\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.45161763780934516,
            1.8349873185157777
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt for each objective space\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three objectives to focus on for the 2-opt\n    obj_choice = np.random.choice([0, 1, 2])\n\n    # Perform 2-opt on the selected objective's distance matrix\n    if obj_choice == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        # Avoid reversing the entire tour\n        i, j = 1, n - 2\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt for each objective space\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three objectives to focus on for the 2-opt\n    obj_choice = np.random.choice([0, 1, 2])\n\n    # Perform 2-opt on the selected objective's distance matrix\n    if obj_choice == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        # Avoid reversing the entire tour\n        i, j = 1, n - 2\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt for each objective space\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three objectives to focus on for the 2-opt\n    obj_choice = np.random.choice([0, 1, 2])\n\n    # Perform 2-opt on the selected objective's distance matrix\n    if obj_choice == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        # Avoid reversing the entire tour\n        i, j = 1, n - 2\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{The new algorithm will select a solution from the archive based on a weighted combination of objective values, then apply a multi-objective 2-opt local search that considers all three objectives simultaneously by randomly selecting segments to reverse and evaluating their impact across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.rand(3)\n    selected_solution = max(archive, key=lambda x: np.dot(x[1], weights))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective 2-opt: randomly select segments and evaluate impact on all objectives\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        i, j = 1, n - 2  # Avoid full reversal\n\n    # Create candidate solution\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Calculate objective improvements\n    def calculate_objectives(sol):\n        obj1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        obj2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        obj3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objectives(new_solution)\n    candidate_obj = calculate_objectives(candidate)\n\n    # Accept if at least one objective improves\n    if any(candidate_obj[k] < current_obj[k] for k in range(3)):\n        new_solution = candidate\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.597790615585013,
            2.297228467464447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.rand(3)\n    selected_solution = max(archive, key=lambda x: np.dot(x[1], weights))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective 2-opt: randomly select segments and evaluate impact on all objectives\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        i, j = 1, n - 2  # Avoid full reversal\n\n    # Create candidate solution\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Calculate objective improvements\n    def calculate_objectives(sol):\n        obj1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        obj2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        obj3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objectives(new_solution)\n    candidate_obj = calculate_objectives(candidate)\n\n    # Accept if at least one objective improves\n    if any(candidate_obj[k] < current_obj[k] for k in range(3)):\n        new_solution = candidate\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel hybrid local search operator that combines segment reversal, insertion, and relinking moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel hybrid local search: segment reversal, insertion, and relinking\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        move_type = random.random()\n\n        if move_type < 0.4:  # Segment reversal\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif move_type < 0.7:  # Insertion\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n        else:  # Relinking\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.3902951437870062,
            1.8127164840698242
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel hybrid local search: segment reversal, insertion, and relinking\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        move_type = random.random()\n\n        if move_type < 0.4:  # Segment reversal\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif move_type < 0.7:  # Insertion\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n        else:  # Relinking\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt for each objective space\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three objectives to focus on for the 2-opt\n    obj_choice = np.random.choice([0, 1, 2])\n\n    # Perform 2-opt on the selected objective's distance matrix\n    if obj_choice == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        # Avoid reversing the entire tour\n        i, j = 1, n - 2\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{A novel tri-objective local search algorithm that intelligently selects solutions from the archive based on their normalized objective values, then applies a hybrid 2-opt with adaptive edge selection and objective weighting to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    scores = np.mean(normalized, axis=1)  # Balance across objectives\n\n    # Select top 30% solutions with highest scores\n    top_indices = np.argsort(scores)[-max(1, len(archive) // 3):]\n    selected_idx = np.random.choice(top_indices)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Adaptive 2-opt with objective weighting\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamically weight objectives based on current solution's performance\n    obj_weights = np.random.dirichlet(np.ones(3))  # Random weights sum to 1\n    weighted_distances = (obj_weights[0] * distance_matrix_1 +\n                         obj_weights[1] * distance_matrix_2 +\n                         obj_weights[2] * distance_matrix_3)\n\n    # Select edges to reverse based on weighted distances\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        i, j = 1, n - 2  # Avoid complete reversal\n\n    # Perform 2-opt with weighted distance consideration\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5840502858942054,
            2.203506624698639
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    scores = np.mean(normalized, axis=1)  # Balance across objectives\n\n    # Select top 30% solutions with highest scores\n    top_indices = np.argsort(scores)[-max(1, len(archive) // 3):]\n    selected_idx = np.random.choice(top_indices)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Adaptive 2-opt with objective weighting\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamically weight objectives based on current solution's performance\n    obj_weights = np.random.dirichlet(np.ones(3))  # Random weights sum to 1\n    weighted_distances = (obj_weights[0] * distance_matrix_1 +\n                         obj_weights[1] * distance_matrix_2 +\n                         obj_weights[2] * distance_matrix_3)\n\n    # Select edges to reverse based on weighted distances\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == 0 and j == n - 1:\n        i, j = 1, n - 2  # Avoid complete reversal\n\n    # Perform 2-opt with weighted distance consideration\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 4-opt and edge insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge insertion moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.6:\n            # 4-opt move\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[b+1:c+1]\n            segment3 = new_solution[c+1:d+1]\n            new_solution[a:d+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n        else:\n            # Edge insertion move\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8726812664793362,
            1.5832682251930237
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge insertion moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.6:\n            # 4-opt move\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[b+1:c+1]\n            segment3 = new_solution[c+1:d+1]\n            new_solution[a:d+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n        else:\n            # Edge insertion move\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 4-opt and edge insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge insertion moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.6:\n            # 4-opt move\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[b+1:c+1]\n            segment3 = new_solution[c+1:d+1]\n            new_solution[a:d+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n        else:\n            # Edge insertion move\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8726812664793362,
            1.5832682251930237
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge insertion moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.6:\n            # 4-opt move\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[b+1:c+1]\n            segment3 = new_solution[c+1:d+1]\n            new_solution[a:d+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n        else:\n            # Edge insertion move\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{This algorithm selects a solution from the archive based on its proximity to the Pareto front and applies a novel segment-based local search that combines adaptive edge swaps and objective-aware node relocations to generate a neighbor solution, ensuring feasibility and promoting diverse improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution closest to the Pareto front\n    def pareto_distance(solution):\n        obj = archive[solution][1]\n        return min(abs(obj[0] - obj[1]), abs(obj[1] - obj[2]), abs(obj[2] - obj[0]))\n\n    selected_idx = min(range(len(archive)), key=lambda i: pareto_distance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, n // 5)\n\n    # Adaptive segment-based local search\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Objective-aware segment operation\n        obj_weights = [1.0, 1.0, 1.0]\n        for i in range(3):\n            if archive[selected_idx][1][i] > np.median([x[1][i] for x in archive]):\n                obj_weights[i] = 1.5\n\n        # Apply weighted segment operation\n        if random.random() < 0.6:\n            # Reverse segment with probability based on objective weights\n            prob = [obj_weights[0], obj_weights[1], obj_weights[2]]\n            if random.choices([0, 1, 2], weights=prob, k=1)[0] == 0:\n                new_solution[start:end] = new_solution[start:end][::-1]\n            else:\n                # Node relocation within segment\n                node = random.choice(new_solution[start:end])\n                pos = np.where(new_solution == node)[0][0]\n                new_pos = random.randint(start, end - 1)\n                if pos != new_pos:\n                    new_solution[pos], new_solution[new_pos] = new_solution[new_pos], new_solution[pos]\n        else:\n            # Edge swap with objective-aware selection\n            i = random.randint(start, end - 1)\n            j = random.randint(start, end - 1)\n            if i != j:\n                if random.choices([0, 1, 2], weights=obj_weights, k=1)[0] == 0:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.714247565148896,
            3.1245516896247865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution closest to the Pareto front\n    def pareto_distance(solution):\n        obj = archive[solution][1]\n        return min(abs(obj[0] - obj[1]), abs(obj[1] - obj[2]), abs(obj[2] - obj[0]))\n\n    selected_idx = min(range(len(archive)), key=lambda i: pareto_distance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, n // 5)\n\n    # Adaptive segment-based local search\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Objective-aware segment operation\n        obj_weights = [1.0, 1.0, 1.0]\n        for i in range(3):\n            if archive[selected_idx][1][i] > np.median([x[1][i] for x in archive]):\n                obj_weights[i] = 1.5\n\n        # Apply weighted segment operation\n        if random.random() < 0.6:\n            # Reverse segment with probability based on objective weights\n            prob = [obj_weights[0], obj_weights[1], obj_weights[2]]\n            if random.choices([0, 1, 2], weights=prob, k=1)[0] == 0:\n                new_solution[start:end] = new_solution[start:end][::-1]\n            else:\n                # Node relocation within segment\n                node = random.choice(new_solution[start:end])\n                pos = np.where(new_solution == node)[0][0]\n                new_pos = random.randint(start, end - 1)\n                if pos != new_pos:\n                    new_solution[pos], new_solution[new_pos] = new_solution[new_pos], new_solution[pos]\n        else:\n            # Edge swap with objective-aware selection\n            i = random.randint(start, end - 1)\n            j = random.randint(start, end - 1)\n            if i != j:\n                if random.choices([0, 1, 2], weights=obj_weights, k=1)[0] == 0:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel multi-objective local search operator that combines 2-opt, 3-opt, and a new \"objective-aware\" move guided by the Pareto front to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.choices(['2-opt', '3-opt', 'objective-aware'], weights=[0.3, 0.3, 0.4])[0]\n\n        if move_type == '2-opt':\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type == '3-opt':\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            obj_weights = np.array(archive[selected_idx][1])\n            obj_weights = obj_weights / np.sum(obj_weights)\n            selected_obj = np.random.choice(3, p=obj_weights)\n            if selected_obj == 0:\n                dist_matrix = distance_matrix_1\n            elif selected_obj == 1:\n                dist_matrix = distance_matrix_2\n            else:\n                dist_matrix = distance_matrix_3\n            current_cost = sum(dist_matrix[new_solution[i], new_solution[i+1]] for i in range(n-1)) + dist_matrix[new_solution[-1], new_solution[0]]\n            for _ in range(3):\n                temp_solution = new_solution.copy()\n                l, m = sorted(random.sample(range(n), 2))\n                temp_solution[l:m+1] = temp_solution[l:m+1][::-1]\n                new_cost = sum(dist_matrix[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + dist_matrix[temp_solution[-1], temp_solution[0]]\n                if new_cost < current_cost:\n                    new_solution = temp_solution\n                    break\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.41195321098175147,
            2.263648796081543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.choices(['2-opt', '3-opt', 'objective-aware'], weights=[0.3, 0.3, 0.4])[0]\n\n        if move_type == '2-opt':\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type == '3-opt':\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            obj_weights = np.array(archive[selected_idx][1])\n            obj_weights = obj_weights / np.sum(obj_weights)\n            selected_obj = np.random.choice(3, p=obj_weights)\n            if selected_obj == 0:\n                dist_matrix = distance_matrix_1\n            elif selected_obj == 1:\n                dist_matrix = distance_matrix_2\n            else:\n                dist_matrix = distance_matrix_3\n            current_cost = sum(dist_matrix[new_solution[i], new_solution[i+1]] for i in range(n-1)) + dist_matrix[new_solution[-1], new_solution[0]]\n            for _ in range(3):\n                temp_solution = new_solution.copy()\n                l, m = sorted(random.sample(range(n), 2))\n                temp_solution[l:m+1] = temp_solution[l:m+1][::-1]\n                new_cost = sum(dist_matrix[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + dist_matrix[temp_solution[-1], temp_solution[0]]\n                if new_cost < current_cost:\n                    new_solution = temp_solution\n                    break\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and their normalized differences, then applies a hybrid local search combining 4-opt and inversion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement using weighted objective differences\n    def selection_score(solution):\n        obj = archive[solution][1]\n        max_obj = max(obj)\n        normalized_diff = (abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])) / (max_obj + 1e-10)\n        weighted_score = 0.6 * (obj[0] + obj[1] + obj[2]) + 0.4 * normalized_diff\n        return weighted_score\n\n    selected_idx = max(range(len(archive)), key=lambda i: selection_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and inversion moves\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n        l = random.randint(k, j) if j - k >= 2 else j\n\n        # 4-opt move\n        if random.random() < 0.6:\n            segment1 = new_solution[i:k+1][::-1]\n            segment2 = new_solution[k+1:l+1][::-1]\n            segment3 = new_solution[l+1:j+1][::-1]\n            new_solution[i:j+1] = np.concatenate([segment1, segment2, segment3])\n        # Inversion move\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7304811862217816,
            1.7878453254699707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement using weighted objective differences\n    def selection_score(solution):\n        obj = archive[solution][1]\n        max_obj = max(obj)\n        normalized_diff = (abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])) / (max_obj + 1e-10)\n        weighted_score = 0.6 * (obj[0] + obj[1] + obj[2]) + 0.4 * normalized_diff\n        return weighted_score\n\n    selected_idx = max(range(len(archive)), key=lambda i: selection_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and inversion moves\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n        l = random.randint(k, j) if j - k >= 2 else j\n\n        # 4-opt move\n        if random.random() < 0.6:\n            segment1 = new_solution[i:k+1][::-1]\n            segment2 = new_solution[k+1:l+1][::-1]\n            segment3 = new_solution[l+1:j+1][::-1]\n            new_solution[i:j+1] = np.concatenate([segment1, segment2, segment3])\n        # Inversion move\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel segment-based local search operator that combines adaptive segment reversal and segment insertion, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = segment[::-1]\n        else:\n            k = random.randint(0, n - len(segment))\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.36320063961956217,
            1.2862114191055298
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = segment[::-1]\n        else:\n            k = random.randint(0, n - len(segment))\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel segment-based local search operator that combines adaptive segment reversal and segment insertion, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = segment[::-1]\n        else:\n            k = random.randint(0, n - len(segment))\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.36320063961956217,
            1.2862114191055298
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = segment[::-1]\n        else:\n            k = random.randint(0, n - len(segment))\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with the worst objective values in any dimension, then applies a novel segment-based local search that combines random segment reversal and segment insertion, guided by a multi-objective improvement metric to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with worst objective in any dimension\n    def worst_objective(solution):\n        obj = archive[solution][1]\n        return max(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: worst_objective(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based local search\n    n = len(new_solution)\n    for _ in range(5):\n        # Randomly select a segment\n        seg_start = random.randint(0, n-1)\n        seg_length = random.randint(2, min(5, n-1))\n        seg_end = min(seg_start + seg_length, n)\n\n        # Choose between segment reversal or insertion\n        if random.random() < 0.5:\n            # Segment reversal\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n        else:\n            # Segment insertion\n            if seg_end - seg_start > 1:\n                segment = new_solution[seg_start:seg_end]\n                new_solution = np.concatenate([\n                    new_solution[:seg_start],\n                    new_solution[seg_end:],\n                    segment\n                ])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.5130314637278224,
            1.5213144779205323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with worst objective in any dimension\n    def worst_objective(solution):\n        obj = archive[solution][1]\n        return max(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: worst_objective(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based local search\n    n = len(new_solution)\n    for _ in range(5):\n        # Randomly select a segment\n        seg_start = random.randint(0, n-1)\n        seg_length = random.randint(2, min(5, n-1))\n        seg_end = min(seg_start + seg_length, n)\n\n        # Choose between segment reversal or insertion\n        if random.random() < 0.5:\n            # Segment reversal\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n        else:\n            # Segment insertion\n            if seg_end - seg_start > 1:\n                segment = new_solution[seg_start:seg_end]\n                new_solution = np.concatenate([\n                    new_solution[:seg_start],\n                    new_solution[seg_end:],\n                    segment\n                ])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a novel combination of edge-swapping and segment-reversal operations to generate a neighbor solution, ensuring feasibility through careful validation of node visits.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1]) ** 2 + (obj[1] - obj[2]) ** 2 + (obj[2] - obj[0]) ** 2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: combination of edge-swapping and segment-reversal\n    n = len(new_solution)\n    for _ in range(3):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Edge-swapping\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Segment-reversal\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.44180683612318095,
            2.9850575804710386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1]) ** 2 + (obj[1] - obj[2]) ** 2 + (obj[2] - obj[0]) ** 2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: combination of edge-swapping and segment-reversal\n    n = len(new_solution)\n    for _ in range(3):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Edge-swapping\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Segment-reversal\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel local search operator that combines adaptive segment reversal and objective-weighted edge swaps to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement by prioritizing objective diversity\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: Adaptive segment reversal and objective-weighted edge swaps\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Adaptive segment reversal based on objective weights\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-weighted edge swap\n            weights = np.array([1.0, 1.0, 1.0])  # Equal weights for simplicity\n            obj = archive[selected_idx][1]\n            normalized_weights = weights / np.sum(weights)\n\n            # Select edges based on objective weights\n            if random.random() < normalized_weights[0]:\n                # Swap based on first objective\n                k = random.randint(i, j)\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            elif random.random() < normalized_weights[1]:\n                # Swap based on second objective\n                k = random.randint(i, j)\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n            else:\n                # Swap based on third objective\n                k = random.randint(i, j)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4662582240520101,
            2.6499611377716064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement by prioritizing objective diversity\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: Adaptive segment reversal and objective-weighted edge swaps\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Adaptive segment reversal based on objective weights\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-weighted edge swap\n            weights = np.array([1.0, 1.0, 1.0])  # Equal weights for simplicity\n            obj = archive[selected_idx][1]\n            normalized_weights = weights / np.sum(weights)\n\n            # Select edges based on objective weights\n            if random.random() < normalized_weights[0]:\n                # Swap based on first objective\n                k = random.randint(i, j)\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            elif random.random() < normalized_weights[1]:\n                # Swap based on second objective\n                k = random.randint(i, j)\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n            else:\n                # Swap based on third objective\n                k = random.randint(i, j)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with diverse objectives and applies a novel segment-shuffling local search operator that randomly reorders segments of the tour while ensuring feasibility, guided by a multi-objective improvement metric to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-shuffling local search\n    n = len(new_solution)\n    segment_size = max(2, n // 5)  # Minimum segment size of 2\n    num_segments = n // segment_size\n\n    for _ in range(3):  # Number of shuffling attempts\n        # Split into segments and shuffle\n        segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(num_segments)]\n        if n % segment_size != 0:\n            segments.append(new_solution[num_segments*segment_size:])\n\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.702480308369746,
            2.2740646481513975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-shuffling local search\n    n = len(new_solution)\n    segment_size = max(2, n // 5)  # Minimum segment size of 2\n    num_segments = n // segment_size\n\n    for _ in range(3):  # Number of shuffling attempts\n        # Split into segments and shuffle\n        segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(num_segments)]\n        if n % segment_size != 0:\n            segments.append(new_solution[num_segments*segment_size:])\n\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high objective variance and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high objective variance\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((x - mean) ** 2 for x in obj) / 3\n        return variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves with Pareto guidance\n    n = len(new_solution)\n    for _ in range(10):  # Increased perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move with Pareto guidance\n        if random.random() < 0.6:\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution\n        # 3-opt move with Pareto guidance\n        else:\n            temp_solution = new_solution.copy()\n            temp_solution[i:k+1] = temp_solution[i:k+1][::-1]\n            temp_solution[k:j+1] = temp_solution[k:j+1][::-1]\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.585033646930806,
            1.909060001373291
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high objective variance\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((x - mean) ** 2 for x in obj) / 3\n        return variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves with Pareto guidance\n    n = len(new_solution)\n    for _ in range(10):  # Increased perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move with Pareto guidance\n        if random.random() < 0.6:\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution\n        # 3-opt move with Pareto guidance\n        else:\n            temp_solution = new_solution.copy()\n            temp_solution[i:k+1] = temp_solution[i:k+1][::-1]\n            temp_solution[k:j+1] = temp_solution[k:j+1][::-1]\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with high objective values and applies a hybrid local search operator that combines edge insertion and node reversal moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_sum(solution):\n        obj = archive[solution][1]\n        return sum(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_sum(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and node reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion move\n        if random.random() < 0.6:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n        # Node reversal move\n        else:\n            k = random.randint(i, min(i + 3, n - 1))\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6993044123554376,
            1.4159451484680177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_sum(solution):\n        obj = archive[solution][1]\n        return sum(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_sum(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and node reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion move\n        if random.random() < 0.6:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n        # Node reversal move\n        else:\n            k = random.randint(i, min(i + 3, n - 1))\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel multi-objective local search operator that combines segment reversal and segment insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: segment reversal and insertion\n    n = len(new_solution)\n    for _ in range(5):\n        # Randomly select segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Segment reversal\n        if random.random() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n        # Segment insertion\n        else:\n            segment = new_solution[c:d]\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.3936557444348091,
            1.310489046573639
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: segment reversal and insertion\n    n = len(new_solution)\n    for _ in range(5):\n        # Randomly select segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Segment reversal\n        if random.random() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n        # Segment insertion\n        else:\n            segment = new_solution[c:d]\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{The algorithm selects a solution from the archive based on its objective diversity and applies a novel adaptive local search operator that dynamically combines 2-opt, 3-opt, and segment insertion moves, guided by a multi-objective improvement metric to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])) / max(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive local search: dynamic combination of moves\n    n = len(new_solution)\n    for _ in range(10):  # Increased perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Dynamic move selection based on objective diversity\n        move_prob = objective_diversity(selected_idx)\n        if random.random() < move_prob:\n            # 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif random.random() < 0.5 + move_prob/2:\n            # 3-opt move\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            # Segment insertion\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.38735454908635447,
            1.8829260110855102
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])) / max(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive local search: dynamic combination of moves\n    n = len(new_solution)\n    for _ in range(10):  # Increased perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Dynamic move selection based on objective diversity\n        move_prob = objective_diversity(selected_idx)\n        if random.random() < move_prob:\n            # 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif random.random() < 0.5 + move_prob/2:\n            # 3-opt move\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            # Segment insertion\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 4-opt and edge insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge insertion moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.6:\n            # 4-opt move\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[b+1:c+1]\n            segment3 = new_solution[c+1:d+1]\n            new_solution[a:d+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n        else:\n            # Edge insertion move\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with extreme objective values and applies a novel local search operator that combines node swapping with path reversal, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with extreme objective values\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: node swapping with path reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Node swapping\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Path reversal between i and j\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4181598276546031,
            1.3985074996948241
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with extreme objective values\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: node swapping with path reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Node swapping\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Path reversal between i and j\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by prioritizing those with extreme objective values and applies a hybrid local search operator that combines 4-opt and edge exchange moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with extreme objective values\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge exchange moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # 4-opt move\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        # Edge exchange move\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.45354057945105986,
            1.6554920196533203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with extreme objective values\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge exchange moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # 4-opt move\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        # Edge exchange move\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 4-opt and edge insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge insertion moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.6:\n            # 4-opt move\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[b+1:c+1]\n            segment3 = new_solution[c+1:d+1]\n            new_solution[a:d+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n        else:\n            # Edge insertion move\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with diverse objective values and applies a novel combination of 2-opt and crossover-based moves, guided by a Pareto-dominance-aware objective function, to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with diverse objectives\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and crossover-based moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.5:\n            # 2-opt move\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Crossover-based move (partial mapping crossover)\n            donor_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            donor = archive[donor_idx][0]\n            points = sorted(random.sample(range(n), 2))\n            a, b = points\n            segment = new_solution[a:b+1]\n            new_solution[a:b+1] = donor[a:b+1]\n            for i in range(a, b+1):\n                if new_solution[i] in segment:\n                    for j in range(a, b+1):\n                        if new_solution[j] == segment[i - a]:\n                            new_solution[i] = donor[j]\n                            break\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.3588780346993975,
            1.4810203313827515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with diverse objectives\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and crossover-based moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.5:\n            # 2-opt move\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Crossover-based move (partial mapping crossover)\n            donor_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            donor = archive[donor_idx][0]\n            points = sorted(random.sample(range(n), 2))\n            a, b = points\n            segment = new_solution[a:b+1]\n            new_solution[a:b+1] = donor[a:b+1]\n            for i in range(a, b+1):\n                if new_solution[i] in segment:\n                    for j in range(a, b+1):\n                        if new_solution[j] == segment[i - a]:\n                            new_solution[i] = donor[j]\n                            break\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9570524599335645,
            1.604290235042572
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9570524599335645,
            1.604290235042572
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 4-opt and edge insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge insertion moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.6:\n            # 4-opt move\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[b+1:c+1]\n            segment3 = new_solution[c+1:d+1]\n            new_solution[a:d+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n        else:\n            # Edge insertion move\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{The algorithm selects a solution with the highest potential for improvement by prioritizing those with unbalanced objectives, then applies a novel hybrid local search combining segment inversion, node relocation, and multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility through a feasibility-preserving mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with unbalanced objectives (high potential for improvement)\n    def objective_unbalance(solution):\n        obj = archive[solution][1]\n        return (max(obj) - min(obj)) ** 2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_unbalance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Segment inversion, node relocation, and multi-objective edge swaps\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        # Segment inversion\n        if random.random() < 0.4:\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Node relocation\n        elif random.random() < 0.7:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Multi-objective edge swap\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            # Calculate objective improvements for both possible swaps\n            def calculate_improvement(swap_solution):\n                obj1 = sum(distance_matrix_1[swap_solution[k], swap_solution[k+1]] for k in range(n-1)) + distance_matrix_1[swap_solution[-1], swap_solution[0]]\n                obj2 = sum(distance_matrix_2[swap_solution[k], swap_solution[k+1]] for k in range(n-1)) + distance_matrix_2[swap_solution[-1], swap_solution[0]]\n                obj3 = sum(distance_matrix_3[swap_solution[k], swap_solution[k+1]] for k in range(n-1)) + distance_matrix_3[swap_solution[-1], swap_solution[0]]\n                return (obj1, obj2, obj3)\n\n            # Try both possible swaps and choose the one that improves the most in any objective\n            swap1 = new_solution.copy()\n            swap1[i], swap1[j] = swap1[j], swap1[i]\n            obj1 = calculate_improvement(swap1)\n\n            swap2 = new_solution.copy()\n            swap2[i], swap2[j] = swap2[j], swap2[i]\n            obj2 = calculate_improvement(swap2)\n\n            # Select the swap that improves at least one objective\n            if sum(obj1) < sum(obj2):\n                new_solution = swap1\n            else:\n                new_solution = swap2\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.42585761903035146,
            1.3795466303825379
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with unbalanced objectives (high potential for improvement)\n    def objective_unbalance(solution):\n        obj = archive[solution][1]\n        return (max(obj) - min(obj)) ** 2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_unbalance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Segment inversion, node relocation, and multi-objective edge swaps\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        # Segment inversion\n        if random.random() < 0.4:\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Node relocation\n        elif random.random() < 0.7:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Multi-objective edge swap\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            # Calculate objective improvements for both possible swaps\n            def calculate_improvement(swap_solution):\n                obj1 = sum(distance_matrix_1[swap_solution[k], swap_solution[k+1]] for k in range(n-1)) + distance_matrix_1[swap_solution[-1], swap_solution[0]]\n                obj2 = sum(distance_matrix_2[swap_solution[k], swap_solution[k+1]] for k in range(n-1)) + distance_matrix_2[swap_solution[-1], swap_solution[0]]\n                obj3 = sum(distance_matrix_3[swap_solution[k], swap_solution[k+1]] for k in range(n-1)) + distance_matrix_3[swap_solution[-1], swap_solution[0]]\n                return (obj1, obj2, obj3)\n\n            # Try both possible swaps and choose the one that improves the most in any objective\n            swap1 = new_solution.copy()\n            swap1[i], swap1[j] = swap1[j], swap1[i]\n            obj1 = calculate_improvement(swap1)\n\n            swap2 = new_solution.copy()\n            swap2[i], swap2[j] = swap2[j], swap2[i]\n            obj2 = calculate_improvement(swap2)\n\n            # Select the swap that improves at least one objective\n            if sum(obj1) < sum(obj2):\n                new_solution = swap1\n            else:\n                new_solution = swap2\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{The algorithm selects the most balanced solution from the archive based on normalized objective values, then applies a novel multi-objective local search operator that combines edge swaps with objective-aware perturbations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalize objectives for balance selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    balance_scores = normalized.std(axis=1)\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: edge swaps with objective-aware perturbations\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Objective-aware edge swap\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Perturb based on worst objective\n            obj = archive[selected_idx][1]\n            worst_obj = np.argmax(obj)\n            if worst_obj == 0:\n                # Perturb in first objective space\n                new_solution[i:j+1] = sorted(new_solution[i:j+1], key=lambda x: distance_matrix_1[new_solution[i], x])\n            elif worst_obj == 1:\n                # Perturb in second objective space\n                new_solution[i:j+1] = sorted(new_solution[i:j+1], key=lambda x: distance_matrix_2[new_solution[i], x])\n            else:\n                # Perturb in third objective space\n                new_solution[i:j+1] = sorted(new_solution[i:j+1], key=lambda x: distance_matrix_3[new_solution[i], x])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6234173265761642,
            2.279980742931366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalize objectives for balance selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    balance_scores = normalized.std(axis=1)\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: edge swaps with objective-aware perturbations\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Objective-aware edge swap\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Perturb based on worst objective\n            obj = archive[selected_idx][1]\n            worst_obj = np.argmax(obj)\n            if worst_obj == 0:\n                # Perturb in first objective space\n                new_solution[i:j+1] = sorted(new_solution[i:j+1], key=lambda x: distance_matrix_1[new_solution[i], x])\n            elif worst_obj == 1:\n                # Perturb in second objective space\n                new_solution[i:j+1] = sorted(new_solution[i:j+1], key=lambda x: distance_matrix_2[new_solution[i], x])\n            else:\n                # Perturb in third objective space\n                new_solution[i:j+1] = sorted(new_solution[i:j+1], key=lambda x: distance_matrix_3[new_solution[i], x])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{The algorithm selects a solution from the archive based on its objective diversity and applies a novel \"multi-objective segment inversion\" operator that randomly inverts segments of the tour while ensuring feasibility and guided by a Pareto-dominance-aware selection criterion to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Randomly select a segment to invert\n        seg_start = random.randint(0, n-1)\n        seg_length = random.randint(2, min(10, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        if seg_start < seg_end:\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n        else:\n            # Handle circular segment\n            segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n            segment = segment[::-1]\n            new_solution[seg_start:] = segment[:n-seg_start]\n            new_solution[:seg_end] = segment[n-seg_start:]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4288942263341404,
            1.7583127856254577
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Randomly select a segment to invert\n        seg_start = random.randint(0, n-1)\n        seg_length = random.randint(2, min(10, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        if seg_start < seg_end:\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n        else:\n            # Handle circular segment\n            segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n            segment = segment[::-1]\n            new_solution[seg_start:] = segment[:n-seg_start]\n            new_solution[:seg_end] = segment[n-seg_start:]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{The algorithm selects a solution from the archive based on its proximity to the ideal point in the objective space, then applies a novel edge-swapping strategy that combines 2-opt and edge-crossing moves to generate a neighbor solution, ensuring feasibility and potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution closest to ideal point (min of each objective)\n    ideal_point = [min(obj[i] for _, obj in archive) for i in range(3)]\n    selected_idx = min(range(len(archive)), key=lambda i: sum(abs(archive[i][1][j] - ideal_point[j]) for j in range(3)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid edge-swapping strategy\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1) if j - i >= 2 else j\n\n        # Edge crossing move (novel combination)\n        if random.random() < 0.6:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if random.random() < 0.5:\n                new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n        # 2-opt move with edge inversion\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            if random.random() < 0.3:\n                new_solution[(i+1)%n], new_solution[(j-1)%n] = new_solution[(j-1)%n], new_solution[(i+1)%n]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6959344257588194,
            1.7761693835258483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution closest to ideal point (min of each objective)\n    ideal_point = [min(obj[i] for _, obj in archive) for i in range(3)]\n    selected_idx = min(range(len(archive)), key=lambda i: sum(abs(archive[i][1][j] - ideal_point[j]) for j in range(3)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid edge-swapping strategy\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1) if j - i >= 2 else j\n\n        # Edge crossing move (novel combination)\n        if random.random() < 0.6:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if random.random() < 0.5:\n                new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n        # 2-opt move with edge inversion\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            if random.random() < 0.3:\n                new_solution[(i+1)%n], new_solution[(j-1)%n] = new_solution[(j-1)%n], new_solution[(i+1)%n]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 4-opt and edge insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge insertion moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.6:\n            # 4-opt move\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[b+1:c+1]\n            segment3 = new_solution[c+1:d+1]\n            new_solution[a:d+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n        else:\n            # Edge insertion move\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 4-opt and edge insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge insertion moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.6:\n            # 4-opt move\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[b+1:c+1]\n            segment3 = new_solution[c+1:d+1]\n            new_solution[a:d+1] = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n        else:\n            # Edge insertion move\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{The algorithm selects a solution from the archive based on its proximity to the ideal point in the objective space, then applies a novel multi-objective local search operator that combines segment reversal with objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution closest to ideal point (minimizing all objectives)\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = objectives.min(axis=0)\n    distances = np.linalg.norm(objectives - ideal_point, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search operator\n    n = len(new_solution)\n    for _ in range(5):\n        # Segment reversal with objective-aware selection\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_segment = segment[::-1]\n\n        # Calculate objective change\n        old_cost = (sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment))) +\n                    sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment))) +\n                    sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(len(segment))))\n        new_cost = (sum(distance_matrix_1[new_segment[i-1], new_segment[i]] for i in range(len(new_segment))) +\n                    sum(distance_matrix_2[new_segment[i-1], new_segment[i]] for i in range(len(new_segment))) +\n                    sum(distance_matrix_3[new_segment[i-1], new_segment[i]] for i in range(len(new_segment))))\n\n        if new_cost < old_cost:\n            new_solution[a:b+1] = new_segment\n\n        # Objective-aware edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        node_i, node_j = new_solution[i], new_solution[j]\n\n        # Calculate objective change for swap\n        old_edges = (distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%n]] +\n                     distance_matrix_3[new_solution[i-1], node_i] + distance_matrix_3[node_i, new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[(j+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[(j+1)%n]] +\n                     distance_matrix_3[new_solution[j-1], node_j] + distance_matrix_3[node_j, new_solution[(j+1)%n]])\n\n        new_edges = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] +\n                     distance_matrix_3[new_solution[i-1], node_j] + distance_matrix_3[node_j, new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]] +\n                     distance_matrix_3[new_solution[j-1], node_i] + distance_matrix_3[node_i, new_solution[(j+1)%n]])\n\n        if new_edges < old_edges:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7736179964735397,
            3.787615442276001
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution closest to ideal point (minimizing all objectives)\n    objectives = np.array([obj for _, obj in archive])\n    ideal_point = objectives.min(axis=0)\n    distances = np.linalg.norm(objectives - ideal_point, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search operator\n    n = len(new_solution)\n    for _ in range(5):\n        # Segment reversal with objective-aware selection\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_segment = segment[::-1]\n\n        # Calculate objective change\n        old_cost = (sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment))) +\n                    sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment))) +\n                    sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(len(segment))))\n        new_cost = (sum(distance_matrix_1[new_segment[i-1], new_segment[i]] for i in range(len(new_segment))) +\n                    sum(distance_matrix_2[new_segment[i-1], new_segment[i]] for i in range(len(new_segment))) +\n                    sum(distance_matrix_3[new_segment[i-1], new_segment[i]] for i in range(len(new_segment))))\n\n        if new_cost < old_cost:\n            new_solution[a:b+1] = new_segment\n\n        # Objective-aware edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        node_i, node_j = new_solution[i], new_solution[j]\n\n        # Calculate objective change for swap\n        old_edges = (distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%n]] +\n                     distance_matrix_3[new_solution[i-1], node_i] + distance_matrix_3[node_i, new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[(j+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[(j+1)%n]] +\n                     distance_matrix_3[new_solution[j-1], node_j] + distance_matrix_3[node_j, new_solution[(j+1)%n]])\n\n        new_edges = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] +\n                     distance_matrix_3[new_solution[i-1], node_j] + distance_matrix_3[node_j, new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]] +\n                     distance_matrix_3[new_solution[j-1], node_i] + distance_matrix_3[node_i, new_solution[(j+1)%n]])\n\n        if new_edges < old_edges:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{The algorithm selects a solution from the archive based on its objective diversity and applies a hybrid local search operator that combines edge insertion and edge reversal moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and edge reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Edge insertion move\n        if random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n        # Edge reversal move\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4342195240579098,
            1.2719854474067689
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and edge reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Edge insertion move\n        if random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n        # Edge reversal move\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{The algorithm selects a solution from the archive based on its objective diversity and applies a hybrid local search operator that combines edge insertion and edge reversal moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and edge reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Edge insertion move\n        if random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n        # Edge reversal move\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4342195240579098,
            1.2719854474067689
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and edge reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Edge insertion move\n        if random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n        # Edge reversal move\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        min_val = min(obj)\n        max_val = max(obj)\n        return (max_val - min_val) / (sum(obj) + 1e-6)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4714345894490002,
            1.9198770880699159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        min_val = min(obj)\n        max_val = max(obj)\n        return (max_val - min_val) / (sum(obj) + 1e-6)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high variance in objective values and applies a novel local search operator that combines edge swaps with segment reversals, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.435265213849656,
            2.061481750011444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and their variance, then applies a hybrid local search combining 2-opt, 3-opt, and a novel objective-aware swap operator to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (weighted objective score + variance)\n    def objective_score(solution):\n        obj = archive[solution][1]\n        weight = [0.4, 0.3, 0.3]  # Weight for each objective\n        weighted_sum = sum(w * o for w, o in zip(weight, obj))\n        variance = sum((o - weighted_sum) ** 2 for o in obj) / len(obj)\n        return weighted_sum + 0.5 * variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt, 3-opt, and objective-aware swap\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move (70% chance)\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move (20% chance)\n        elif random.random() < 0.9:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        # Objective-aware swap (10% chance)\n        else:\n            # Swap nodes that are far in at least two objectives\n            obj1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            obj2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            obj3 = distance_matrix_3[new_solution[i], new_solution[j]]\n            if sum(1 for o in [obj1, obj2, obj3] if o > np.mean([obj1, obj2, obj3])) >= 2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.3987710487589963,
            2.5089532136917114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (weighted objective score + variance)\n    def objective_score(solution):\n        obj = archive[solution][1]\n        weight = [0.4, 0.3, 0.3]  # Weight for each objective\n        weighted_sum = sum(w * o for w, o in zip(weight, obj))\n        variance = sum((o - weighted_sum) ** 2 for o in obj) / len(obj)\n        return weighted_sum + 0.5 * variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt, 3-opt, and objective-aware swap\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move (70% chance)\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move (20% chance)\n        elif random.random() < 0.9:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        # Objective-aware swap (10% chance)\n        else:\n            # Swap nodes that are far in at least two objectives\n            obj1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            obj2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            obj3 = distance_matrix_3[new_solution[i], new_solution[j]]\n            if sum(1 for o in [obj1, obj2, obj3] if o > np.mean([obj1, obj2, obj3])) >= 2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{The algorithm selects a solution from the archive based on the highest sum of pairwise objective differences, then applies a hybrid local search combining edge swaps and node insertions, guided by a multi-objective improvement metric to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest sum of pairwise objective differences\n    def objective_difference(solution):\n        obj = archive[solution][1]\n        return sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(i+1, 3))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_difference(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps and node insertions\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        # Randomly choose between edge swap and node insertion\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Node insertion\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4676849736719987,
            2.0699960827827453
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest sum of pairwise objective differences\n    def objective_difference(solution):\n        obj = archive[solution][1]\n        return sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(i+1, 3))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_difference(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps and node insertions\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        # Randomly choose between edge swap and node insertion\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Node insertion\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with the highest combined distance in all three objectives, then applies a hybrid local search operator that combines 2-opt and 3-opt moves, with a higher probability of 3-opt moves, to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high total distance across all objectives\n    def total_distance(solution):\n        obj = archive[solution][1]\n        return sum(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: total_distance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt more likely\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.3:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7234881226989471,
            1.5602253079414368
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high total distance across all objectives\n    def total_distance(solution):\n        obj = archive[solution][1]\n        return sum(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: total_distance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt more likely\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.3:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{The algorithm selects a solution from the archive that is Pareto-optimal in at least one objective while having high diversity across objectives, then applies a novel multi-objective local search operator that combines edge swaps and node reinsertions, guided by a weighted sum of objectives to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution that is Pareto-optimal in at least one objective and has high diversity\n    def pareto_diversity(solution):\n        obj = archive[solution][1]\n        # Check if the solution is Pareto-optimal in at least one objective\n        is_pareto = any(\n            all(obj[i] <= archive[s][1][i] for s in range(len(archive)) if s != solution)\n            for i in range(3)\n        )\n        # Calculate objective diversity\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        return is_pareto * diversity\n\n    selected_idx = max(range(len(archive)), key=lambda i: pareto_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: edge swaps and node reinsertions\n    n = len(new_solution)\n    for _ in range(5):\n        # Edge swap\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Node reinsertion\n        else:\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.39939034987170946,
            3.465811276435852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution that is Pareto-optimal in at least one objective and has high diversity\n    def pareto_diversity(solution):\n        obj = archive[solution][1]\n        # Check if the solution is Pareto-optimal in at least one objective\n        is_pareto = any(\n            all(obj[i] <= archive[s][1][i] for s in range(len(archive)) if s != solution)\n            for i in range(3)\n        )\n        # Calculate objective diversity\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        return is_pareto * diversity\n\n    selected_idx = max(range(len(archive)), key=lambda i: pareto_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: edge swaps and node reinsertions\n    n = len(new_solution)\n    for _ in range(5):\n        # Edge swap\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Node reinsertion\n        else:\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{The algorithm selects solutions from the archive based on a novel objective diversity metric that considers the balance between objectives and their relative improvements, then applies a hybrid local search combining 4-opt and edge exchange moves, guided by a Pareto-dominance-aware objective function to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with balanced objective improvements\n    def objective_score(solution):\n        obj = archive[solution][1]\n        mean_obj = sum(obj) / 3\n        return sum((o - mean_obj) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge exchange\n    n = len(new_solution)\n    for _ in range(5):\n        i, j, k, l = sorted(random.sample(range(n), 4))\n\n        # 4-opt move\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        # Edge exchange\n        else:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = new_solution[k]\n            new_solution[k] = temp\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4859342012146282,
            1.8830178737640382
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with balanced objective improvements\n    def objective_score(solution):\n        obj = archive[solution][1]\n        mean_obj = sum(obj) / 3\n        return sum((o - mean_obj) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge exchange\n    n = len(new_solution)\n    for _ in range(5):\n        i, j, k, l = sorted(random.sample(range(n), 4))\n\n        # 4-opt move\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        # Edge exchange\n        else:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = new_solution[k]\n            new_solution[k] = temp\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{The algorithm selects a solution from the archive based on its balance across objectives, then applies a novel multi-objective edge insertion heuristic that dynamically selects the best edge insertion or removal operation across all three objective spaces, prioritizing moves that improve the most underutilized objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with balanced objectives (avoiding extremes)\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return -sum((x - mean)**2 for x in obj)  # Minimize variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge insertion heuristic\n    for _ in range(3):  # Number of improvement attempts\n        # Calculate current total distances\n        current_dist = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n        ]\n\n        # Find the most underutilized objective\n        underutilized_obj = np.argmin(current_dist)\n\n        # Try edge insertion/removal operations\n        for _ in range(5):\n            a, b = sorted(random.sample(range(n), 2))\n            c = random.randint(0, n-1)\n\n            # Try inserting node c between a and b\n            candidate = np.concatenate([new_solution[:a+1], [new_solution[c]], new_solution[a+1:b+1], [new_solution[c]], new_solution[b+1:]])\n\n            # Check feasibility and improvement\n            if len(np.unique(candidate)) == n:\n                new_dist = [\n                    sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n)),\n                    sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n)),\n                    sum(distance_matrix_3[candidate[i-1], candidate[i]] for i in range(n))\n                ]\n\n                # Accept if improves the underutilized objective\n                if new_dist[underutilized_obj] < current_dist[underutilized_obj]:\n                    new_solution = candidate.copy()\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6784528387945727,
            2.263891351222992
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with balanced objectives (avoiding extremes)\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return -sum((x - mean)**2 for x in obj)  # Minimize variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge insertion heuristic\n    for _ in range(3):  # Number of improvement attempts\n        # Calculate current total distances\n        current_dist = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n        ]\n\n        # Find the most underutilized objective\n        underutilized_obj = np.argmin(current_dist)\n\n        # Try edge insertion/removal operations\n        for _ in range(5):\n            a, b = sorted(random.sample(range(n), 2))\n            c = random.randint(0, n-1)\n\n            # Try inserting node c between a and b\n            candidate = np.concatenate([new_solution[:a+1], [new_solution[c]], new_solution[a+1:b+1], [new_solution[c]], new_solution[b+1:]])\n\n            # Check feasibility and improvement\n            if len(np.unique(candidate)) == n:\n                new_dist = [\n                    sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n)),\n                    sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n)),\n                    sum(distance_matrix_3[candidate[i-1], candidate[i]] for i in range(n))\n                ]\n\n                # Accept if improves the underutilized objective\n                if new_dist[underutilized_obj] < current_dist[underutilized_obj]:\n                    new_solution = candidate.copy()\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{The algorithm selects a solution from the archive based on the highest diversity in objective values, then applies a hybrid local search combining edge swaps and segment reversals, guided by a Pareto-dominance-aware objective function to generate an improved neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(i, j) if j - i >= 2 else j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4426334506771015,
            1.6042940258979796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(i, j) if j - i >= 2 else j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{The algorithm selects a solution from the archive with the highest combined distance improvement potential across all three objectives, then applies a novel segmented path reversal operator that divides the tour into three equal segments and reverses each segment independently to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest potential improvement (sum of all objective values)\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = n // 3\n\n    # Segmented path reversal: divide into 3 segments and reverse each\n    for i in range(3):\n        start = i * segment_size\n        end = (i + 1) * segment_size if i < 2 else n\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            -0.671048607066083,
            1.2820309042930602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest potential improvement (sum of all objective values)\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = n // 3\n\n    # Segmented path reversal: divide into 3 segments and reverse each\n    for i in range(3):\n        start = i * segment_size\n        end = (i + 1) * segment_size if i < 2 else n\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with extreme objective values in at least one dimension and applies a novel local search operator that combines segment reversal with node insertion, guided by a dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with extreme objective values in at least one dimension\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Segment reversal with node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Reverse segment and insert node\n        segment = new_solution[i:j+1]\n        if len(segment) > 1:\n            segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n        new_solution = np.insert(new_solution, k, new_solution[k])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7648278738795112,
            0.4826410412788391
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with extreme objective values in at least one dimension\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Segment reversal with node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Reverse segment and insert node\n        segment = new_solution[i:j+1]\n        if len(segment) > 1:\n            segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n        new_solution = np.insert(new_solution, k, new_solution[k])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with extreme objective values in at least one dimension and applies a novel local search operator that combines segment reversal with node insertion, guided by a dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with extreme objective values in at least one dimension\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Segment reversal with node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Reverse segment and insert node\n        segment = new_solution[i:j+1]\n        if len(segment) > 1:\n            segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n        new_solution = np.insert(new_solution, k, new_solution[k])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7648278738795112,
            0.4826410412788391
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with extreme objective values in at least one dimension\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Segment reversal with node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Reverse segment and insert node\n        segment = new_solution[i:j+1]\n        if len(segment) > 1:\n            segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n        new_solution = np.insert(new_solution, k, new_solution[k])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel multi-objective local search operator that combines segment reversal with objective-aware edge swaps, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])) / max(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = segment[::-1]\n        else:\n            for _ in range(2):\n                a, b = random.sample(range(len(segment)), 2)\n                if a > b:\n                    a, b = b, a\n                segment[a:b+1] = segment[a:b+1][::-1]\n            new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.38470430205112977,
            1.7169358491897584
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])) / max(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = segment[::-1]\n        else:\n            for _ in range(2):\n                a, b = random.sample(range(len(segment)), 2)\n                if a > b:\n                    a, b = b, a\n                segment[a:b+1] = segment[a:b+1][::-1]\n            new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt, 3-opt, and guided Pareto-dominance moves to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1.0 / (max(obj) - min(obj) + 1e-6)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with Pareto-aware moves\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.random()\n        if move_type < 0.4:\n            # 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.8:\n            # 3-opt move\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            # Pareto-aware move: swap segments if it improves at least one objective\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n            if (sum(distance_matrix_1[temp_solution[:-1], temp_solution[1:]]) < sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]) or\n                sum(distance_matrix_2[temp_solution[:-1], temp_solution[1:]]) < sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]) or\n                sum(distance_matrix_3[temp_solution[:-1], temp_solution[1:]]) < sum(distance_matrix_3[new_solution[:-1], new_solution[1:]])):\n                new_solution = temp_solution\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8683756668968965,
            1.6577752590179444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1.0 / (max(obj) - min(obj) + 1e-6)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with Pareto-aware moves\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.random()\n        if move_type < 0.4:\n            # 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.8:\n            # 3-opt move\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            # Pareto-aware move: swap segments if it improves at least one objective\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n            if (sum(distance_matrix_1[temp_solution[:-1], temp_solution[1:]]) < sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]) or\n                sum(distance_matrix_2[temp_solution[:-1], temp_solution[1:]]) < sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]) or\n                sum(distance_matrix_3[temp_solution[:-1], temp_solution[1:]]) < sum(distance_matrix_3[new_solution[:-1], new_solution[1:]])):\n                new_solution = temp_solution\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high objective variance and applies a novel segment-based local search that combines 2-opt with a multi-objective-aware edge insertion heuristic to generate a neighbor solution, ensuring feasibility and potentially improving multiple objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            best_insert_pos = -1\n            best_improvement = 0\n\n            for pos in range(n):\n                if pos >= i and pos <= j:\n                    continue\n\n                temp_solution = new_solution.copy()\n                temp_solution = np.delete(temp_solution, i)\n                temp_solution = np.insert(temp_solution, pos, segment)\n\n                if len(np.unique(temp_solution)) != n:\n                    continue\n\n                current_obj = archive[selected_idx][1]\n                new_obj = (\n                    sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n                    sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n                    sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n                )\n\n                improvement = sum((current_obj[i] - new_obj[i]) / (current_obj[i] + 1e-10) for i in range(3))\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_insert_pos = pos\n\n            if best_insert_pos != -1:\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, best_insert_pos, segment)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4314554829844369,
            3.4642548680305483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            best_insert_pos = -1\n            best_improvement = 0\n\n            for pos in range(n):\n                if pos >= i and pos <= j:\n                    continue\n\n                temp_solution = new_solution.copy()\n                temp_solution = np.delete(temp_solution, i)\n                temp_solution = np.insert(temp_solution, pos, segment)\n\n                if len(np.unique(temp_solution)) != n:\n                    continue\n\n                current_obj = archive[selected_idx][1]\n                new_obj = (\n                    sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n                    sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n                    sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n                )\n\n                improvement = sum((current_obj[i] - new_obj[i]) / (current_obj[i] + 1e-10) for i in range(3))\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_insert_pos = pos\n\n            if best_insert_pos != -1:\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, best_insert_pos, segment)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objective values and applies a hybrid local search operator that combines edge insertion and node relocation, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        min_val = min(obj)\n        max_val = max(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n        else:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n            new_solution = np.roll(new_solution, shift=random.randint(1, n-1))\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4100958735069772,
            1.7317203044891358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        min_val = min(obj)\n        max_val = max(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n        else:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n            new_solution = np.roll(new_solution, shift=random.randint(1, n-1))\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objectives, then applies a novel path inversion and segment reordering operator that combines random segment inversion with objective-aware segment reordering to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return -sum((x - mean)**2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel path inversion and segment reordering\n    n = len(new_solution)\n    for _ in range(3):\n        # Random segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware segment reordering\n        if random.random() < 0.5:\n            segments = []\n            for k in range(0, n, n//3):\n                segments.append(new_solution[k:k+n//3])\n            random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8322874815839274,
            1.7963725805282593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return -sum((x - mean)**2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel path inversion and segment reordering\n    n = len(new_solution)\n    for _ in range(3):\n        # Random segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware segment reordering\n        if random.random() < 0.5:\n            segments = []\n            for k in range(0, n, n//3):\n                segments.append(new_solution[k:k+n//3])\n            random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high objective diversity and applies a novel local search operator that combines edge swaps, node insertions, and objective-aware segment reversals to generate a neighbor solution, ensuring feasibility and multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (max(obj) - min(obj)) ** 2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.4:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(0, n-1)\n            new_solution = np.insert(np.delete(new_solution, i), k, new_solution[i])\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(i, j)\n            segment = new_solution[i:j+1]\n            obj_weights = [1.0, 1.0, 1.0]\n            if k - i > 0:\n                segment[:k-i] = segment[:k-i][::-1]\n            if j - k > 0:\n                segment[k-i:] = segment[k-i:][::-1]\n            new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4332883107431349,
            1.776723897457123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (max(obj) - min(obj)) ** 2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.4:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(0, n-1)\n            new_solution = np.insert(np.delete(new_solution, i), k, new_solution[i])\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(i, j)\n            segment = new_solution[i:j+1]\n            obj_weights = [1.0, 1.0, 1.0]\n            if k - i > 0:\n                segment[:k-i] = segment[:k-i][::-1]\n            if j - k > 0:\n                segment[k-i:] = segment[k-i:][::-1]\n            new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 4-opt and random swaps, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1.0 / (1.0 + abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0]))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and random swaps\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j, k, l = sorted(random.sample(range(n), 4))\n\n        # 4-opt move\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        # Random swaps\n        else:\n            random.shuffle(new_solution[i:j+1])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8275647729595429,
            1.6811505675315856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1.0 / (1.0 + abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0]))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and random swaps\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j, k, l = sorted(random.sample(range(n), 4))\n\n        # 4-opt move\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        # Random swaps\n        else:\n            random.shuffle(new_solution[i:j+1])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{The algorithm selects a solution from the archive by considering both objective diversity and solution quality, then applies a hybrid local search combining edge insertion and swap operations, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with high objective diversity and low total cost\n    def selection_criteria(solution):\n        obj = archive[solution][1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        total_cost = sum(obj)\n        return diversity - 0.5 * total_cost  # Balance diversity and quality\n\n    selected_idx = max(range(len(archive)), key=lambda i: selection_criteria(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and swap operations\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            # Edge insertion\n            i, j, k = sorted(random.sample(range(n), 3))\n            inserted = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [inserted], new_solution[i:j], new_solution[j+1:]])\n        else:\n            # Swap operation\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.45118905985270674,
            1.7594266891479493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with high objective diversity and low total cost\n    def selection_criteria(solution):\n        obj = archive[solution][1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        total_cost = sum(obj)\n        return diversity - 0.5 * total_cost  # Balance diversity and quality\n\n    selected_idx = max(range(len(archive)), key=lambda i: selection_criteria(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and swap operations\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            # Edge insertion\n            i, j, k = sorted(random.sample(range(n), 3))\n            inserted = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [inserted], new_solution[i:j], new_solution[j+1:]])\n        else:\n            # Swap operation\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines edge insertion and node relocation moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and node relocation\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.5:\n            # Edge insertion\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n        else:\n            # Node relocation\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4384448716344752,
            1.7792133688926697
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and node relocation\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.5:\n            # Edge insertion\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n        else:\n            # Node relocation\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high variance in objective values and applies a hybrid local search combining 2-opt and 3-opt moves with a novel objective-aware perturbation strategy to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        variance = ((obj[0] - mean)**2 + (obj[1] - mean)**2 + (obj[2] - mean)**2) / 3\n        return variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware perturbations\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Objective-aware move selection\n        if random.random() < 0.6:\n            # 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt move with objective-aware segment selection\n            obj_weights = np.array([distance_matrix_1[new_solution[i], new_solution[j]],\n                                   distance_matrix_2[new_solution[i], new_solution[j]],\n                                   distance_matrix_3[new_solution[i], new_solution[j]]])\n            if np.argmax(obj_weights) == 0:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            else:\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4295129547213513,
            2.290802466869354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        variance = ((obj[0] - mean)**2 + (obj[1] - mean)**2 + (obj[2] - mean)**2) / 3\n        return variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with objective-aware perturbations\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Objective-aware move selection\n        if random.random() < 0.6:\n            # 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt move with objective-aware segment selection\n            obj_weights = np.array([distance_matrix_1[new_solution[i], new_solution[j]],\n                                   distance_matrix_2[new_solution[i], new_solution[j]],\n                                   distance_matrix_3[new_solution[i], new_solution[j]]])\n            if np.argmax(obj_weights) == 0:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            else:\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with extreme objective values in any dimension, then applies a novel \"multi-objective inversion\" local search that selectively inverts segments of the tour based on objective-specific distance improvements, ensuring feasibility and Pareto-dominance-aware neighbor generation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with extreme objective values in any dimension\n    def objective_extremeness(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremeness(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Select random segment\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement for each objective\n        current_seg = base_solution[i:j+1]\n        inverted_seg = current_seg[::-1]\n\n        def seg_cost(seg, dm):\n            total = 0\n            for a, b in zip(seg[:-1], seg[1:]):\n                total += dm[a, b]\n            return total\n\n        cost1_current = seg_cost(current_seg, distance_matrix_1)\n        cost2_current = seg_cost(current_seg, distance_matrix_2)\n        cost3_current = seg_cost(current_seg, distance_matrix_3)\n\n        cost1_inverted = seg_cost(inverted_seg, distance_matrix_1)\n        cost2_inverted = seg_cost(inverted_seg, distance_matrix_2)\n        cost3_inverted = seg_cost(inverted_seg, distance_matrix_3)\n\n        # Apply inversion if it improves at least one objective\n        if (cost1_inverted < cost1_current or\n            cost2_inverted < cost2_current or\n            cost3_inverted < cost3_current):\n            new_solution[i:j+1] = inverted_seg\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4589240783422853,
            4.15165501832962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with extreme objective values in any dimension\n    def objective_extremeness(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremeness(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Select random segment\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement for each objective\n        current_seg = base_solution[i:j+1]\n        inverted_seg = current_seg[::-1]\n\n        def seg_cost(seg, dm):\n            total = 0\n            for a, b in zip(seg[:-1], seg[1:]):\n                total += dm[a, b]\n            return total\n\n        cost1_current = seg_cost(current_seg, distance_matrix_1)\n        cost2_current = seg_cost(current_seg, distance_matrix_2)\n        cost3_current = seg_cost(current_seg, distance_matrix_3)\n\n        cost1_inverted = seg_cost(inverted_seg, distance_matrix_1)\n        cost2_inverted = seg_cost(inverted_seg, distance_matrix_2)\n        cost3_inverted = seg_cost(inverted_seg, distance_matrix_3)\n\n        # Apply inversion if it improves at least one objective\n        if (cost1_inverted < cost1_current or\n            cost2_inverted < cost2_current or\n            cost3_inverted < cost3_current):\n            new_solution[i:j+1] = inverted_seg\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel segment-based local search operator that combines adaptive edge swaps and segment rotations, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel segment-based local search\n    n = len(new_solution)\n    for _ in range(5):\n        # Randomly select a segment\n        seg_start = random.randint(0, n-1)\n        seg_length = random.randint(2, min(5, n-1))\n        seg_end = (seg_start + seg_length) % n\n\n        # Adaptive edge swap\n        if random.random() < 0.6:\n            if seg_start < seg_end:\n                new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n            else:\n                segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n                reversed_segment = segment[::-1]\n                new_solution[seg_start:] = reversed_segment[:n-seg_start]\n                new_solution[:seg_end] = reversed_segment[n-seg_start:]\n        # Segment rotation\n        else:\n            rotation = random.randint(1, seg_length-1)\n            if seg_start < seg_end:\n                segment = new_solution[seg_start:seg_end]\n                rotated_segment = np.roll(segment, rotation)\n                new_solution[seg_start:seg_end] = rotated_segment\n            else:\n                segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n                rotated_segment = np.roll(segment, rotation)\n                new_solution[seg_start:] = rotated_segment[:n-seg_start]\n                new_solution[:seg_end] = rotated_segment[n-seg_start:]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.46118086279530884,
            2.7431395173072817
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel segment-based local search\n    n = len(new_solution)\n    for _ in range(5):\n        # Randomly select a segment\n        seg_start = random.randint(0, n-1)\n        seg_length = random.randint(2, min(5, n-1))\n        seg_end = (seg_start + seg_length) % n\n\n        # Adaptive edge swap\n        if random.random() < 0.6:\n            if seg_start < seg_end:\n                new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n            else:\n                segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n                reversed_segment = segment[::-1]\n                new_solution[seg_start:] = reversed_segment[:n-seg_start]\n                new_solution[:seg_end] = reversed_segment[n-seg_start:]\n        # Segment rotation\n        else:\n            rotation = random.randint(1, seg_length-1)\n            if seg_start < seg_end:\n                segment = new_solution[seg_start:seg_end]\n                rotated_segment = np.roll(segment, rotation)\n                new_solution[seg_start:seg_end] = rotated_segment\n            else:\n                segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n                rotated_segment = np.roll(segment, rotation)\n                new_solution[seg_start:] = rotated_segment[:n-seg_start]\n                new_solution[:seg_end] = rotated_segment[n-seg_start:]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{This algorithm selects a solution from the archive based on its proximity to the ideal point in the objective space, then applies a novel multi-objective local search operator that combines segment reversal and node insertion moves, guided by a weighted sum of objectives to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate ideal point (minimum values for each objective)\n    ideal_point = (\n        min(obj[0] for _, obj in archive),\n        min(obj[1] for _, obj in archive),\n        min(obj[2] for _, obj in archive)\n    )\n\n    # Select solution closest to ideal point\n    def distance_to_ideal(obj):\n        return sum((o - i) ** 2 for o, i in zip(obj, ideal_point)) ** 0.5\n\n    selected_idx = min(range(len(archive)), key=lambda i: distance_to_ideal(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search\n    n = len(new_solution)\n    for _ in range(5):\n        # Select random segment to reverse\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Insert random node at random position\n        k = random.randint(0, n-1)\n        node = random.choice(new_solution)\n        new_solution = np.insert(new_solution, k, node)\n\n        # Remove duplicate (ensures feasibility)\n        mask = np.ones(len(new_solution), dtype=bool)\n        mask[np.where(new_solution == node)[0][1:]] = False\n        new_solution = new_solution[mask]\n\n        if len(new_solution) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6390031320655196,
            2.8002980232238768
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate ideal point (minimum values for each objective)\n    ideal_point = (\n        min(obj[0] for _, obj in archive),\n        min(obj[1] for _, obj in archive),\n        min(obj[2] for _, obj in archive)\n    )\n\n    # Select solution closest to ideal point\n    def distance_to_ideal(obj):\n        return sum((o - i) ** 2 for o, i in zip(obj, ideal_point)) ** 0.5\n\n    selected_idx = min(range(len(archive)), key=lambda i: distance_to_ideal(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search\n    n = len(new_solution)\n    for _ in range(5):\n        # Select random segment to reverse\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Insert random node at random position\n        k = random.randint(0, n-1)\n        node = random.choice(new_solution)\n        new_solution = np.insert(new_solution, k, node)\n\n        # Remove duplicate (ensures feasibility)\n        mask = np.ones(len(new_solution), dtype=bool)\n        mask[np.where(new_solution == node)[0][1:]] = False\n        new_solution = new_solution[mask]\n\n        if len(new_solution) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This algorithm selects a solution from the archive based on its diversity in objective values, then applies a hybrid local search combining segment reversal and node insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        min_obj = min(obj)\n        max_obj = max(obj)\n        return max_obj - min_obj\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        move_type = random.random()\n\n        if move_type < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.8:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        else:\n            k = random.randint(i, j)\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.42873853393194794,
            1.8240049958229065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        min_obj = min(obj)\n        max_obj = max(obj)\n        return max_obj - min_obj\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        move_type = random.random()\n\n        if move_type < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.8:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        else:\n            k = random.randint(i, j)\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the most balanced objective values, then applies a novel local search operator that combines a weighted 2-opt move with a Pareto-dominance-aware edge insertion, guided by the total improvement across all three objectives to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            new_solution = np.roll(new_solution, k)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8486366620407946,
            1.7805681705474854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            new_solution = np.roll(new_solution, k)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{The new algorithm selects a solution from the archive based on its potential for improvement by prioritizing those with balanced objective values, then applies a hybrid local search operator combining 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = sum(obj) / 3\n        return -sum((o - mean_obj) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8588106110444146,
            1.680626916885376
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = sum(obj) / 3\n        return -sum((o - mean_obj) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a novel segment-based local search operator that combines adaptive edge relinking with objective-aware segment swaps to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((o - mean) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive segment-based local search\n    n = len(new_solution)\n    for _ in range(5):\n        # Select a random segment\n        seg_start = random.randint(0, n - 1)\n        seg_length = random.randint(2, min(5, n // 2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Extract segment\n        if seg_start < seg_end:\n            segment = new_solution[seg_start:seg_end]\n        else:\n            segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n\n        # Find best insertion point based on objective-aware distance\n        min_cost = float('inf')\n        best_pos = -1\n        for pos in range(n):\n            if pos in range(seg_start, seg_end) if seg_start < seg_end else (pos >= seg_start or pos < seg_end):\n                continue\n            # Calculate cost for each objective\n            cost1 = distance_matrix_1[new_solution[pos - 1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]]\n            cost2 = distance_matrix_2[new_solution[pos - 1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]]\n            cost3 = distance_matrix_3[new_solution[pos - 1], segment[0]] + distance_matrix_3[segment[-1], new_solution[pos]]\n            total_cost = cost1 + cost2 + cost3\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        if best_pos != -1:\n            if seg_start < seg_end:\n                new_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    segment,\n                    new_solution[seg_end:seg_start],\n                    new_solution[best_pos:]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    segment,\n                    new_solution[seg_end:seg_start],\n                    new_solution[best_pos:]\n                ])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.659589914625033,
            0.949385142326355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((o - mean) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive segment-based local search\n    n = len(new_solution)\n    for _ in range(5):\n        # Select a random segment\n        seg_start = random.randint(0, n - 1)\n        seg_length = random.randint(2, min(5, n // 2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Extract segment\n        if seg_start < seg_end:\n            segment = new_solution[seg_start:seg_end]\n        else:\n            segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n\n        # Find best insertion point based on objective-aware distance\n        min_cost = float('inf')\n        best_pos = -1\n        for pos in range(n):\n            if pos in range(seg_start, seg_end) if seg_start < seg_end else (pos >= seg_start or pos < seg_end):\n                continue\n            # Calculate cost for each objective\n            cost1 = distance_matrix_1[new_solution[pos - 1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]]\n            cost2 = distance_matrix_2[new_solution[pos - 1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]]\n            cost3 = distance_matrix_3[new_solution[pos - 1], segment[0]] + distance_matrix_3[segment[-1], new_solution[pos]]\n            total_cost = cost1 + cost2 + cost3\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        if best_pos != -1:\n            if seg_start < seg_end:\n                new_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    segment,\n                    new_solution[seg_end:seg_start],\n                    new_solution[best_pos:]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    segment,\n                    new_solution[seg_end:seg_start],\n                    new_solution[best_pos:]\n                ])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{The new algorithm selects a solution from the archive based on the highest average objective value, then applies a hybrid local search combining edge insertion and node swap operations, guided by Pareto-dominance-aware objective improvements to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest average objective value\n    def avg_objective(solution):\n        obj = archive[solution][1]\n        return (obj[0] + obj[1] + obj[2]) / 3\n\n    selected_idx = max(range(len(archive)), key=lambda i: avg_objective(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.5:\n            # Edge insertion move\n            i, j = sorted(random.sample(range(n), 2))\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                new_solution = np.insert(new_solution, i, node)\n        else:\n            # Node swap move\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7112119262798278,
            1.579026222229004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest average objective value\n    def avg_objective(solution):\n        obj = archive[solution][1]\n        return (obj[0] + obj[1] + obj[2]) / 3\n\n    selected_idx = max(range(len(archive)), key=lambda i: avg_objective(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.5:\n            # Edge insertion move\n            i, j = sorted(random.sample(range(n), 2))\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                new_solution = np.insert(new_solution, i, node)\n        else:\n            # Node swap move\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        std_dev = (sum((x - mean) ** 2 for x in obj) / 3) ** 0.5\n        return -std_dev\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8429847847474097,
            1.8705726504325866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        std_dev = (sum((x - mean) ** 2 for x in obj) / 3) ** 0.5\n        return -std_dev\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{The algorithm selects a solution from the archive based on its objective diversity and applies a novel \"multi-objective adaptive perturbation\" operator that dynamically adjusts the intensity of local search based on the relative improvement potential of each objective, combining 2-opt, 3-opt, and a custom \"objective-balancing\" move to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Dynamic move selection based on objective diversity\n        obj = archive[selected_idx][1]\n        diversity = objective_diversity(selected_idx)\n        max_obj = max(obj)\n        min_obj = min(obj)\n\n        if diversity > 0.5 * (max_obj - min_obj):\n            # High diversity: use more aggressive moves\n            if random.random() < 0.4:\n                # 2-opt\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            elif random.random() < 0.8:\n                # 3-opt\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n            else:\n                # Objective-balancing move: swap segments to balance objectives\n                segment1 = new_solution[i:k]\n                segment2 = new_solution[k:j]\n                new_solution[i:j] = np.concatenate([segment2, segment1])\n        else:\n            # Low diversity: use more conservative moves\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.40016832919578543,
            1.6096097469329833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Dynamic move selection based on objective diversity\n        obj = archive[selected_idx][1]\n        diversity = objective_diversity(selected_idx)\n        max_obj = max(obj)\n        min_obj = min(obj)\n\n        if diversity > 0.5 * (max_obj - min_obj):\n            # High diversity: use more aggressive moves\n            if random.random() < 0.4:\n                # 2-opt\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            elif random.random() < 0.8:\n                # 3-opt\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n            else:\n                # Objective-balancing move: swap segments to balance objectives\n                segment1 = new_solution[i:k]\n                segment2 = new_solution[k:j]\n                new_solution[i:j] = np.concatenate([segment2, segment1])\n        else:\n            # Low diversity: use more conservative moves\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective improvement potential, applies a novel edge-swap and segment-reversal hybrid local search, and ensures feasibility by validating the tour structure after each operation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined objective improvement potential\n    def improvement_potential(solution):\n        obj = archive[solution][1]\n        return (obj[0] + obj[1] + obj[2]) / 3  # Average objective value\n\n    selected_idx = max(range(len(archive)), key=lambda i: improvement_potential(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge-swap and segment-reversal\n    n = len(new_solution)\n    for _ in range(5):\n        # Randomly select two distinct segments\n        i, j = sorted(random.sample(range(n-1), 2))\n        k = random.randint(j+1, n-1) if j < n-2 else j+1\n\n        # Edge-swap move\n        if random.random() < 0.6:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Segment-reversal move\n        else:\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n        # Validate tour structure\n        if len(np.unique(new_solution)) == n and np.all(new_solution[:-1] != new_solution[1:]):\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6819611190469039,
            1.4968017935752869
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined objective improvement potential\n    def improvement_potential(solution):\n        obj = archive[solution][1]\n        return (obj[0] + obj[1] + obj[2]) / 3  # Average objective value\n\n    selected_idx = max(range(len(archive)), key=lambda i: improvement_potential(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge-swap and segment-reversal\n    n = len(new_solution)\n    for _ in range(5):\n        # Randomly select two distinct segments\n        i, j = sorted(random.sample(range(n-1), 2))\n        k = random.randint(j+1, n-1) if j < n-2 else j+1\n\n        # Edge-swap move\n        if random.random() < 0.6:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Segment-reversal move\n        else:\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n        # Validate tour structure\n        if len(np.unique(new_solution)) == n and np.all(new_solution[:-1] != new_solution[1:]):\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high objective diversity and applies a novel segment-based local search that combines adaptive segment reversal and segment insertion, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel segment-based local search\n    n = len(new_solution)\n    segment_length = max(2, n // 5)  # Adaptive segment length\n\n    for _ in range(5):\n        # Randomly select a segment\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n\n        # Adaptive operation: reverse or insert\n        if random.random() < 0.6:\n            # Reverse segment\n            new_solution[start:start + segment_length] = segment[::-1]\n        else:\n            # Insert segment elsewhere\n            insert_pos = random.randint(0, n - segment_length)\n            if insert_pos > start:\n                # Remove original segment\n                new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n                # Insert at new position\n                new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n            else:\n                # Remove original segment\n                new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n                # Insert at new position\n                new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.508852039307469,
            1.7943517446517945
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel segment-based local search\n    n = len(new_solution)\n    segment_length = max(2, n // 5)  # Adaptive segment length\n\n    for _ in range(5):\n        # Randomly select a segment\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n\n        # Adaptive operation: reverse or insert\n        if random.random() < 0.6:\n            # Reverse segment\n            new_solution[start:start + segment_length] = segment[::-1]\n        else:\n            # Insert segment elsewhere\n            insert_pos = random.randint(0, n - segment_length)\n            if insert_pos > start:\n                # Remove original segment\n                new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n                # Insert at new position\n                new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n            else:\n                # Remove original segment\n                new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n                # Insert at new position\n                new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with extreme objective values in at least one dimension, then applies a novel \"objective-balancing\" local search operator that combines 2-opt moves with objective-aware edge swaps to generate a neighbor solution while ensuring Pareto dominance improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_diff = max(abs(obj[0] - obj[1]), abs(obj[1] - obj[2]), abs(obj[2] - obj[0]))\n        return max_diff\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            if obj1 > obj2 and obj1 > obj3:\n                edge1, edge2 = new_solution[i], new_solution[j]\n                for k in range(n):\n                    if new_solution[k] == edge1 and new_solution[(k+1)%n] == edge2:\n                        new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n                        break\n            elif obj2 > obj1 and obj2 > obj3:\n                edge1, edge2 = new_solution[i], new_solution[j]\n                for k in range(n):\n                    if new_solution[k] == edge1 and new_solution[(k+1)%n] == edge2:\n                        new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n                        break\n            else:\n                edge1, edge2 = new_solution[i], new_solution[j]\n                for k in range(n):\n                    if new_solution[k] == edge1 and new_solution[(k+1)%n] == edge2:\n                        new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n                        break\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.3735188292052804,
            2.7745251059532166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_diff = max(abs(obj[0] - obj[1]), abs(obj[1] - obj[2]), abs(obj[2] - obj[0]))\n        return max_diff\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            if obj1 > obj2 and obj1 > obj3:\n                edge1, edge2 = new_solution[i], new_solution[j]\n                for k in range(n):\n                    if new_solution[k] == edge1 and new_solution[(k+1)%n] == edge2:\n                        new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n                        break\n            elif obj2 > obj1 and obj2 > obj3:\n                edge1, edge2 = new_solution[i], new_solution[j]\n                for k in range(n):\n                    if new_solution[k] == edge1 and new_solution[(k+1)%n] == edge2:\n                        new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n                        break\n            else:\n                edge1, edge2 = new_solution[i], new_solution[j]\n                for k in range(n):\n                    if new_solution[k] == edge1 and new_solution[(k+1)%n] == edge2:\n                        new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n                        break\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines edge insertion and swap moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objective values\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return min(obj) / max(obj) if max(obj) != 0 else 1.0\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and swap moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion move\n        if random.random() < 0.6:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n        # Swap move\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8430410536040901,
            1.5380210876464844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objective values\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return min(obj) / max(obj) if max(obj) != 0 else 1.0\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and swap moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion move\n        if random.random() < 0.6:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n        # Swap move\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines edge insertion and segment reversal, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7462241556061155,
            1.6497804522514343
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a novel local search operator that combines edge-swapping and node-insertion moves, guided by a multi-objective improvement heuristic to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Edge-swapping move\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Node-insertion move\n        else:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9067777172309572,
            1.7636366009712219
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Edge-swapping move\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Node-insertion move\n        else:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with extreme objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.44211767639411353,
            1.685395848751068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel \"multi-objective segment inversion\" operator that inverts segments of the tour while considering the three objectives simultaneously, guided by a combined objective function that balances the three objectives, to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Multi-objective segment inversion\n        if random.random() < 0.5:\n            # Invert segment based on combined objective\n            obj1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            obj2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            obj3 = sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n\n            if (obj1 + obj2 + obj3) > (obj1 + obj2 + obj3) * 0.8:  # Threshold for inversion\n                new_solution[i:j+1] = segment[::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4181112427846319,
            2.8582475423812865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Multi-objective segment inversion\n        if random.random() < 0.5:\n            # Invert segment based on combined objective\n            obj1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            obj2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            obj3 = sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n\n            if (obj1 + obj2 + obj3) > (obj1 + obj2 + obj3) * 0.8:  # Threshold for inversion\n                new_solution[i:j+1] = segment[::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with the highest objective diversity and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4745455593070007,
            1.6003067255020142
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high objective variance and applies a novel local search operator that combines segment reversal with objective-aware segment insertion, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        k, l = sorted(random.sample(range(n), 2))\n        if k < l:\n            segment = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:l], new_solution[l:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.634406316987852,
            0.28976263999938967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        k, l = sorted(random.sample(range(n), 2))\n        if k < l:\n            segment = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:l], new_solution[l:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high objective variance and applies a novel local search operator that combines segment reversal with objective-aware segment insertion, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        k, l = sorted(random.sample(range(n), 2))\n        if k < l:\n            segment = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:l], new_solution[l:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.634406316987852,
            0.28976263999938967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        k, l = sorted(random.sample(range(n), 2))\n        if k < l:\n            segment = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:l], new_solution[l:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid local search operator that combines edge insertion and edge reversal moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and edge reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Edge insertion move\n        if random.random() < 0.6:\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j+1 if j > i else j)\n        # Edge reversal move\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.41387833730087253,
            1.7484161853790283
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and edge reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Edge insertion move\n        if random.random() < 0.6:\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j+1 if j > i else j)\n        # Edge reversal move\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with extreme objective values and applies a novel multi-objective local search operator that combines segment reversal and insertion moves, guided by a dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            k = random.randint(0, n-1)\n            if k < i or k > j:\n                node = new_solution[k]\n                new_solution = np.delete(new_solution, k)\n                insert_pos = random.randint(0, n-2)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.3798358383806385,
            1.8508403778076172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            k = random.randint(0, n-1)\n            if k < i or k > j:\n                node = new_solution[k]\n                new_solution = np.delete(new_solution, k)\n                insert_pos = random.randint(0, n-2)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with the highest objective diversity, then applies a hybrid local search combining 2-opt and 3-opt moves, but with a novel perturbation strategy that dynamically adjusts move probabilities based on the current solution's objective values to better navigate the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    current_obj = archive[selected_idx][1]\n\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        obj_weights = [1.0 / (1.0 + current_obj[m]) for m in range(3)]\n        move_prob = sum(obj_weights) / 3.0\n\n        if random.random() < move_prob:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4486456183045477,
            1.7166852951049805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    current_obj = archive[selected_idx][1]\n\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        obj_weights = [1.0 / (1.0 + current_obj[m]) for m in range(3)]\n        move_prob = sum(obj_weights) / 3.0\n\n        if random.random() < move_prob:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{The algorithm selects a solution from the archive based on the sum of the three objectives, applies a hybrid local search combining 2-opt and 3-opt moves, and ensures feasibility by validating the neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the lowest sum of objectives\n    selected_idx = min(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.684036698653439,
            1.7043575644493103
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the lowest sum of objectives\n    selected_idx = min(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with extreme objective values (one objective significantly better than others) and applies a novel segment-based local search operator that combines alternating segment reversals and segment shifts, guided by a dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        segment_length = random.randint(2, min(5, n//2))\n        start_idx = random.randint(0, n - segment_length)\n\n        if random.random() < 0.5:\n            new_solution[start_idx:start_idx+segment_length] = new_solution[start_idx:start_idx+segment_length][::-1]\n        else:\n            shift = random.randint(1, segment_length-1)\n            segment = new_solution[start_idx:start_idx+segment_length]\n            new_solution[start_idx:start_idx+segment_length] = np.roll(segment, shift)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.505981630371568,
            1.8779749155044556
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        segment_length = random.randint(2, min(5, n//2))\n        start_idx = random.randint(0, n - segment_length)\n\n        if random.random() < 0.5:\n            new_solution[start_idx:start_idx+segment_length] = new_solution[start_idx:start_idx+segment_length][::-1]\n        else:\n            shift = random.randint(1, segment_length-1)\n            segment = new_solution[start_idx:start_idx+segment_length]\n            new_solution[start_idx:start_idx+segment_length] = np.roll(segment, shift)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel multi-objective local search operator that combines edge insertion and segment reversal moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel multi-objective local search: edge insertion and segment reversal\n    n = len(new_solution)\n    for _ in range(5):\n        # Randomly select two distinct nodes\n        a, b = random.sample(range(n), 2)\n        a, b = min(a, b), max(a, b)\n\n        # Edge insertion move\n        if random.random() < 0.6:\n            node = new_solution[b]\n            new_solution = np.delete(new_solution, b)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        # Segment reversal move\n        else:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.40291576246155436,
            1.6512982487678527
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel multi-objective local search: edge insertion and segment reversal\n    n = len(new_solution)\n    for _ in range(5):\n        # Randomly select two distinct nodes\n        a, b = random.sample(range(n), 2)\n        a, b = min(a, b), max(a, b)\n\n        # Edge insertion move\n        if random.random() < 0.6:\n            node = new_solution[b]\n            new_solution = np.delete(new_solution, b)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        # Segment reversal move\n        else:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with extreme objective values and applies a hybrid local search operator that combines 4-opt and 5-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n        l = random.randint(k, j) if j - k >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            new_solution[l:j+1] = new_solution[l:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4812631619032624,
            1.718985116481781
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n        l = random.randint(k, j) if j - k >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            new_solution[l:j+1] = new_solution[l:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a novel local search operator that combines cluster-based perturbation with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    clusters = []\n    cluster_size = max(2, n // 5)\n\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    for _ in range(3):\n        if random.random() < 0.5:\n            cluster_idx = random.randint(0, len(clusters)-1)\n            clusters[cluster_idx] = clusters[cluster_idx][::-1]\n        else:\n            i, j = sorted(random.sample(range(len(clusters)), 2))\n            clusters[i], clusters[j] = clusters[j], clusters[i]\n\n    new_solution = np.concatenate(clusters)\n\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                distance_matrix_3[new_solution[i-1], new_solution[j]])\n        obj2 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                distance_matrix_3[new_solution[i-1], new_solution[i]])\n\n        if obj1 < obj2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8076979892290419,
            1.64223370552063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    clusters = []\n    cluster_size = max(2, n // 5)\n\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    for _ in range(3):\n        if random.random() < 0.5:\n            cluster_idx = random.randint(0, len(clusters)-1)\n            clusters[cluster_idx] = clusters[cluster_idx][::-1]\n        else:\n            i, j = sorted(random.sample(range(len(clusters)), 2))\n            clusters[i], clusters[j] = clusters[j], clusters[i]\n\n    new_solution = np.concatenate(clusters)\n\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                distance_matrix_3[new_solution[i-1], new_solution[j]])\n        obj2 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                distance_matrix_3[new_solution[i-1], new_solution[i]])\n\n        if obj1 < obj2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel segment-based local search operator that combines adaptive segment reversal and segment reinsertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive segment-based local search\n    n = len(new_solution)\n    segment_size = max(2, n // 5)  # Adaptive segment size\n\n    for _ in range(5):  # Number of perturbation attempts\n        # Randomly select a segment\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Segment reversal\n        if random.random() < 0.6:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        # Segment reinsertion\n        else:\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4719401890720367,
            1.8784935235977174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive segment-based local search\n    n = len(new_solution)\n    segment_size = max(2, n // 5)  # Adaptive segment size\n\n    for _ in range(5):  # Number of perturbation attempts\n        # Randomly select a segment\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Segment reversal\n        if random.random() < 0.6:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        # Segment reinsertion\n        else:\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with diverse objective values and applies a hybrid local search operator that combines edge insertion and relocation moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        k = random.randint(0, n-1)\n\n        if random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n        else:\n            new_solution[[i, j]] = new_solution[[j, i]]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4669617071338634,
            0.9921130895614624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        k = random.randint(0, n-1)\n\n        if random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n        else:\n            new_solution[[i, j]] = new_solution[[j, i]]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with the worst objective values in any space, then applies a hybrid local search operator that combines node swaps and segment reversals, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with worst objective in any space\n    selected_idx = max(range(len(archive)), key=lambda i: max(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node swaps and segment reversals\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.5:\n            # Node swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Segment reversal\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.47301534114903393,
            1.5909988641738892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with worst objective in any space\n    selected_idx = max(range(len(archive)), key=lambda i: max(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node swaps and segment reversals\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.5:\n            # Node swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Segment reversal\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objectives and applies a hybrid local search operator that combines 4-opt and Or-opt moves, guided by a multi-objective improvement function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return -abs(obj[0] - mean) - abs(obj[1] - mean) - abs(obj[2] - mean)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n        else:\n            temp = new_solution[i]\n            new_solution = np.concatenate((new_solution[:i], new_solution[i+1:j+1], [temp], new_solution[j+1:]))\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8765749954871183,
            1.5364773750305176
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return -abs(obj[0] - mean) - abs(obj[1] - mean) - abs(obj[2] - mean)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n        else:\n            temp = new_solution[i]\n            new_solution = np.concatenate((new_solution[:i], new_solution[i+1:j+1], [temp], new_solution[j+1:]))\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high objective diversity, then applies a novel local search operator that combines segment reversal and segment rotation moves, guided by a multi-objective improvement criterion to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])) / (max(obj) - min(obj) + 1e-6)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = segment[::-1]\n        else:\n            shift = random.randint(1, len(segment)-1)\n            new_solution[i:j+1] = np.roll(segment, shift)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.41539843497028617,
            1.9870308756828308
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])) / (max(obj) - min(obj) + 1e-6)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = segment[::-1]\n        else:\n            shift = random.randint(1, len(segment)-1)\n            new_solution[i:j+1] = np.roll(segment, shift)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel multi-objective local search operator that combines 2-opt with a novel \"objective-aware\" 3-opt move, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            obj_weights = np.random.dirichlet(np.ones(3))\n            obj1_diff = sum(distance_matrix_1[new_solution[i:k+1][l], new_solution[i:k+1][l+1]] for l in range(len(new_solution[i:k+1])-1))\n            obj2_diff = sum(distance_matrix_2[new_solution[i:k+1][l], new_solution[i:k+1][l+1]] for l in range(len(new_solution[i:k+1])-1))\n            obj3_diff = sum(distance_matrix_3[new_solution[i:k+1][l], new_solution[i:k+1][l+1]] for l in range(len(new_solution[i:k+1])-1))\n            total_diff = obj_weights[0] * obj1_diff + obj_weights[1] * obj2_diff + obj_weights[2] * obj3_diff\n\n            if total_diff > 0:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.40638602318873807,
            1.7883431673049928
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            obj_weights = np.random.dirichlet(np.ones(3))\n            obj1_diff = sum(distance_matrix_1[new_solution[i:k+1][l], new_solution[i:k+1][l+1]] for l in range(len(new_solution[i:k+1])-1))\n            obj2_diff = sum(distance_matrix_2[new_solution[i:k+1][l], new_solution[i:k+1][l+1]] for l in range(len(new_solution[i:k+1])-1))\n            obj3_diff = sum(distance_matrix_3[new_solution[i:k+1][l], new_solution[i:k+1][l+1]] for l in range(len(new_solution[i:k+1])-1))\n            total_diff = obj_weights[0] * obj1_diff + obj_weights[1] * obj2_diff + obj_weights[2] * obj3_diff\n\n            if total_diff > 0:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{The algorithm selects a solution from the archive based on a novel weighted objective score that balances diversity and quality, then applies a hybrid local search combining 4-opt and swap moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement using a novel scoring function\n    def objective_score(solution):\n        obj = archive[solution][1]\n        diversity = (abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])) / (sum(obj) + 1e-6)\n        quality = 1 / (1 + sum(obj))\n        return 0.6 * diversity + 0.4 * quality\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and swap moves\n    n = len(new_solution)\n    for _ in range(5):\n        i, j, k, l = sorted(random.sample(range(n), 4))\n\n        if random.random() < 0.5:\n            # 4-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            # Swap move\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.45779494865702197,
            1.6701488494873047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement using a novel scoring function\n    def objective_score(solution):\n        obj = archive[solution][1]\n        diversity = (abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])) / (sum(obj) + 1e-6)\n        quality = 1 / (1 + sum(obj))\n        return 0.6 * diversity + 0.4 * quality\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and swap moves\n    n = len(new_solution)\n    for _ in range(5):\n        i, j, k, l = sorted(random.sample(range(n), 4))\n\n        if random.random() < 0.5:\n            # 4-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            # Swap move\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with high variance in objectives and applies a hybrid local search operator that combines edge insertion, node relocation, and path reversal moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((x - mean) ** 2 for x in obj) / 3\n        return variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion, node relocation, and path reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        move_type = random.random()\n\n        if move_type < 0.4:  # Edge insertion\n            i, j, k = random.sample(range(n), 3)\n            if i > j:\n                i, j = j, i\n            new_solution = np.concatenate([new_solution[:i], new_solution[k:k+1], new_solution[i:j], new_solution[j:k], new_solution[k+1:]])\n        elif move_type < 0.7:  # Node relocation\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], new_solution[j:j+1], new_solution[i:i+1], new_solution[j+1:]])\n        else:  # Path reversal\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4407117788479872,
            1.5498771786689758
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((x - mean) ** 2 for x in obj) / 3\n        return variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion, node relocation, and path reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        move_type = random.random()\n\n        if move_type < 0.4:  # Edge insertion\n            i, j, k = random.sample(range(n), 3)\n            if i > j:\n                i, j = j, i\n            new_solution = np.concatenate([new_solution[:i], new_solution[k:k+1], new_solution[i:j], new_solution[j:k], new_solution[k+1:]])\n        elif move_type < 0.7:  # Node relocation\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], new_solution[j:j+1], new_solution[i:i+1], new_solution[j+1:]])\n        else:  # Path reversal\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with extreme objective values in one or more dimensions, then applies a novel multi-objective local search operator that combines 2-opt and 3-opt moves with a dynamic weighted objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_diff = max(obj) - min(obj)\n        return max_diff\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            if j - i >= 3:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                l = random.randint(i, j)\n                new_solution[l:j+1] = new_solution[l:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4150533906021764,
            1.9034007906913757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_diff = max(obj) - min(obj)\n        return max_diff\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            if j - i >= 3:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                l = random.randint(i, j)\n                new_solution[l:j+1] = new_solution[l:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel segment-based local search operator that combines adaptive segment reversal and segment insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based local search\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        seg_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - seg_length)\n        end = start + seg_length\n\n        # Adaptive segment reversal\n        if random.random() < 0.6:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        # Segment insertion\n        else:\n            insert_pos = random.randint(0, n - seg_length)\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[end:],\n                segment\n            ])\n            new_solution = np.roll(new_solution, -insert_pos)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.35865147988800117,
            1.8151052117347717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based local search\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        seg_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - seg_length)\n        end = start + seg_length\n\n        # Adaptive segment reversal\n        if random.random() < 0.6:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        # Segment insertion\n        else:\n            insert_pos = random.randint(0, n - seg_length)\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[end:],\n                segment\n            ])\n            new_solution = np.roll(new_solution, -insert_pos)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a novel hybrid local search operator that combines 2-opt, 3-opt, and a multi-objective adaptive perturbation strategy, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Adaptive selection of move type based on objective diversity\n        obj = archive[selected_idx][1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n        if diversity < 0.1 * sum(obj):\n            # Highly balanced objectives: prefer 3-opt\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(i, j) if j - i >= 2 else j\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            # More diverse objectives: use weighted combination of moves\n            if random.random() < 0.5:\n                # 2-opt move\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                # 3-opt move with adaptive segment selection\n                i, j = sorted(random.sample(range(n), 2))\n                k = random.randint(i, j) if j - i >= 2 else j\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8416232673950953,
            1.7443415164947509
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Adaptive selection of move type based on objective diversity\n        obj = archive[selected_idx][1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n        if diversity < 0.1 * sum(obj):\n            # Highly balanced objectives: prefer 3-opt\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(i, j) if j - i >= 2 else j\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            # More diverse objectives: use weighted combination of moves\n            if random.random() < 0.5:\n                # 2-opt move\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                # 3-opt move with adaptive segment selection\n                i, j = sorted(random.sample(range(n), 2))\n                k = random.randint(i, j) if j - i >= 2 else j\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel multi-objective local search operator that combines segment reversal with objective-aware edge swaps, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            k = random.randint(0, n-1)\n            if k != i and k != j:\n                new_solution[[i, j, k]] = new_solution[[j, k, i]]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.466947479299494,
            1.7092372536659242
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            k = random.randint(0, n-1)\n            if k != i and k != j:\n                new_solution[[i, j, k]] = new_solution[[j, k, i]]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{The algorithm selects a solution from the archive based on the highest diversity in objective values, then applies a hybrid local search combining edge insertion and node relocation moves, prioritizing segments that show improvement in at least two objectives, to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.5538722702349189,
            1.9002317667007447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines edge insertion and segment reversal, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i < 2:\n            continue\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            new_pos = random.randint(0, n - len(segment))\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:new_pos], segment, new_solution[new_pos:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7745483308334558,
            1.4527257680892944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i < 2:\n            continue\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            new_pos = random.randint(0, n - len(segment))\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:new_pos], segment, new_solution[new_pos:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{The algorithm selects a solution from the archive based on its potential for multi-objective improvement by prioritizing solutions with balanced and diverse objectives, then applies a novel local search operator that combines adaptive 2-opt and 3-opt moves with objective-weighted edge swaps to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_score(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((x - mean) ** 2 for x in obj)\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        return 0.7 * variance + 0.3 * diversity\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        obj_weights = archive[selected_idx][1]\n        total_weight = sum(obj_weights)\n        normalized_weights = [w / total_weight for w in obj_weights]\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            if random.random() < 0.3:\n                for _ in range(2):\n                    l, m = sorted(random.sample(range(n), 2))\n                    if random.random() < normalized_weights[0]:\n                        if distance_matrix_1[new_solution[l], new_solution[m]] < distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] + distance_matrix_1[new_solution[m], new_solution[(m+1)%n]]:\n                            new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n                    elif random.random() < normalized_weights[1]:\n                        if distance_matrix_2[new_solution[l], new_solution[m]] < distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] + distance_matrix_2[new_solution[m], new_solution[(m+1)%n]]:\n                            new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n                    else:\n                        if distance_matrix_3[new_solution[l], new_solution[m]] < distance_matrix_3[new_solution[l], new_solution[(l+1)%n]] + distance_matrix_3[new_solution[m], new_solution[(m+1)%n]]:\n                            new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.472944347113087,
            2.270950496196747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_score(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((x - mean) ** 2 for x in obj)\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        return 0.7 * variance + 0.3 * diversity\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        obj_weights = archive[selected_idx][1]\n        total_weight = sum(obj_weights)\n        normalized_weights = [w / total_weight for w in obj_weights]\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            if random.random() < 0.3:\n                for _ in range(2):\n                    l, m = sorted(random.sample(range(n), 2))\n                    if random.random() < normalized_weights[0]:\n                        if distance_matrix_1[new_solution[l], new_solution[m]] < distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] + distance_matrix_1[new_solution[m], new_solution[(m+1)%n]]:\n                            new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n                    elif random.random() < normalized_weights[1]:\n                        if distance_matrix_2[new_solution[l], new_solution[m]] < distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] + distance_matrix_2[new_solution[m], new_solution[(m+1)%n]]:\n                            new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n                    else:\n                        if distance_matrix_3[new_solution[l], new_solution[m]] < distance_matrix_3[new_solution[l], new_solution[(l+1)%n]] + distance_matrix_3[new_solution[m], new_solution[(m+1)%n]]:\n                            new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values, then applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        avg = sum(obj) / 3\n        return -sum(abs(x - avg) for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8397759192478826,
            1.5766531825065613
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        avg = sum(obj) / 3\n        return -sum(abs(x - avg) for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = (obj[0] + obj[1] + obj[2]) / 3\n        return - (abs(obj[0] - mean_obj) + abs(obj[1] - mean_obj) + abs(obj[2] - mean_obj))\n\n    # Prioritize solutions with more balanced objectives\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8889625888001655,
            1.4645017385482788
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = (obj[0] + obj[1] + obj[2]) / 3\n        return - (abs(obj[0] - mean_obj) + abs(obj[1] - mean_obj) + abs(obj[2] - mean_obj))\n\n    # Prioritize solutions with more balanced objectives\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution, while ensuring feasibility through intelligent random selection and perturbation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objective values\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = (obj[0] + obj[1] + obj[2]) / 3\n        return - (abs(obj[0] - mean_obj) + abs(obj[1] - mean_obj) + abs(obj[2] - mean_obj))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8437577614504755,
            1.6335456252098084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objective values\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = (obj[0] + obj[1] + obj[2]) / 3\n        return - (abs(obj[0] - mean_obj) + abs(obj[1] - mean_obj) + abs(obj[2] - mean_obj))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with high variance in objective values and applies a novel multi-objective local search operator that combines segment relocation with objective-aware edge swaps, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = segment[::-1]\n        else:\n            k = random.randint(0, n-1)\n            if k < i or k >= j:\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4374043478872087,
            1.5784342288970947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = segment[::-1]\n        else:\n            k = random.randint(0, n-1)\n            if k < i or k >= j:\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel multi-objective local search operator that combines segment inversion, insertion, and swap moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel multi-objective local search operator\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        move_type = random.random()\n\n        if move_type < 0.33:  # Segment inversion\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.66:  # Insertion\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n        else:  # Swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.41698998192111353,
            1.7466909766197205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel multi-objective local search operator\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        move_type = random.random()\n\n        if move_type < 0.33:  # Segment inversion\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.66:  # Insertion\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n        else:  # Swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{The algorithm selects a solution from the archive based on its proximity to the ideal point in the objective space, then applies a novel \"multi-objective inversion\" operator that reverses segments of the tour while considering the trade-offs between objectives, ensuring feasibility and potentially improving multiple objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution closest to the ideal point (minimizing all objectives)\n    ideal_point = [min(obj[0] for _, obj in archive),\n                   min(obj[1] for _, obj in archive),\n                   min(obj[2] for _, obj in archive)]\n\n    def distance_to_ideal(obj):\n        return sum((x - y) ** 2 for x, y in zip(obj, ideal_point)) ** 0.5\n\n    selected_idx = min(range(len(archive)), key=lambda i: distance_to_ideal(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective inversion operator\n    n = len(new_solution)\n    for _ in range(3):\n        # Select random segment to invert\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Determine which objectives to prioritize in inversion\n        obj_weights = [random.random() for _ in range(3)]\n        obj_weights = [w / sum(obj_weights) for w in obj_weights]\n\n        # Calculate potential improvement for each objective\n        original_cost = [0, 0, 0]\n        improved_cost = [0, 0, 0]\n\n        for k in range(i, j):\n            original_cost[0] += distance_matrix_1[new_solution[k], new_solution[k+1]]\n            original_cost[1] += distance_matrix_2[new_solution[k], new_solution[k+1]]\n            original_cost[2] += distance_matrix_3[new_solution[k], new_solution[k+1]]\n\n            improved_cost[0] += distance_matrix_1[new_solution[k+1], new_solution[k]]\n            improved_cost[1] += distance_matrix_2[new_solution[k+1], new_solution[k]]\n            improved_cost[2] += distance_matrix_3[new_solution[k+1], new_solution[k]]\n\n        # Calculate weighted improvement\n        improvement = sum((original_cost[m] - improved_cost[m]) * obj_weights[m]\n                         for m in range(3))\n\n        if improvement > 0 or random.random() < 0.3:  # Accept with probability if no improvement\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.61896819937232,
            3.6888612866401673
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution closest to the ideal point (minimizing all objectives)\n    ideal_point = [min(obj[0] for _, obj in archive),\n                   min(obj[1] for _, obj in archive),\n                   min(obj[2] for _, obj in archive)]\n\n    def distance_to_ideal(obj):\n        return sum((x - y) ** 2 for x, y in zip(obj, ideal_point)) ** 0.5\n\n    selected_idx = min(range(len(archive)), key=lambda i: distance_to_ideal(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective inversion operator\n    n = len(new_solution)\n    for _ in range(3):\n        # Select random segment to invert\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Determine which objectives to prioritize in inversion\n        obj_weights = [random.random() for _ in range(3)]\n        obj_weights = [w / sum(obj_weights) for w in obj_weights]\n\n        # Calculate potential improvement for each objective\n        original_cost = [0, 0, 0]\n        improved_cost = [0, 0, 0]\n\n        for k in range(i, j):\n            original_cost[0] += distance_matrix_1[new_solution[k], new_solution[k+1]]\n            original_cost[1] += distance_matrix_2[new_solution[k], new_solution[k+1]]\n            original_cost[2] += distance_matrix_3[new_solution[k], new_solution[k+1]]\n\n            improved_cost[0] += distance_matrix_1[new_solution[k+1], new_solution[k]]\n            improved_cost[1] += distance_matrix_2[new_solution[k+1], new_solution[k]]\n            improved_cost[2] += distance_matrix_3[new_solution[k+1], new_solution[k]]\n\n        # Calculate weighted improvement\n        improvement = sum((original_cost[m] - improved_cost[m]) * obj_weights[m]\n                         for m in range(3))\n\n        if improvement > 0 or random.random() < 0.3:  # Accept with probability if no improvement\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7550953232322398,
            2.246248924732208
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel multi-objective local search operator that combines segment reversal and insertion moves, guided by a weighted Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4651890747539598,
            2.3703917980194094
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with both high objective diversity and balanced values, then applies a novel local search operator that combines 4-opt and swap moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def combined_metric(solution):\n        obj = archive[solution][1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        mean = sum(obj) / 3\n        balance = -sum((x - mean) ** 2 for x in obj)\n        return diversity + balance\n\n    selected_idx = max(range(len(archive)), key=lambda i: combined_metric(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        move_type = random.random()\n        if move_type < 0.4:\n            # 4-opt move\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            segment3 = new_solution[c:d]\n            new_solution[a:d] = np.concatenate([segment2, segment1, segment3])\n        elif move_type < 0.8:\n            # Swap move\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7416730216369222,
            2.425278401374817
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def combined_metric(solution):\n        obj = archive[solution][1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        mean = sum(obj) / 3\n        balance = -sum((x - mean) ** 2 for x in obj)\n        return diversity + balance\n\n    selected_idx = max(range(len(archive)), key=lambda i: combined_metric(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        move_type = random.random()\n        if move_type < 0.4:\n            # 4-opt move\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            segment3 = new_solution[c:d]\n            new_solution[a:d] = np.concatenate([segment2, segment1, segment3])\n        elif move_type < 0.8:\n            # Swap move\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{This algorithm selects a solution from the archive with the highest variance in objective values to encourage exploration, then applies a hybrid local search operator that combines edge swaps and node insertions, guided by a dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.5061202291765643,
            2.1166064381599425
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high diversity in objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function, to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.43141017031894996,
            1.5393548250198363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the highest sum of normalized objective values and applies a hybrid local search operator that combines edge insertion and edge reversal moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_sum(solution):\n        obj = archive[solution][1]\n        return sum(obj)\n\n    # Prioritize solutions with higher objective sum\n    selected_idx = max(range(len(archive)), key=lambda i: objective_sum(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and edge reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge reversal\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Edge insertion\n        else:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7312519474057655,
            1.1316689729690552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_sum(solution):\n        obj = archive[solution][1]\n        return sum(obj)\n\n    # Prioritize solutions with higher objective sum\n    selected_idx = max(range(len(archive)), key=lambda i: objective_sum(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and edge reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge reversal\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Edge insertion\n        else:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = (obj[0] + obj[1] + obj[2]) / 3\n        return - (abs(obj[0] - mean_obj) + abs(obj[1] - mean_obj) + abs(obj[2] - mean_obj))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9058268265842855,
            1.4950574040412903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = (obj[0] + obj[1] + obj[2]) / 3\n        return - (abs(obj[0] - mean_obj) + abs(obj[1] - mean_obj) + abs(obj[2] - mean_obj))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function, while also considering the instance-specific distance matrices to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return sum((x - y) ** 2 for x, y in zip(obj, obj[1:]))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(10):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.43262084362513187,
            1.8834688544273377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return sum((x - y) ** 2 for x, y in zip(obj, obj[1:]))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(10):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a novel \"multi-objective segment inversion\" operator that intelligently inverts segments of the tour while considering the trade-offs between objectives, ensuring feasibility and potentially uncovering better trade-offs across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if j - i > 2:\n            segment = new_solution[i:j+1]\n\n            # Multi-objective segment inversion: invert based on objective trade-offs\n            obj1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            obj2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            obj3 = sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n\n            if obj1 > obj2 and obj1 > obj3:\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                new_solution[i:j+1] = segment[::-1]\n            elif obj3 > obj1 and obj3 > obj2:\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                if random.random() < 0.5:\n                    new_solution[i:j+1] = segment[::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6891254043320355,
            2.287193810939789
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if j - i > 2:\n            segment = new_solution[i:j+1]\n\n            # Multi-objective segment inversion: invert based on objective trade-offs\n            obj1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            obj2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            obj3 = sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n\n            if obj1 > obj2 and obj1 > obj3:\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                new_solution[i:j+1] = segment[::-1]\n            elif obj3 > obj1 and obj3 > obj2:\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                if random.random() < 0.5:\n                    new_solution[i:j+1] = segment[::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a novel segment-based local search operator that combines dynamic segment reversal and insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        if random.random() < 0.5:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            insert_pos = random.randint(0, n - segment_length)\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7938905929310094,
            1.697113847732544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        if random.random() < 0.5:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            insert_pos = random.randint(0, n - segment_length)\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a novel segment-based crossover operator that combines segments from multiple solutions, guided by a multi-objective improvement metric to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    candidates = [s[0] for s in archive if s[0].shape == base_solution.shape]\n\n    for _ in range(5):\n        if len(candidates) < 2:\n            break\n\n        other_solution = random.choice(candidates)\n        seg_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - seg_length)\n\n        new_solution[start:start+seg_length] = other_solution[start:start+seg_length]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6903569899437183,
            1.6642696499824523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    candidates = [s[0] for s in archive if s[0].shape == base_solution.shape]\n\n    for _ in range(5):\n        if len(candidates) < 2:\n            break\n\n        other_solution = random.choice(candidates)\n        seg_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - seg_length)\n\n        new_solution[start:start+seg_length] = other_solution[start:start+seg_length]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the most balanced objective values, then applies a novel segment-based local search that intelligently reorders segments of the tour based on their contribution to each objective, ensuring feasibility while promoting multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, n // 5)\n    num_segments = n // segment_size\n\n    for _ in range(3):\n        if random.random() < 0.5:\n            # Reorder segments based on objective contribution\n            segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(num_segments)]\n            random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n            if num_segments * segment_size < n:\n                new_solution = np.concatenate([new_solution, base_solution[num_segments*segment_size:]])\n        else:\n            # Reverse a segment\n            start = random.randint(0, n - segment_size)\n            new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.73767414447713,
            2.352208065986633
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, n // 5)\n    num_segments = n // segment_size\n\n    for _ in range(3):\n        if random.random() < 0.5:\n            # Reorder segments based on objective contribution\n            segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(num_segments)]\n            random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n            if num_segments * segment_size < n:\n                new_solution = np.concatenate([new_solution, base_solution[num_segments*segment_size:]])\n        else:\n            # Reverse a segment\n            start = random.randint(0, n - segment_size)\n            new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values and applies a novel local search operator that combines adaptive segment reversal and objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i] = new_solution[j]\n            new_solution[j] = new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    adaptive_swap = random.choice([True, False])\n    if adaptive_swap:\n        for _ in range(3):\n            obj_weights = np.array(archive[selected_idx][1])\n            obj_weights = obj_weights / np.sum(obj_weights)\n            obj_choice = np.random.choice([0, 1, 2], p=obj_weights)\n\n            if obj_choice == 0:\n                distances = distance_matrix_1\n            elif obj_choice == 1:\n                distances = distance_matrix_2\n            else:\n                distances = distance_matrix_3\n\n            for idx in range(n):\n                current_node = new_solution[idx]\n                next_node = new_solution[(idx + 1) % n]\n                for candidate in range(n):\n                    if candidate == current_node or candidate == next_node:\n                        continue\n                    new_dist = distances[current_node, candidate] + distances[candidate, next_node]\n                    old_dist = distances[current_node, next_node]\n                    if new_dist < old_dist:\n                        new_solution[idx] = candidate\n                        new_solution[(idx + 1) % n] = next_node\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8211753043555052,
            3.239926612377167
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i] = new_solution[j]\n            new_solution[j] = new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    adaptive_swap = random.choice([True, False])\n    if adaptive_swap:\n        for _ in range(3):\n            obj_weights = np.array(archive[selected_idx][1])\n            obj_weights = obj_weights / np.sum(obj_weights)\n            obj_choice = np.random.choice([0, 1, 2], p=obj_weights)\n\n            if obj_choice == 0:\n                distances = distance_matrix_1\n            elif obj_choice == 1:\n                distances = distance_matrix_2\n            else:\n                distances = distance_matrix_3\n\n            for idx in range(n):\n                current_node = new_solution[idx]\n                next_node = new_solution[(idx + 1) % n]\n                for candidate in range(n):\n                    if candidate == current_node or candidate == next_node:\n                        continue\n                    new_dist = distances[current_node, candidate] + distances[candidate, next_node]\n                    old_dist = distances[current_node, next_node]\n                    if new_dist < old_dist:\n                        new_solution[idx] = candidate\n                        new_solution[(idx + 1) % n] = next_node\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with extreme objective values and applies a novel local search operator that combines edge swaps with segment reversals, guided by a multi-objective improvement criterion to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            k = random.randint(i, j) if j - i >= 2 else j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.40522421218673693,
            1.7036096692085265
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            k = random.randint(i, j) if j - i >= 2 else j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{The algorithm selects a solution from the archive based on its proximity to the ideal point in the objective space, then applies a hybrid local search operator that combines edge swaps and node reinsertions, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution closest to ideal point\n    ideal = (min(obj[0] for _, obj in archive),\n             min(obj[1] for _, obj in archive),\n             min(obj[2] for _, obj in archive))\n\n    def distance_to_ideal(obj):\n        return sum((o - i)**2 for o, i in zip(obj, ideal))**0.5\n\n    selected_idx = min(range(len(archive)), key=lambda i: distance_to_ideal(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps and node reinsertions\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Node reinsertion\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6325157696401673,
            1.9960194945335388
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution closest to ideal point\n    ideal = (min(obj[0] for _, obj in archive),\n             min(obj[1] for _, obj in archive),\n             min(obj[2] for _, obj in archive))\n\n    def distance_to_ideal(obj):\n        return sum((o - i)**2 for o, i in zip(obj, ideal))**0.5\n\n    selected_idx = min(range(len(archive)), key=lambda i: distance_to_ideal(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps and node reinsertions\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Node reinsertion\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for multi-objective improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines edge insertion and segment reversal moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and segment reversal\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion move\n        if random.random() < 0.5:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n        # Segment reversal move\n        else:\n            k = random.randint(i, j)\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8299074531675281,
            1.7322890996932983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and segment reversal\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion move\n        if random.random() < 0.5:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n        # Segment reversal move\n        else:\n            k = random.randint(i, j)\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{The algorithm selects a solution from the archive based on the diversity of its objective values, then applies a hybrid local search combining 4-opt and swap moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        min_val = min(obj)\n        max_val = max(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4343924028275584,
            1.5044419407844543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        min_val = min(obj)\n        max_val = max(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high Pareto-dominance potential, then applies a hybrid local search combining edge insertion and segment reversal, guided by a multi-objective evaluation function to generate an improved neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def pareto_potential(solution):\n        obj = archive[solution][1]\n        return sum(obj)\n\n    selected_idx = min(range(len(archive)), key=lambda i: pareto_potential(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i < 2:\n            continue\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            new_segment = np.roll(segment, random.randint(1, len(segment)-1))\n            new_solution[i:j+1] = new_segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6729574206561416,
            1.4175286889076233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def pareto_potential(solution):\n        obj = archive[solution][1]\n        return sum(obj)\n\n    selected_idx = min(range(len(archive)), key=lambda i: pareto_potential(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i < 2:\n            continue\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            new_segment = np.roll(segment, random.randint(1, len(segment)-1))\n            new_solution[i:j+1] = new_segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel weighted objective score that balances improvement potential and diversity, then applies a hybrid local search combining 2-opt, 3-opt, and a novel 4-opt move, guided by Pareto-dominance-aware objective evaluation to generate an improved neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement using weighted objective score\n    def objective_score(solution):\n        obj = archive[solution][1]\n        # Weighted combination of objective diversity and improvement potential\n        diversity = (abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])) / 3\n        improvement_potential = sum(obj) / 3\n        return diversity * 0.6 + improvement_potential * 0.4\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt, 3-opt, and 4-opt moves\n    n = len(new_solution)\n    for _ in range(7):  # Increased number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n        l = random.randint(k, j) if j - k >= 1 else j\n\n        move_type = random.random()\n        if move_type < 0.5:  # 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.8:  # 3-opt move\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:  # 4-opt move (novel)\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            new_solution[l:j+1] = new_solution[l:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.38861547447408534,
            1.9780382871627809
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement using weighted objective score\n    def objective_score(solution):\n        obj = archive[solution][1]\n        # Weighted combination of objective diversity and improvement potential\n        diversity = (abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])) / 3\n        improvement_potential = sum(obj) / 3\n        return diversity * 0.6 + improvement_potential * 0.4\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt, 3-opt, and 4-opt moves\n    n = len(new_solution)\n    for _ in range(7):  # Increased number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n        l = random.randint(k, j) if j - k >= 1 else j\n\n        move_type = random.random()\n        if move_type < 0.5:  # 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.8:  # 3-opt move\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:  # 4-opt move (novel)\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            new_solution[l:j+1] = new_solution[l:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with extreme objective values in at least one dimension, then applies a novel segment-based local search that combines random segment reversal with objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_diff = max(max(obj) - min(obj), abs(obj[0] - obj[1]), abs(obj[1] - obj[2]), abs(obj[2] - obj[0]))\n        return max_diff\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i = random.randint(0, n-1)\n            j = (i + random.randint(2, min(5, n-1))) % n\n            if i > j:\n                i, j = j, i\n            segment = new_solution[i:j+1]\n            for k in range(len(segment)-1):\n                if random.random() < 0.3:\n                    segment[k], segment[k+1] = segment[k+1], segment[k]\n            new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.47212209818023043,
            1.8183798789978027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_diff = max(max(obj) - min(obj), abs(obj[0] - obj[1]), abs(obj[1] - obj[2]), abs(obj[2] - obj[0]))\n        return max_diff\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i = random.randint(0, n-1)\n            j = (i + random.randint(2, min(5, n-1))) % n\n            if i > j:\n                i, j = j, i\n            segment = new_solution[i:j+1]\n            for k in range(len(segment)-1):\n                if random.random() < 0.3:\n                    segment[k], segment[k+1] = segment[k+1], segment[k]\n            new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{The algorithm selects a solution from the archive based on the highest combined distance improvement potential across all three objectives, then applies a hybrid local search operator that combines segment reversal and insertion moves with Pareto-dominance-aware selection to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def improvement_potential(solution):\n        obj = archive[solution][1]\n        total_distance = sum(obj)\n        return total_distance\n\n    selected_idx = min(range(len(archive)), key=lambda i: improvement_potential(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8123194587261395,
            1.3780120730400085
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def improvement_potential(solution):\n        obj = archive[solution][1]\n        total_distance = sum(obj)\n        return total_distance\n\n    selected_idx = min(range(len(archive)), key=lambda i: improvement_potential(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{The algorithm selects solutions from the archive with high potential by prioritizing those with diverse objective values and applies a hybrid local search operator that combines 4-opt and random segment swaps, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return sum(abs(x - y) for x in obj for y in obj) / (3 * 3)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(i, j+1), 2))\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            if random.random() < 0.5:\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            new_solution[i:j+1] = np.concatenate([new_solution[k:j+1], new_solution[i:k]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4362024710673597,
            2.802566707134247
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return sum(abs(x - y) for x in obj for y in obj) / (3 * 3)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(i, j+1), 2))\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            if random.random() < 0.5:\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            new_solution[i:j+1] = np.concatenate([new_solution[k:j+1], new_solution[i:k]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{The new algorithm selects a solution from the archive with high variance in objective values by prioritizing those with the largest differences between objectives, then applies a novel multi-objective local search operator that combines node swapping, insertion, and inversion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.random()\n        if move_type < 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif move_type < 0.7:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4590998023623528,
            1.6972575068473816
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.random()\n        if move_type < 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif move_type < 0.7:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a novel local search operator that combines 2-opt with a multi-objective-aware edge insertion heuristic to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            removed_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j], new_solution[(j+1)%n])]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, j)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7600309698690426,
            1.2175071954727172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            removed_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j], new_solution[(j+1)%n])]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, j)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high objective variance and applies a hybrid local search operator that combines 2-opt, 3-opt, and adaptive segment swaps, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return sum((o - mean) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif random.random() < 0.7:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            random.shuffle(segment)\n            new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.501031813516644,
            2.0726139426231383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return sum((o - mean) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif random.random() < 0.7:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            random.shuffle(segment)\n            new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high diversity in objective values and applies a novel segment-based local search that combines random segment reversal with adaptive segment length selection, guided by a multi-objective improvement criterion to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    max_attempts = 5\n    for _ in range(max_attempts):\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4645645611205289,
            1.822719144821167
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    max_attempts = 5\n    for _ in range(max_attempts):\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a novel local search operator that combines adaptive segment swapping and Pareto-dominance-aware edge insertion, guided by a multi-objective improvement metric to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        if random.random() < 0.7:\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9084004736464701,
            1.5727145195007324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        if random.random() < 0.7:\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high Pareto-front proximity and applies a novel edge-swap local search operator that considers both single and double edge swaps, guided by a weighted sum of objectives to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high Pareto-front proximity\n    def pareto_proximity(solution):\n        obj = archive[solution][1]\n        return sum(obj)\n\n    selected_idx = min(range(len(archive)), key=lambda i: pareto_proximity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Edge-swap local search\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Single edge swap\n        if random.random() < 0.6:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Double edge swap\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6772410437290677,
            1.585418438911438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high Pareto-front proximity\n    def pareto_proximity(solution):\n        obj = archive[solution][1]\n        return sum(obj)\n\n    selected_idx = min(range(len(archive)), key=lambda i: pareto_proximity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Edge-swap local search\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Single edge swap\n        if random.random() < 0.6:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Double edge swap\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a novel local search operator that combines adaptive edge swaps and segment relocations, guided by a multi-objective improvement metric to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(i, j) if j - i >= 2 else j\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8353406658326581,
            1.8748912572860719
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(i, j) if j - i >= 2 else j\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{This algorithm selects a solution from the archive based on the least crowded objective space to diversify exploration, then applies a hybrid local search combining edge insertion and segment reversal with adaptive move probabilities based on the solution's objective diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_crowding(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = min(range(len(archive)), key=lambda i: objective_crowding(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(i, j) if j - i >= 2 else j\n            if random.random() < 0.7:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8823503333263121,
            1.5073619842529298
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_crowding(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = min(range(len(archive)), key=lambda i: objective_crowding(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(i, j) if j - i >= 2 else j\n            if random.random() < 0.7:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with high objective variance and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function, but with adjusted parameters to balance exploration and exploitation more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return (obj[0] - mean)**2 + (obj[1] - mean)**2 + (obj[2] - mean)**2\n\n    # Prioritize solutions with higher objective variance\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves with adjusted parameters\n    n = len(new_solution)\n    for _ in range(3):  # Reduced number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move with higher probability\n        if random.random() < 0.8:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4716150493665605,
            1.8528698325157165
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return (obj[0] - mean)**2 + (obj[1] - mean)**2 + (obj[2] - mean)**2\n\n    # Prioritize solutions with higher objective variance\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves with adjusted parameters\n    n = len(new_solution)\n    for _ in range(3):  # Reduced number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move with higher probability\n        if random.random() < 0.8:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9054793818769638,
            1.6509454488754272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{The new algorithm selects a solution from the archive based on the sum of pairwise differences in objectives, applies a hybrid local search combining 2-opt and 3-opt moves with adaptive perturbation probabilities, and ensures feasibility by validating the solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.48603159755602554,
            1.6188477277755737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for multi-objective improvement by prioritizing those with diverse and balanced objective values, then applies a novel segment-based local search operator that combines adaptive edge swaps and segment reversals, guided by a Pareto-dominance-aware objective function, to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_score(solution):\n        obj = archive[solution][1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        balance = -sum((x - sum(obj)/3) ** 2 for x in obj)\n        return diversity + balance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n\n        if random.random() < 0.5:\n            segment = new_solution[start:start+segment_length]\n            new_segment = np.concatenate([segment[1:], segment[:1]])\n            new_solution[start:start+segment_length] = new_segment\n        else:\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7440355087077533,
            2.6346989631652833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_score(solution):\n        obj = archive[solution][1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        balance = -sum((x - sum(obj)/3) ** 2 for x in obj)\n        return diversity + balance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n\n        if random.random() < 0.5:\n            segment = new_solution[start:start+segment_length]\n            new_segment = np.concatenate([segment[1:], segment[:1]])\n            new_solution[start:start+segment_length] = new_segment\n        else:\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a multi-objective-aware local search operator that combines 2-opt and 3-opt moves with a novel objective-space adaptive perturbation strategy to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Adaptive perturbation based on objective space dominance\n        obj = archive[selected_idx][1]\n        if obj[0] > obj[1] and obj[0] > obj[2]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif obj[1] > obj[0] and obj[1] > obj[2]:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            if random.random() < 0.5:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9112439726507935,
            1.8350396513938905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Adaptive perturbation based on objective space dominance\n        obj = archive[selected_idx][1]\n        if obj[0] > obj[1] and obj[0] > obj[2]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif obj[1] > obj[0] and obj[1] > obj[2]:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            if random.random() < 0.5:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a novel multi-objective local search operator that combines 2-opt with a novel 4-opt move, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n        l = random.randint(k, j) if j - k >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            new_solution[l:j+1] = new_solution[l:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.43209290574590115,
            1.5241838335990905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n        l = random.randint(k, j) if j - k >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            new_solution[l:j+1] = new_solution[l:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8055718354213285,
            1.8788504481315613
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values and applies a novel local search operator that combines adaptive segment reversal and insertion moves, guided by a multi-objective improvement metric to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        operation = random.choice(['reverse', 'insert'])\n\n        if operation == 'reverse':\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8670585024165215,
            1.7425763368606568
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        operation = random.choice(['reverse', 'insert'])\n\n        if operation == 'reverse':\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel segment-based local search that combines adaptive edge swaps and segment rotations to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = sum(obj) / 3\n        return -sum(abs(o - mean_obj) for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment-based local search with adaptive operations\n    for _ in range(5):\n        # Randomly select a segment\n        seg_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - seg_length)\n        end = start + seg_length\n\n        # Adaptive operation selection\n        if random.random() < 0.6:\n            # Segment rotation\n            rotation = random.randint(1, seg_length-1)\n            new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n        else:\n            # Edge swap between segments\n            if end < n - 1:\n                other_start = random.randint(end, n - 2)\n                other_end = other_start + 1\n                new_solution[end], new_solution[other_start] = new_solution[other_start], new_solution[end]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7702585396582107,
            2.518247675895691
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = sum(obj) / 3\n        return -sum(abs(o - mean_obj) for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment-based local search with adaptive operations\n    for _ in range(5):\n        # Randomly select a segment\n        seg_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - seg_length)\n        end = start + seg_length\n\n        # Adaptive operation selection\n        if random.random() < 0.6:\n            # Segment rotation\n            rotation = random.randint(1, seg_length-1)\n            new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n        else:\n            # Edge swap between segments\n            if end < n - 1:\n                other_start = random.randint(end, n - 2)\n                other_end = other_start + 1\n                new_solution[end], new_solution[other_start] = new_solution[other_start], new_solution[end]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4367688771827532,
            1.9623125433921813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution, while also incorporating a novel segment rotation operator to enhance exploration of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i < 2:\n            continue\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            k = random.randint(i + 1, j - 1)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n            new_solution[i:j+1] = rotated_segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.895920758643969,
            1.8063631415367127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i < 2:\n            continue\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            k = random.randint(i + 1, j - 1)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n            new_solution[i:j+1] = rotated_segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{The algorithm selects the solution with the highest sum of normalized objective values from the archive, then applies a novel \"objective-biased segment inversion\" operator that inverts segments of the tour based on the relative contribution of each objective to the total cost, ensuring feasibility by maintaining unique node visits.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest sum of normalized objectives\n    def normalized_sum(solution):\n        obj = archive[solution][1]\n        total = sum(obj)\n        return sum(x / total for x in obj) if total > 0 else 0\n\n    selected_idx = max(range(len(archive)), key=lambda i: normalized_sum(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Objective-biased segment inversion\n    n = len(new_solution)\n    obj = archive[selected_idx][1]\n    total = sum(obj)\n    weights = [x / total for x in obj] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment length based on objective weights\n    segment_length = max(2, int(sum(w * n for w in weights)))\n\n    for _ in range(3):  # Multiple perturbation attempts\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Invert segment with probability based on objective weights\n        if random.random() < weights[0]:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6759983864909895,
            3.7961859703063965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest sum of normalized objectives\n    def normalized_sum(solution):\n        obj = archive[solution][1]\n        total = sum(obj)\n        return sum(x / total for x in obj) if total > 0 else 0\n\n    selected_idx = max(range(len(archive)), key=lambda i: normalized_sum(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Objective-biased segment inversion\n    n = len(new_solution)\n    obj = archive[selected_idx][1]\n    total = sum(obj)\n    weights = [x / total for x in obj] if total > 0 else [1/3, 1/3, 1/3]\n\n    # Determine segment length based on objective weights\n    segment_length = max(2, int(sum(w * n for w in weights)))\n\n    for _ in range(3):  # Multiple perturbation attempts\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Invert segment with probability based on objective weights\n        if random.random() < weights[0]:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with the worst objective values in at least one dimension, then applies a novel segment-based local search that combines reverse and shift operations, guided by a multi-objective improvement metric to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with the worst objective in at least one dimension\n    def worst_objective(solution):\n        obj = archive[solution][1]\n        return max(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: worst_objective(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment-based local search\n    segment_size = max(2, n // 5)\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Apply reverse or shift operation\n        if random.random() < 0.6:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            shift = random.randint(1, segment_size-1)\n            new_solution[start:end] = np.roll(new_solution[start:end], shift)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.5464992208811841,
            1.4790502786636353
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with the worst objective in at least one dimension\n    def worst_objective(solution):\n        obj = archive[solution][1]\n        return max(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: worst_objective(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment-based local search\n    segment_size = max(2, n // 5)\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Apply reverse or shift operation\n        if random.random() < 0.6:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            shift = random.randint(1, segment_size-1)\n            new_solution[start:end] = np.roll(new_solution[start:end], shift)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 3 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.424407708447874,
            1.6271998524665832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 3 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high diversity in objectives, then applies a novel local search operator that combines segment reversal and insertion moves, guided by a Pareto-dominance-aware objective function, to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment reversal and insertion\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Segment reversal\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Node insertion\n        else:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4568016106091938,
            1.9249704360961915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment reversal and insertion\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Segment reversal\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Node insertion\n        else:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and diverse objectives, then applies a hybrid local search operator that combines 2-opt, 3-opt, and a novel segment relocation move, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_score(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        balance = -sum((x - mean) ** 2 for x in obj)\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        return balance + 0.5 * diversity\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        move_type = random.random()\n\n        if move_type < 0.4:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(i, j) if j - i >= 2 else j\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7903131191027997,
            1.7746522068977355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_score(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        balance = -sum((x - mean) ** 2 for x in obj)\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        return balance + 0.5 * diversity\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        move_type = random.random()\n\n        if move_type < 0.4:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(i, j) if j - i >= 2 else j\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.827206925700805,
            1.7755272030830382
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a novel local search operator that combines segment reversal, node insertion, and edge exchange moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        move_type = random.choice(['reverse', 'insert', 'exchange'])\n\n        if move_type == 'reverse':\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif move_type == 'insert':\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n        elif move_type == 'exchange':\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9246151904751023,
            1.7586615681648254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        move_type = random.choice(['reverse', 'insert', 'exchange'])\n\n        if move_type == 'reverse':\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif move_type == 'insert':\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n        elif move_type == 'exchange':\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution, while also incorporating a novel segment reversal strategy to enhance exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            k = random.randint(i, j) if j - i >= 2 else j\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8598640070665221,
            1.7605398774147034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            k = random.randint(i, j) if j - i >= 2 else j\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with high variance in objectives, applies a hybrid local search combining 3-opt and edge exchange moves, and uses a Pareto-dominance-aware objective function to guide the search for improved solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high objective variance\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((x - mean) ** 2 for x in obj) / 3\n        return variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and edge exchange\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 3-opt move\n        if random.random() < 0.6:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        # Edge exchange move\n        else:\n            l = random.randint(0, n-1)\n            new_solution[i], new_solution[l] = new_solution[l], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4578086686943255,
            1.9683849811553955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high objective variance\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((x - mean) ** 2 for x in obj) / 3\n        return variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt and edge exchange\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 3-opt move\n        if random.random() < 0.6:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        # Edge exchange move\n        else:\n            l = random.randint(0, n-1)\n            new_solution[i], new_solution[l] = new_solution[l], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective diversity and current objective values, then applies a hybrid local search operator that combines 4-opt and edge exchange moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def selection_score(solution_idx):\n        obj = archive[solution_idx][1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        total = sum(obj)\n        return diversity * 0.6 + total * 0.4\n\n    selected_idx = max(range(len(archive)), key=lambda i: selection_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge exchange moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.5:\n            # 4-opt move\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            # Edge exchange move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.44199156486091307,
            1.7562205791473389
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def selection_score(solution_idx):\n        obj = archive[solution_idx][1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        total = sum(obj)\n        return diversity * 0.6 + total * 0.4\n\n    selected_idx = max(range(len(archive)), key=lambda i: selection_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge exchange moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.5:\n            # 4-opt move\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            # Edge exchange move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objectives and applies a novel multi-objective local search operator that combines 2-opt and 3-opt moves with a diversity-aware objective function, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = sum(obj) / 3\n        return -sum((o - mean_obj) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: 2-opt and 3-opt moves with diversity consideration\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Apply 2-opt or 3-opt move based on objective diversity\n        obj_diversity = abs(distance_matrix_1[new_solution[i], new_solution[j]] - distance_matrix_2[new_solution[i], new_solution[j]]) + \\\n                        abs(distance_matrix_2[new_solution[i], new_solution[j]] - distance_matrix_3[new_solution[i], new_solution[j]]) + \\\n                        abs(distance_matrix_3[new_solution[i], new_solution[j]] - distance_matrix_1[new_solution[i], new_solution[j]])\n\n        if obj_diversity > 0.5 * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]]):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.909484286157878,
            1.6662965774536134
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = sum(obj) / 3\n        return -sum((o - mean_obj) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: 2-opt and 3-opt moves with diversity consideration\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Apply 2-opt or 3-opt move based on objective diversity\n        obj_diversity = abs(distance_matrix_1[new_solution[i], new_solution[j]] - distance_matrix_2[new_solution[i], new_solution[j]]) + \\\n                        abs(distance_matrix_2[new_solution[i], new_solution[j]] - distance_matrix_3[new_solution[i], new_solution[j]]) + \\\n                        abs(distance_matrix_3[new_solution[i], new_solution[j]] - distance_matrix_1[new_solution[i], new_solution[j]])\n\n        if obj_diversity > 0.5 * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]]):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{The algorithm selects a solution from the archive that shows high potential for improvement by prioritizing those with balanced objective values, then applies a novel local search operator that combines 2-opt and 3-opt moves with a probabilistic selection of segments based on their contribution to the objectives, ensuring feasibility and diversity in the generated neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8179265319806467,
            1.7937897562980651
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with extreme objective values (to explore under-explored regions) and applies a novel local search operator that combines edge insertion and segment reversal moves, guided by a multi-objective improvement criterion to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_obj = max(obj)\n        min_obj = min(obj)\n        return max_obj - min_obj\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution[i] = new_solution[j]\n            new_solution[j] = new_solution[k]\n            new_solution[k] = new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.45116628089803096,
            1.0642325401306152
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_obj = max(obj)\n        min_obj = min(obj)\n        return max_obj - min_obj\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution[i] = new_solution[j]\n            new_solution[j] = new_solution[k]\n            new_solution[k] = new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values and applies a novel multi-objective local search operator that combines segment reversal, insertion, and swap operations, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        op = random.choice(['reverse', 'insert', 'swap'])\n\n        if op == 'reverse':\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif op == 'insert':\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n        elif op == 'swap':\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8644765874940654,
            1.6907575368881225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        op = random.choice(['reverse', 'insert', 'swap'])\n\n        if op == 'reverse':\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif op == 'insert':\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n        elif op == 'swap':\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by prioritizing those with extreme objective values and applies a hybrid local search operator that combines 4-opt and edge insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with extreme objective values\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge insertion\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.5:\n            # 4-opt move\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            # Edge insertion move\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            if j - i > 1:\n                new_solution[i+1:j] = new_solution[i:j-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.45630629201532386,
            1.1223742008209228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with extreme objective values\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and edge insertion\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.5:\n            # 4-opt move\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            # Edge insertion move\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            if j - i > 1:\n                new_solution[i+1:j] = new_solution[i:j-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{The new algorithm selects a solution from the archive based on its objective dominance and applies a novel combination of edge-swapping and segment-reversing moves, guided by a weighted objective function that balances all three objectives, to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_weighted_score(solution):\n        obj = archive[solution][1]\n        return 0.4 * obj[0] + 0.3 * obj[1] + 0.3 * obj[2]\n\n    selected_idx = min(range(len(archive)), key=lambda i: objective_weighted_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge-swapping and segment-reversing\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Edge-swapping move\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Segment-reversing move\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6280133411941724,
            1.451646637916565
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_weighted_score(solution):\n        obj = archive[solution][1]\n        return 0.4 * obj[0] + 0.3 * obj[1] + 0.3 * obj[2]\n\n    selected_idx = min(range(len(archive)), key=lambda i: objective_weighted_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge-swapping and segment-reversing\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Edge-swapping move\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Segment-reversing move\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a novel local search operator that combines multi-objective-aware edge swaps with a dynamic neighborhood exploration strategy to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            temp = new_solution[i:j+1]\n            random.shuffle(temp)\n            new_solution[i:j+1] = temp\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7722320578598769,
            1.7941255450248719
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            temp = new_solution[i:j+1]\n            random.shuffle(temp)\n            new_solution[i:j+1] = temp\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objectives, then applies a hybrid local search operator combining 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function, to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = (obj[0] + obj[1] + obj[2]) / 3\n        return -sum((o - mean_obj) ** 2 for o in obj)  # Negative for minimization\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7016685016512604,
            1.7286740303039552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = (obj[0] + obj[1] + obj[2]) / 3\n        return -sum((o - mean_obj) ** 2 for o in obj)  # Negative for minimization\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with extreme objective values (either very high or very low in at least one objective) and applies a novel \"multi-objective inversion\" operator that inverts segments of the tour while considering the trade-offs between objectives, guided by a hybrid of Pareto-dominance and objective-specific improvement criteria to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.3873826839869905,
            1.7254374027252197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines edge insertion and node relocation moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((o - mean) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and node relocation\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion\n        if random.random() < 0.6:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n        # Node relocation\n        else:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8334658868328644,
            2.0006711006164553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((o - mean) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and node relocation\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion\n        if random.random() < 0.6:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n        # Node relocation\n        else:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.42082399443948126,
            1.6434364199638367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel objective diversity score that considers both the spread of objectives and their normalized differences, then applies a hybrid local search combining 2-opt and 3-opt moves with a Pareto-dominance-aware selection criterion to generate an improved neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalize objectives to [0,1] range\n    all_objs = [obj for _, obj in archive]\n    obj1_min, obj1_max = min(o[0] for o in all_objs), max(o[0] for o in all_objs)\n    obj2_min, obj2_max = min(o[1] for o in all_objs), max(o[1] for o in all_objs)\n    obj3_min, obj3_max = min(o[2] for o in all_objs), max(o[2] for o in all_objs)\n\n    def normalized_diversity(solution):\n        obj = archive[solution][1]\n        norm_obj1 = (obj[0] - obj1_min) / (obj1_max - obj1_min + 1e-10)\n        norm_obj2 = (obj[1] - obj2_min) / (obj2_max - obj2_min + 1e-10)\n        norm_obj3 = (obj[2] - obj3_min) / (obj3_max - obj3_min + 1e-10)\n        return (abs(norm_obj1 - norm_obj2) + abs(norm_obj2 - norm_obj3) + abs(norm_obj3 - norm_obj1)) * (norm_obj1 + norm_obj2 + norm_obj3)\n\n    # Select solution with highest normalized diversity\n    selected_idx = max(range(len(archive)), key=lambda i: normalized_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with Pareto-aware move selection\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Generate candidate solutions\n        candidates = []\n        # 2-opt move\n        candidate_2opt = new_solution.copy()\n        candidate_2opt[i:j+1] = candidate_2opt[i:j+1][::-1]\n        candidates.append(candidate_2opt)\n\n        # 3-opt move\n        candidate_3opt = new_solution.copy()\n        candidate_3opt[i:k+1] = candidate_3opt[i:k+1][::-1]\n        candidate_3opt[k:j+1] = candidate_3opt[k:j+1][::-1]\n        candidates.append(candidate_3opt)\n\n        # Evaluate candidates\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate total tour length in all three objectives\n            total_cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            total_cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            total_cost3 = sum(distance_matrix_3[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            # Pareto-dominance aware score\n            score = (total_cost1 + total_cost2 + total_cost3) / 3\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate\n\n        if best_candidate is not None:\n            new_solution = best_candidate.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6623817199701942,
            3.750662994384766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalize objectives to [0,1] range\n    all_objs = [obj for _, obj in archive]\n    obj1_min, obj1_max = min(o[0] for o in all_objs), max(o[0] for o in all_objs)\n    obj2_min, obj2_max = min(o[1] for o in all_objs), max(o[1] for o in all_objs)\n    obj3_min, obj3_max = min(o[2] for o in all_objs), max(o[2] for o in all_objs)\n\n    def normalized_diversity(solution):\n        obj = archive[solution][1]\n        norm_obj1 = (obj[0] - obj1_min) / (obj1_max - obj1_min + 1e-10)\n        norm_obj2 = (obj[1] - obj2_min) / (obj2_max - obj2_min + 1e-10)\n        norm_obj3 = (obj[2] - obj3_min) / (obj3_max - obj3_min + 1e-10)\n        return (abs(norm_obj1 - norm_obj2) + abs(norm_obj2 - norm_obj3) + abs(norm_obj3 - norm_obj1)) * (norm_obj1 + norm_obj2 + norm_obj3)\n\n    # Select solution with highest normalized diversity\n    selected_idx = max(range(len(archive)), key=lambda i: normalized_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with Pareto-aware move selection\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Generate candidate solutions\n        candidates = []\n        # 2-opt move\n        candidate_2opt = new_solution.copy()\n        candidate_2opt[i:j+1] = candidate_2opt[i:j+1][::-1]\n        candidates.append(candidate_2opt)\n\n        # 3-opt move\n        candidate_3opt = new_solution.copy()\n        candidate_3opt[i:k+1] = candidate_3opt[i:k+1][::-1]\n        candidate_3opt[k:j+1] = candidate_3opt[k:j+1][::-1]\n        candidates.append(candidate_3opt)\n\n        # Evaluate candidates\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate total tour length in all three objectives\n            total_cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            total_cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            total_cost3 = sum(distance_matrix_3[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            # Pareto-dominance aware score\n            score = (total_cost1 + total_cost2 + total_cost3) / 3\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate\n\n        if best_candidate is not None:\n            new_solution = best_candidate.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with extreme objective values in at least one dimension, then applies a novel hybrid local search that combines 2-opt with a multi-objective-aware segment insertion, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_diff = max(abs(obj[0] - obj[1]), abs(obj[1] - obj[2]), abs(obj[2] - obj[0]))\n        return max_diff\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            k = random.randint(0, n-1)\n            if k < i or k > j:\n                segment = new_solution[i:j+1]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4181304584546253,
            1.6823384284973144
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_diff = max(abs(obj[0] - obj[1]), abs(obj[1] - obj[2]), abs(obj[2] - obj[0]))\n        return max_diff\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            k = random.randint(0, n-1)\n            if k < i or k > j:\n                segment = new_solution[i:j+1]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function, while also considering the instance-specific distance matrices to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return sum(abs(x - y) for x, y in zip(obj, obj[1:]))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.45534549886827963,
            1.9655476808547974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return sum(abs(x - y) for x, y in zip(obj, obj[1:]))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{The algorithm selects a solution from the archive based on the worst objective value to target improvement in all objectives, then applies a hybrid local search combining 2-opt and 4-opt moves, guided by a weighted sum of objectives to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_worst(solution):\n        obj = archive[solution][1]\n        return max(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_worst(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            new_solution[l:j+1] = new_solution[l:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4710979708938125,
            1.504372775554657
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_worst(solution):\n        obj = archive[solution][1]\n        return max(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_worst(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            new_solution[l:j+1] = new_solution[l:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{The algorithm selects a solution from the archive based on a novel objective correlation metric that combines the normalized differences between objectives and the solution's position entropy, then applies a multi-phase local search that alternates between objective-specific 2-opt moves and a novel \"objective-aware\" node relocation operator to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate objective correlation metric\n    def objective_correlation(solution):\n        obj = archive[solution][1]\n        norm_diff = [(obj[i] - obj[j]) / (max(obj) - min(obj) + 1e-6) for i in range(3) for j in range(i+1, 3)]\n        position_entropy = -sum(p * np.log(p + 1e-6) for p in [abs(obj[0]-obj[1]), abs(obj[1]-obj[2]), abs(obj[2]-obj[0])])\n        return sum(norm_diff) + position_entropy\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_correlation(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    phases = 3  # Multi-phase local search\n\n    for phase in range(phases):\n        # Objective-specific 2-opt moves\n        for obj_idx in range(3):\n            if phase == obj_idx:\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware node relocation\n        if phase == phases - 1:\n            pos = random.randint(0, n-1)\n            node = new_solution[pos]\n            del new_solution[pos]\n            insert_pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7963287126320835,
            4.192452442646027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate objective correlation metric\n    def objective_correlation(solution):\n        obj = archive[solution][1]\n        norm_diff = [(obj[i] - obj[j]) / (max(obj) - min(obj) + 1e-6) for i in range(3) for j in range(i+1, 3)]\n        position_entropy = -sum(p * np.log(p + 1e-6) for p in [abs(obj[0]-obj[1]), abs(obj[1]-obj[2]), abs(obj[2]-obj[0])])\n        return sum(norm_diff) + position_entropy\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_correlation(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    phases = 3  # Multi-phase local search\n\n    for phase in range(phases):\n        # Objective-specific 2-opt moves\n        for obj_idx in range(3):\n            if phase == obj_idx:\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware node relocation\n        if phase == phases - 1:\n            pos = random.randint(0, n-1)\n            node = new_solution[pos]\n            del new_solution[pos]\n            insert_pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{The algorithm selects a solution from the archive based on a novel diversity-aware metric that balances improvement potential across all three objectives, then applies a multi-objective-aware local search operator that combines a novel segment rotation with a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(i+1, 3))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        if random.random() < 0.5:\n            rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n            new_solution[i:j+1] = rotated_segment\n        else:\n            new_solution[i:j+1] = segment[::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.41884052002648764,
            2.2271546363830566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(i+1, 3))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        if random.random() < 0.5:\n            rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n            new_solution[i:j+1] = rotated_segment\n        else:\n            new_solution[i:j+1] = segment[::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{The new algorithm selects a solution from the archive based on the sum of squared differences between objectives, applies a hybrid local search combining 2-opt and 3-opt moves, and ensures feasibility by validating the neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.48896318731843325,
            1.660844087600708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel multi-objective local search operator that combines 2-opt and 3-opt moves with a dynamic weighting strategy to balance improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    weights = [0.4, 0.3, 0.3]\n\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n            if len(np.unique(candidate)) == n:\n                new_solution = candidate\n        else:\n            candidate = new_solution.copy()\n            candidate[i:k+1] = candidate[i:k+1][::-1]\n            candidate[k:j+1] = candidate[k:j+1][::-1]\n            if len(np.unique(candidate)) == n:\n                new_solution = candidate\n\n        if random.random() < 0.2:\n            weights = [random.random() for _ in range(3)]\n            weights = [w/sum(weights) for w in weights]\n\n    return new_solution\n\n",
        "score": [
            -0.8006069752981579,
            1.555431854724884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    weights = [0.4, 0.3, 0.3]\n\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n            if len(np.unique(candidate)) == n:\n                new_solution = candidate\n        else:\n            candidate = new_solution.copy()\n            candidate[i:k+1] = candidate[i:k+1][::-1]\n            candidate[k:j+1] = candidate[k:j+1][::-1]\n            if len(np.unique(candidate)) == n:\n                new_solution = candidate\n\n        if random.random() < 0.2:\n            weights = [random.random() for _ in range(3)]\n            weights = [w/sum(weights) for w in weights]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with the worst objective values in any space, then applies a novel local search operator that combines a segment inversion with a multi-objective-aware swap operation to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the worst objective in any space\n    def worst_objective(solution):\n        obj = archive[solution][1]\n        return max(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: worst_objective(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: segment inversion + multi-objective swap\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Segment inversion\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Multi-objective swap\n        if random.random() < 0.5:\n            swap_candidates = []\n            for l in range(n):\n                if l != k:\n                    obj_diff = (abs(distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] - distance_matrix_1[new_solution[k-1], new_solution[k]] - distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]) +\n                               abs(distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] - distance_matrix_2[new_solution[k-1], new_solution[k]] - distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]) +\n                               abs(distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l], new_solution[(k+1)%n]] - distance_matrix_3[new_solution[k-1], new_solution[k]] - distance_matrix_3[new_solution[k], new_solution[(k+1)%n]]))\n                    swap_candidates.append((obj_diff, l))\n\n            if swap_candidates:\n                _, best_l = min(swap_candidates, key=lambda x: x[0])\n                new_solution[k], new_solution[best_l] = new_solution[best_l], new_solution[k]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.41412325347970463,
            1.7383291482925416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the worst objective in any space\n    def worst_objective(solution):\n        obj = archive[solution][1]\n        return max(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: worst_objective(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: segment inversion + multi-objective swap\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Segment inversion\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Multi-objective swap\n        if random.random() < 0.5:\n            swap_candidates = []\n            for l in range(n):\n                if l != k:\n                    obj_diff = (abs(distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] - distance_matrix_1[new_solution[k-1], new_solution[k]] - distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]) +\n                               abs(distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] - distance_matrix_2[new_solution[k-1], new_solution[k]] - distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]) +\n                               abs(distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l], new_solution[(k+1)%n]] - distance_matrix_3[new_solution[k-1], new_solution[k]] - distance_matrix_3[new_solution[k], new_solution[(k+1)%n]]))\n                    swap_candidates.append((obj_diff, l))\n\n            if swap_candidates:\n                _, best_l = min(swap_candidates, key=lambda x: x[0])\n                new_solution[k], new_solution[best_l] = new_solution[best_l], new_solution[k]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with high objective diversity and applies a novel local search operator that combines adaptive edge insertion and segment reversal moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            # Adaptive edge insertion\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n        else:\n            # Segment reversal with adaptive length\n            seg_length = min(5, n // 2)\n            start = random.randint(0, n - seg_length)\n            end = start + random.randint(1, seg_length)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.41815792818715203,
            2.2657366156578065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            # Adaptive edge insertion\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n        else:\n            # Segment reversal with adaptive length\n            seg_length = min(5, n // 2)\n            start = random.randint(0, n - seg_length)\n            end = start + random.randint(1, seg_length)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values, then applies a novel segment-based local search operator that combines adaptive 2-opt and insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel segment-based local search\n    n = len(new_solution)\n    segment_size = max(3, n // 4)\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Adaptive move selection\n        if random.random() < 0.6:\n            # Segment reversal (2-opt variant)\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            # Segment insertion (insertion variant)\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7241652596394119,
            2.052523398399353
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel segment-based local search\n    n = len(new_solution)\n    segment_size = max(3, n // 4)\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Adaptive move selection\n        if random.random() < 0.6:\n            # Segment reversal (2-opt variant)\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            # Segment insertion (insertion variant)\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid local search operator that combines edge swaps and node insertions, guided by Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps and node insertions\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Edge swap\n        if random.random() < 0.6:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Node insertion\n        else:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4278378056466674,
            1.6934844851493835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps and node insertions\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Edge swap\n        if random.random() < 0.6:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Node insertion\n        else:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel local search operator that combines segment reversal with adaptive step-size selection, guided by a multi-objective improvement metric to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    max_attempts = 5\n    step_size = max(2, n // 10)  # Adaptive step size\n\n    for _ in range(max_attempts):\n        # Select a segment with adaptive size\n        segment_start = random.randint(0, n - step_size - 1)\n        segment_end = segment_start + step_size\n\n        # Reverse the segment\n        new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n        # Adapt step size based on improvement potential\n        if random.random() < 0.3:\n            step_size = max(2, step_size - 1)\n        else:\n            step_size = min(n // 2, step_size + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.5464844521075606,
            2.641722929477692
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    max_attempts = 5\n    step_size = max(2, n // 10)  # Adaptive step size\n\n    for _ in range(max_attempts):\n        # Select a segment with adaptive size\n        segment_start = random.randint(0, n - step_size - 1)\n        segment_end = segment_start + step_size\n\n        # Reverse the segment\n        new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n        # Adapt step size based on improvement potential\n        if random.random() < 0.3:\n            step_size = max(2, step_size - 1)\n        else:\n            step_size = min(n // 2, step_size + 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{The algorithm selects a solution from the archive based on a novel scoring function that combines objective diversity and solution quality, then applies a hybrid local search operator combining 2-opt, 3-opt, and a novel \"multi-objective swap\" move to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # New scoring function combining objective diversity and quality\n    def score_solution(solution_idx):\n        obj = archive[solution_idx][1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        quality = sum(obj)  # Lower is better\n        return diversity / (1 + quality)  # Normalized score\n\n    selected_idx = max(range(len(archive)), key=lambda i: score_solution(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(10):  # Increased perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.random()\n        if move_type < 0.3:  # 2-opt\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.6:  # 3-opt\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:  # Multi-objective swap\n            if random.random() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Swap segments considering all three objectives\n                segment = new_solution[i:j+1]\n                obj1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n                obj2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n                obj3 = sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n                if obj1 < obj2 and obj1 < obj3:\n                    new_solution[i:j+1] = segment[::-1]\n                elif obj2 < obj3:\n                    new_solution[i:j+1] = segment[::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.42939320389454105,
            1.9506320834159852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # New scoring function combining objective diversity and quality\n    def score_solution(solution_idx):\n        obj = archive[solution_idx][1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        quality = sum(obj)  # Lower is better\n        return diversity / (1 + quality)  # Normalized score\n\n    selected_idx = max(range(len(archive)), key=lambda i: score_solution(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(10):  # Increased perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.random()\n        if move_type < 0.3:  # 2-opt\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.6:  # 3-opt\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:  # Multi-objective swap\n            if random.random() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Swap segments considering all three objectives\n                segment = new_solution[i:j+1]\n                obj1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n                obj2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n                obj3 = sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n                if obj1 < obj2 and obj1 < obj3:\n                    new_solution[i:j+1] = segment[::-1]\n                elif obj2 < obj3:\n                    new_solution[i:j+1] = segment[::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7772996741891113,
            1.8517713785171508
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{This new algorithm selects a solution from the archive by prioritizing those with the highest diversity in objective values, then applies a hybrid local search operator that combines a novel \"multi-objective segment inversion\" with random edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            for obj_idx in range(3):\n                if obj_idx == 0:\n                    dm = distance_matrix_1\n                elif obj_idx == 1:\n                    dm = distance_matrix_2\n                else:\n                    dm = distance_matrix_3\n\n                if random.random() < 0.3:\n                    current_cost = sum(dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j], new_solution[(j+1)%n]] for i, j in zip(range(n), range(1, n)))\n                    temp_solution = new_solution.copy()\n                    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n                    new_cost = sum(dm[temp_solution[i-1], temp_solution[i]] + dm[temp_solution[j], temp_solution[(j+1)%n]] for i, j in zip(range(n), range(1, n)))\n\n                    if new_cost < current_cost:\n                        new_solution = temp_solution\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4301936299128745,
            2.525762617588043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            for obj_idx in range(3):\n                if obj_idx == 0:\n                    dm = distance_matrix_1\n                elif obj_idx == 1:\n                    dm = distance_matrix_2\n                else:\n                    dm = distance_matrix_3\n\n                if random.random() < 0.3:\n                    current_cost = sum(dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j], new_solution[(j+1)%n]] for i, j in zip(range(n), range(1, n)))\n                    temp_solution = new_solution.copy()\n                    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n                    new_cost = sum(dm[temp_solution[i-1], temp_solution[i]] + dm[temp_solution[j], temp_solution[(j+1)%n]] for i, j in zip(range(n), range(1, n)))\n\n                    if new_cost < current_cost:\n                        new_solution = temp_solution\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objectives and applies a novel local search operator that combines node insertion, swap, and reverse operations, guided by a multi-objective improvement criterion to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return min(obj) / (max(obj) + 1e-10)  # Avoid division by zero\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: combine node insertion, swap, and reverse\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        op = random.random()\n\n        if op < 0.3:  # Node insertion\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n        elif op < 0.6:  # Swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Reverse segment\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8068388068312695,
            1.4231994032859803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return min(obj) / (max(obj) + 1e-10)  # Avoid division by zero\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: combine node insertion, swap, and reverse\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        op = random.random()\n\n        if op < 0.3:  # Node insertion\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n        elif op < 0.6:  # Swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Reverse segment\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{The algorithm selects a solution from the archive that has the best balance across all three objectives by minimizing the maximum individual objective value, then applies a novel \"objective-aware segment inversion\" local search that inverts segments of the tour while prioritizing improvements in the most underperforming objective, ensuring feasibility and multi-objective progress.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best balance across objectives (minimize max individual objective)\n    selected_idx = min(range(len(archive)), key=lambda i: max(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Objective-aware segment inversion\n    n = len(new_solution)\n    for _ in range(5):\n        # Identify most underperforming objective\n        obj = archive[selected_idx][1]\n        worst_obj = np.argmax(obj)\n\n        # Select segment to invert based on worst objective\n        if worst_obj == 0:\n            distances = distance_matrix_1\n        elif worst_obj == 1:\n            distances = distance_matrix_2\n        else:\n            distances = distance_matrix_3\n\n        i, j = sorted(random.sample(range(n), 2))\n        current_segment_cost = sum(distances[new_solution[i-1], new_solution[i]] for i in range(i, j+1)) + distances[new_solution[j], new_solution[i]]\n\n        # Try inversion\n        inverted_segment = new_solution[i:j+1][::-1]\n        new_solution[i:j+1] = inverted_segment\n        new_segment_cost = sum(distances[new_solution[i-1], new_solution[i]] for i in range(i, j+1)) + distances[new_solution[j], new_solution[i]]\n\n        # Accept if improvement in worst objective\n        if new_segment_cost < current_segment_cost:\n            break\n        else:\n            # Revert if no improvement\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.627346155382593,
            2.7596492528915406
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best balance across objectives (minimize max individual objective)\n    selected_idx = min(range(len(archive)), key=lambda i: max(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Objective-aware segment inversion\n    n = len(new_solution)\n    for _ in range(5):\n        # Identify most underperforming objective\n        obj = archive[selected_idx][1]\n        worst_obj = np.argmax(obj)\n\n        # Select segment to invert based on worst objective\n        if worst_obj == 0:\n            distances = distance_matrix_1\n        elif worst_obj == 1:\n            distances = distance_matrix_2\n        else:\n            distances = distance_matrix_3\n\n        i, j = sorted(random.sample(range(n), 2))\n        current_segment_cost = sum(distances[new_solution[i-1], new_solution[i]] for i in range(i, j+1)) + distances[new_solution[j], new_solution[i]]\n\n        # Try inversion\n        inverted_segment = new_solution[i:j+1][::-1]\n        new_solution[i:j+1] = inverted_segment\n        new_segment_cost = sum(distances[new_solution[i-1], new_solution[i]] for i in range(i, j+1)) + distances[new_solution[j], new_solution[i]]\n\n        # Accept if improvement in worst objective\n        if new_segment_cost < current_segment_cost:\n            break\n        else:\n            # Revert if no improvement\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values, then applies a novel multi-objective local search operator that combines adaptive segment reversal with objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i < 2:\n            continue\n\n        segment = new_solution[i:j+1]\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        else:\n            k = random.randint(i, j-1)\n            segment = np.concatenate([segment[k:], segment[:k]])\n\n        new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8372785418148032,
            1.6440202593803406
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i < 2:\n            continue\n\n        segment = new_solution[i:j+1]\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        else:\n            k = random.randint(i, j-1)\n            segment = np.concatenate([segment[k:], segment[:k]])\n\n        new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a hybrid local search combining 2-opt, 3-opt, and adaptive perturbation moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum(abs(o - mean) for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive moves\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.random()\n        if move_type < 0.4:\n            # 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.7:\n            # 3-opt move\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            # Adaptive perturbation\n            segment = new_solution[i:j+1]\n            random.shuffle(segment)\n            new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8351795921222408,
            1.6221622943878173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum(abs(o - mean) for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive moves\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.random()\n        if move_type < 0.4:\n            # 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.7:\n            # 3-opt move\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            # Adaptive perturbation\n            segment = new_solution[i:j+1]\n            random.shuffle(segment)\n            new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{The algorithm selects a solution from the archive based on its diversity and objective improvement potential, then applies a hybrid local search combining edge-swap and node-insertion moves, guided by a dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return sum(obj) / 3\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i:\n                j = random.randint(0, n-1)\n            new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6919323598321292,
            1.439746868610382
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return sum(obj) / 3\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i:\n                j = random.randint(0, n-1)\n            new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with extreme objective values in one or more dimensions, then applies a novel local search operator that combines segment reversal with adaptive step-size optimization guided by the Pareto front, ensuring feasibility and multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_diff = max(obj) - min(obj)\n        return max_diff\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        step = random.randint(1, min(5, j - i + 1))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            for k in range(0, len(segment), step):\n                segment[k:k+step] = segment[k:k+step][::-1]\n            new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4265283534164638,
            1.7168309807777404
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_diff = max(obj) - min(obj)\n        return max_diff\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        step = random.randint(1, min(5, j - i + 1))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            for k in range(0, len(segment), step):\n                segment[k:k+step] = segment[k:k+step][::-1]\n            new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with extreme objective values (either very high or very low in at least one dimension) and applies a novel local search operator that combines segment reversal with node insertion, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            segment = new_solution[i:j]\n            np.random.shuffle(segment)\n            new_solution[i:j] = segment\n        else:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4970075417253212,
            1.476461398601532
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            segment = new_solution[i:j]\n            np.random.shuffle(segment)\n            new_solution[i:j] = segment\n        else:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high variance in objective values and applies a novel local search operator that combines segment inversion and segment rotation moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((x - mean) ** 2 for x in obj) / 3\n        return variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n            new_solution[i:j+1] = rotated_segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.44296223104390897,
            1.9410602927207947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((x - mean) ** 2 for x in obj) / 3\n        return variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n            new_solution[i:j+1] = rotated_segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel segment-based local search operator that combines random segment reversal and segment insertion, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel segment-based local search\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        # Randomly select a segment to manipulate\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        segment = new_solution[seg_start:seg_end+1]\n\n        # With 60% probability, reverse the segment\n        if random.random() < 0.6:\n            new_solution[seg_start:seg_end+1] = segment[::-1]\n        # With 40% probability, insert the segment elsewhere\n        else:\n            insert_pos = random.randint(0, n-1)\n            if insert_pos < seg_start:\n                new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:seg_start], new_solution[seg_end+1:]])\n            elif insert_pos > seg_end:\n                new_solution = np.concatenate([new_solution[:seg_end+1], new_solution[seg_start:seg_end+1], new_solution[seg_end+1:insert_pos], new_solution[insert_pos:]])\n            else:\n                new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.3965815999758179,
            1.4725399494171143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel segment-based local search\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        # Randomly select a segment to manipulate\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        segment = new_solution[seg_start:seg_end+1]\n\n        # With 60% probability, reverse the segment\n        if random.random() < 0.6:\n            new_solution[seg_start:seg_end+1] = segment[::-1]\n        # With 40% probability, insert the segment elsewhere\n        else:\n            insert_pos = random.randint(0, n-1)\n            if insert_pos < seg_start:\n                new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:seg_start], new_solution[seg_end+1:]])\n            elif insert_pos > seg_end:\n                new_solution = np.concatenate([new_solution[:seg_end+1], new_solution[seg_start:seg_end+1], new_solution[seg_end+1:insert_pos], new_solution[insert_pos:]])\n            else:\n                new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function, while incorporating adaptive neighborhood exploration to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8808014175699036,
            1.6762495994567872
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with extreme objective values in any dimension, then applies a novel \"objective-biased\" local search that combines segment reversal and node swaps, guided by the worst-performing objective to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with extreme objective values in any dimension\n    def extreme_objective(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: extreme_objective(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Objective-biased local search\n    n = len(new_solution)\n    worst_obj = archive[selected_idx][1].index(max(archive[selected_idx][1]))\n\n    for _ in range(3):  # Limited attempts for efficiency\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Segment reversal biased by worst objective\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Node swap biased by worst objective\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4331127813577586,
            1.6595754504203797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with extreme objective values in any dimension\n    def extreme_objective(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: extreme_objective(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Objective-biased local search\n    n = len(new_solution)\n    worst_obj = archive[selected_idx][1].index(max(archive[selected_idx][1]))\n\n    for _ in range(3):  # Limited attempts for efficiency\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Segment reversal biased by worst objective\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Node swap biased by worst objective\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with diverse objective values and applies a hybrid local search operator that combines edge-swap and node-insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                insert_pos = random.randint(0, n-2)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.47146708170382734,
            1.7542508125305176
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                insert_pos = random.randint(0, n-2)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{The algorithm selects a solution from the archive based on its potential for improvement by prioritizing those with balanced objective values and applies a novel local search operator that combines 2-opt with a new multi-objective edge-swap heuristic to explore diverse solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            k = random.randint(0, n-1)\n            if k != i and k != j:\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8460414986820652,
            1.4647183179855348
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            k = random.randint(0, n-1)\n            if k != i and k != j:\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{The algorithm prioritizes solutions with high variance in objective values, applies a hybrid local search combining 2-opt and 3-opt moves, and uses a dominance-aware objective function to guide the search for improved multi-objective solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        return sum((x - sum(obj)/3) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4399746222995146,
            2.3302711486816405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        return sum((x - sum(obj)/3) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with extreme objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function, while also incorporating random swaps and reversals to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extreme(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extreme(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4158092825965224,
            1.697742772102356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extreme(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extreme(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{The algorithm selects a solution from the archive based on a novel objective-space coverage metric that prioritizes solutions with extreme or outlier objective values, then applies a multi-objective-aware local search operator that combines a novel \"objective-space guided segment reversal\" with a Pareto-dominance-aware move acceptance criterion to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        normalized = [(x - min(obj)) / (max(obj) - min(obj) + 1e-10) for x in obj]\n        return sum(normalized) / 3\n\n    selected_idx = min(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        obj_weights = [0.5, 0.3, 0.2] if random.random() < 0.5 else [0.2, 0.5, 0.3]\n        segment = new_solution[i:j+1]\n\n        for _ in range(2):\n            if random.random() < 0.4:\n                segment = segment[::-1]\n            else:\n                k = random.randint(0, len(segment)-1)\n                segment = np.concatenate([segment[k:], segment[:k]])\n\n        new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.636730087642692,
            2.435935950279236
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        normalized = [(x - min(obj)) / (max(obj) - min(obj) + 1e-10) for x in obj]\n        return sum(normalized) / 3\n\n    selected_idx = min(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        obj_weights = [0.5, 0.3, 0.2] if random.random() < 0.5 else [0.2, 0.5, 0.3]\n        segment = new_solution[i:j+1]\n\n        for _ in range(2):\n            if random.random() < 0.4:\n                segment = segment[::-1]\n            else:\n                k = random.randint(0, len(segment)-1)\n                segment = np.concatenate([segment[k:], segment[:k]])\n\n        new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with the best trade-off between objective values and applies a hybrid local search operator that combines edge insertion and edge reversal moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the best trade-off between objectives\n    def objective_tradeoff(solution):\n        obj = archive[solution][1]\n        return (obj[0] + obj[1] + obj[2]) / 3 - min(obj)\n\n    selected_idx = min(range(len(archive)), key=lambda i: objective_tradeoff(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and edge reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge reversal move\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Edge insertion move\n        else:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            k = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, k, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6496408468337858,
            1.671486258506775
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the best trade-off between objectives\n    def objective_tradeoff(solution):\n        obj = archive[solution][1]\n        return (obj[0] + obj[1] + obj[2]) / 3 - min(obj)\n\n    selected_idx = min(range(len(archive)), key=lambda i: objective_tradeoff(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and edge reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge reversal move\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Edge insertion move\n        else:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            k = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, k, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with extreme objective values and applies a novel local search operator that combines segment reversal and insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4386278177054111,
            1.717472457885742
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel segment-based local search operator that combines adaptive segment reversal and segment insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        # Randomly select a segment\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n\n        # Adaptive segment reversal with probability based on segment length\n        if random.random() < 0.6:\n            if len(segment) > 1:\n                new_solution[start:end+1] = segment[::-1]\n\n        # Segment insertion at a random position\n        else:\n            insert_pos = random.randint(0, n-1)\n            if insert_pos < start:\n                new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:start], new_solution[end+1:]])\n            elif insert_pos > end:\n                new_solution = np.concatenate([new_solution[:start], new_solution[end+1:insert_pos+1], segment, new_solution[insert_pos+1:]])\n            else:\n                continue\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.39603908305437835,
            1.7719145655632018
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        # Randomly select a segment\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n\n        # Adaptive segment reversal with probability based on segment length\n        if random.random() < 0.6:\n            if len(segment) > 1:\n                new_solution[start:end+1] = segment[::-1]\n\n        # Segment insertion at a random position\n        else:\n            insert_pos = random.randint(0, n-1)\n            if insert_pos < start:\n                new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:start], new_solution[end+1:]])\n            elif insert_pos > end:\n                new_solution = np.concatenate([new_solution[:start], new_solution[end+1:insert_pos+1], segment, new_solution[insert_pos+1:]])\n            else:\n                continue\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{The new algorithm prioritizes solutions with high objective variance and applies a hybrid local search combining 2-opt, 3-opt, and a novel multi-objective edge replacement strategy guided by Pareto-dominance, ensuring diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high objective variance\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return (obj[0] - mean)**2 + (obj[1] - mean)**2 + (obj[2] - mean)**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Hybrid local search: 2-opt, 3-opt, or multi-objective edge replacement\n        if random.random() < 0.5:\n            if random.random() < 0.5:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            # Multi-objective edge replacement\n            a, b = random.sample(range(n), 2)\n            if a > b:\n                a, b = b, a\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            # Evaluate new solution's objectives\n            obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n            obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n            obj3 = sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n\n            # Check Pareto-dominance\n            dominated = False\n            for (_, obj) in archive:\n                if (obj[0] <= obj1 and obj[1] <= obj2 and obj[2] <= obj3 and\n                    (obj[0] < obj1 or obj[1] < obj2 or obj[2] < obj3)):\n                    dominated = True\n                    break\n\n            if not dominated:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.547653945786285,
            2.662384593486786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high objective variance\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return (obj[0] - mean)**2 + (obj[1] - mean)**2 + (obj[2] - mean)**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Hybrid local search: 2-opt, 3-opt, or multi-objective edge replacement\n        if random.random() < 0.5:\n            if random.random() < 0.5:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            # Multi-objective edge replacement\n            a, b = random.sample(range(n), 2)\n            if a > b:\n                a, b = b, a\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            # Evaluate new solution's objectives\n            obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n            obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n            obj3 = sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n\n            # Check Pareto-dominance\n            dominated = False\n            for (_, obj) in archive:\n                if (obj[0] <= obj1 and obj[1] <= obj2 and obj[2] <= obj3 and\n                    (obj[0] < obj1 or obj[1] < obj2 or obj[2] < obj3)):\n                    dominated = True\n                    break\n\n            if not dominated:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{The algorithm selects a solution from the archive by favoring those with diverse objective values and applies a hybrid local search operator that combines 2-opt and insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.42859187238132124,
            1.6834621906280518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution, while also incorporating a novel segment-based perturbation strategy that dynamically adjusts the perturbation scope based on the current solution's objective diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    obj = archive[selected_idx][1]\n    diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n    segment_size = max(3, int(n * (0.1 + 0.4 * (diversity / max(1e-6, sum(obj))))))\n\n    for _ in range(5):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        if random.random() < 0.6:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            mid = random.randint(start, end - 1)\n            new_solution[start:mid] = new_solution[start:mid][::-1]\n            new_solution[mid:end] = new_solution[mid:end][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7406273455545335,
            2.431992506980896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    obj = archive[selected_idx][1]\n    diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n    segment_size = max(3, int(n * (0.1 + 0.4 * (diversity / max(1e-6, sum(obj))))))\n\n    for _ in range(5):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        if random.random() < 0.6:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            mid = random.randint(start, end - 1)\n            new_solution[start:mid] = new_solution[start:mid][::-1]\n            new_solution[mid:end] = new_solution[mid:end][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with high variance in objective values and applies a hybrid local search operator that combines 4-opt and relocate moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement based on objective variance\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean_obj = sum(obj) / 3\n        variance = sum((x - mean_obj) ** 2 for x in obj) / 3\n        return variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and relocate moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j, k, l = sorted(random.sample(range(n), 4))\n\n        # 4-opt move\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        # Relocate move\n        else:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4409854271353947,
            2.019089901447296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement based on objective variance\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean_obj = sum(obj) / 3\n        variance = sum((x - mean_obj) ** 2 for x in obj) / 3\n        return variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and relocate moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j, k, l = sorted(random.sample(range(n), 4))\n\n        # 4-opt move\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        # Relocate move\n        else:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel segment-based local search that combines adaptive segment reversal and insertion operations, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based local search\n    n = len(new_solution)\n    segment_length = max(3, n // 5)  # Adaptive segment length\n\n    for _ in range(5):  # Number of perturbation attempts\n        # Randomly select a segment\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Choose operation: reverse or insert\n        if random.random() < 0.5:\n            # Reverse segment\n            new_solution[start:end] = segment[::-1]\n        else:\n            # Insert segment elsewhere\n            insert_pos = random.randint(0, n - segment_length)\n            if insert_pos != start:\n                # Remove original segment\n                new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n                # Insert at new position\n                new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4541567813686139,
            1.9301195979118346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based local search\n    n = len(new_solution)\n    segment_length = max(3, n // 5)  # Adaptive segment length\n\n    for _ in range(5):  # Number of perturbation attempts\n        # Randomly select a segment\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Choose operation: reverse or insert\n        if random.random() < 0.5:\n            # Reverse segment\n            new_solution[start:end] = segment[::-1]\n        else:\n            # Insert segment elsewhere\n            insert_pos = random.randint(0, n - segment_length)\n            if insert_pos != start:\n                # Remove original segment\n                new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n                # Insert at new position\n                new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with the most diverse objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return -sum(abs(x - y) for x in obj for y in obj if x != y)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8147303468349791,
            1.8199890017509461
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return -sum(abs(x - y) for x in obj for y in obj if x != y)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 4-opt and edge exchange moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            l = random.randint(0, n-1)\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n            new_solution[l], new_solution[(l+1)%n] = new_solution[(l+1)%n], new_solution[l]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4012842649174762,
            1.6699146270751952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            l = random.randint(0, n-1)\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n            new_solution[l], new_solution[(l+1)%n] = new_solution[(l+1)%n], new_solution[l]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a novel local search operator that combines adaptive 2-opt moves with objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Select edges based on objective-aware criteria\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Adaptive 2-opt move with objective-aware edge selection\n        if random.random() < 0.8:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware edge swap\n            k = random.randint(0, n-1)\n            l = (k + random.randint(1, n-1)) % n\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.802885016341083,
            1.66101735830307
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Select edges based on objective-aware criteria\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Adaptive 2-opt move with objective-aware edge selection\n        if random.random() < 0.8:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware edge swap\n            k = random.randint(0, n-1)\n            l = (k + random.randint(1, n-1)) % n\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.42620034333550627,
            1.6042807221412658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{The new algorithm prioritizes solutions with extreme objective values, applies a hybrid local search combining 4-opt and random segment reversal, and uses a dominance-aware objective function to guide the search while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_obj = max(obj)\n        min_obj = min(obj)\n        return max_obj - min_obj\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            random.shuffle(segment)\n            new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4385538149147859,
            1.4412996888160705
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_obj = max(obj)\n        min_obj = min(obj)\n        return max_obj - min_obj\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            random.shuffle(segment)\n            new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high Pareto-frontier proximity and applies a novel segment-swap-and-reverse operator that dynamically balances local and global improvements across the three objectives by adaptively adjusting the segment size based on the current objective trade-offs, ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high Pareto-frontier proximity\n    def pareto_proximity(solution):\n        obj = archive[solution][1]\n        return (obj[0] + obj[1] + obj[2]) / 3  # Simple average for proximity\n\n    selected_idx = min(range(len(archive)), key=lambda i: pareto_proximity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel segment-swap-and-reverse operator\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))  # Dynamic segment size based on problem size\n\n    for _ in range(3):  # Limited perturbation attempts\n        a = random.randint(0, n - segment_size)\n        b = random.randint(0, n - segment_size)\n\n        # Swap segments and reverse one of them\n        if random.random() < 0.5:\n            segment_a = new_solution[a:a+segment_size]\n            segment_b = new_solution[b:b+segment_size]\n            new_solution[a:a+segment_size] = segment_b[::-1]\n            new_solution[b:b+segment_size] = segment_a[::-1]\n        else:\n            segment = new_solution[a:a+segment_size]\n            new_solution[a:a+segment_size] = segment[::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.618294279133919,
            1.698935294151306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high Pareto-frontier proximity\n    def pareto_proximity(solution):\n        obj = archive[solution][1]\n        return (obj[0] + obj[1] + obj[2]) / 3  # Simple average for proximity\n\n    selected_idx = min(range(len(archive)), key=lambda i: pareto_proximity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel segment-swap-and-reverse operator\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))  # Dynamic segment size based on problem size\n\n    for _ in range(3):  # Limited perturbation attempts\n        a = random.randint(0, n - segment_size)\n        b = random.randint(0, n - segment_size)\n\n        # Swap segments and reverse one of them\n        if random.random() < 0.5:\n            segment_a = new_solution[a:a+segment_size]\n            segment_b = new_solution[b:b+segment_size]\n            new_solution[a:a+segment_size] = segment_b[::-1]\n            new_solution[b:b+segment_size] = segment_a[::-1]\n        else:\n            segment = new_solution[a:a+segment_size]\n            new_solution[a:a+segment_size] = segment[::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objective values and applies a hybrid local search operator that combines segment reversal and insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.42362837877216447,
            1.6823920011520386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This algorithm selects a solution from the archive based on the diversity of its objectives, applies a hybrid local search operator that combines 2-opt and 4-opt moves, and uses a Pareto-dominance-aware objective function to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        max_obj = max(obj)\n        min_obj = min(obj)\n        return max_obj - min_obj\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n        l = random.randint(k, j) if j - k >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            new_solution[l:j+1] = new_solution[l:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4080308399540559,
            1.6731731653213502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        max_obj = max(obj)\n        min_obj = min(obj)\n        return max_obj - min_obj\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n        l = random.randint(k, j) if j - k >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            new_solution[l:j+1] = new_solution[l:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objectives and applies a novel multi-objective local search operator that combines node insertion, swap, and inversion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        move_type = random.random()\n\n        if move_type < 0.3:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif move_type < 0.6:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(i, j)\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7213303868469328,
            1.793994963169098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        move_type = random.random()\n\n        if move_type < 0.3:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif move_type < 0.6:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(i, j)\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for multi-objective improvement by prioritizing those with balanced objectives and applies a novel segment-based local search that combines adaptive segment reversal and segment insertion, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return min(obj) / (max(obj) + 1e-10)  # Avoid division by zero\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based local search\n    n = len(new_solution)\n    for _ in range(5):\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Adaptive segment reversal or insertion\n        if random.random() < 0.6:\n            # Segment reversal\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            # Segment insertion\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7641997518254061,
            1.5440909743309021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return min(obj) / (max(obj) + 1e-10)  # Avoid division by zero\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based local search\n    n = len(new_solution)\n    for _ in range(5):\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Adaptive segment reversal or insertion\n        if random.random() < 0.6:\n            # Segment reversal\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            # Segment insertion\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8103935412373587,
            1.7764912605285645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{The new algorithm selects a solution from the archive based on the sum of its objective values, applies a hybrid local search operator that combines 2-opt and 3-opt moves, and uses Pareto-dominance awareness to guide the search for improved solutions across multiple objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_sum(solution):\n        return sum(archive[solution][1])\n\n    selected_idx = min(range(len(archive)), key=lambda i: objective_sum(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6060456757294035,
            1.5437419772148133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_sum(solution):\n        return sum(archive[solution][1])\n\n    selected_idx = min(range(len(archive)), key=lambda i: objective_sum(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8129159174389994,
            1.881309151649475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with high objective diversity and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function, while dynamically adjusting the perturbation intensity based on the solution's current objective values to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement based on objective diversity and current objective values\n    def objective_score(solution):\n        obj = archive[solution][1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        intensity = (obj[0] + obj[1] + obj[2]) / 3  # Higher intensity for worse solutions\n        return diversity * intensity\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with dynamic perturbation intensity\n    n = len(new_solution)\n    current_obj = archive[selected_idx][1]\n    perturbation_intensity = min(10, max(1, int((current_obj[0] + current_obj[1] + current_obj[2]) / 3 / 1000)))\n\n    for _ in range(perturbation_intensity):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            # 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt move\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.39468150692385207,
            1.942214846611023
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement based on objective diversity and current objective values\n    def objective_score(solution):\n        obj = archive[solution][1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        intensity = (obj[0] + obj[1] + obj[2]) / 3  # Higher intensity for worse solutions\n        return diversity * intensity\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with dynamic perturbation intensity\n    n = len(new_solution)\n    current_obj = archive[selected_idx][1]\n    perturbation_intensity = min(10, max(1, int((current_obj[0] + current_obj[1] + current_obj[2]) / 3 / 1000)))\n\n    for _ in range(perturbation_intensity):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            # 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt move\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with extreme objective values and applies a novel local search operator that combines segment reversal with node swapping, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            if j - i >= 3:\n                segment = new_solution[i:j+1]\n                random.shuffle(segment)\n                new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.46709123798669666,
            1.6673691153526307
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            if j - i >= 3:\n                segment = new_solution[i:j+1]\n                random.shuffle(segment)\n                new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with the most balanced objective values and applies a novel multi-objective local search operator that combines segment reversal and insertion moves, guided by a Pareto-dominance-aware objective function, while ensuring feasibility through a node-swapping mechanism to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]])\n            insert_pos = random.randint(0, n-1)\n            node_to_insert = new_solution[insert_pos]\n            new_solution = np.concatenate([new_solution[:insert_pos], new_solution[insert_pos+1:]])\n            new_solution = np.insert(new_solution, k, node_to_insert)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8300573926675787,
            1.763444757461548
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]])\n            insert_pos = random.randint(0, n-1)\n            node_to_insert = new_solution[insert_pos]\n            new_solution = np.concatenate([new_solution[:insert_pos], new_solution[insert_pos+1:]])\n            new_solution = np.insert(new_solution, k, node_to_insert)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by prioritizing those with extreme objective values (either very high or very low) and applies a novel \"multi-objective inversion\" local search operator that inverts segments of the tour while considering the trade-off between all three objectives, ensuring feasibility through careful segment selection and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        if random.random() < 0.5:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            new_solution[start:end] = new_solution[start:end][::-1]\n            new_solution[end:] = new_solution[end:][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.38452106296138633,
            1.5597543239593505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        if random.random() < 0.5:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            new_solution[start:end] = new_solution[start:end][::-1]\n            new_solution[end:] = new_solution[end:][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{The algorithm selects a solution from the archive based on a novel scoring function that prioritizes solutions with diverse objective values and applies a hybrid local search operator that combines edge swaps and node insertions, guided by a dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        min_val = min(obj)\n        max_val = max(obj)\n        return (max_val - min_val) / (sum(obj) + 1e-10)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4677527626705902,
            1.8938119053840636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        min_val = min(obj)\n        max_val = max(obj)\n        return (max_val - min_val) / (sum(obj) + 1e-10)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high diversity in objective values, then applies a hybrid local search operator that combines segment reversal and node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4158496084115887,
            1.69731764793396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with extreme objective values and applies a novel local search operator that combines 2-opt with a multi-objective edge-swap strategy to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            swap_edges = random.sample(range(n), 2)\n            a, b = swap_edges\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4570081577991755,
            1.55030015707016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            swap_edges = random.sample(range(n), 2)\n            a, b = swap_edges\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a novel segment-based local search operator that combines adaptive segment reversal and segment insertion moves, guided by a multi-objective improvement metric to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objective values\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based local search\n    n = len(new_solution)\n    for _ in range(5):\n        # Randomly select segments\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Adaptive segment reversal\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Segment insertion\n        else:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8427614127703403,
            1.8613375425338745
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objective values\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based local search\n    n = len(new_solution)\n    for _ in range(5):\n        # Randomly select segments\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Adaptive segment reversal\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Segment insertion\n        else:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a novel multi-objective local search operator that combines segment reversal with objective-aware edge swaps, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            obj1 = distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[(k+1)%n]]\n            obj2 = distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[(k+1)%n]]\n            obj3 = distance_matrix_3[new_solution[i-1], new_solution[k]] + distance_matrix_3[new_solution[j], new_solution[(k+1)%n]]\n\n            if obj1 < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] or \\\n               obj2 < distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] or \\\n               obj3 < distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8844763036331653,
            2.3665319800376894
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            obj1 = distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[(k+1)%n]]\n            obj2 = distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[(k+1)%n]]\n            obj3 = distance_matrix_3[new_solution[i-1], new_solution[k]] + distance_matrix_3[new_solution[j], new_solution[(k+1)%n]]\n\n            if obj1 < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] or \\\n               obj2 < distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] or \\\n               obj3 < distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective improvements and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function, while ensuring feasibility by validating each move.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objective improvements\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = sum(obj) / 3\n        return -sum(abs(o - mean_obj) for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with feasibility checks\n    n = len(new_solution)\n    for _ in range(3):  # Fewer perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move with probability 0.6\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Validate feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9538748484311561,
            1.633672571182251
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objective improvements\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = sum(obj) / 3\n        return -sum(abs(o - mean_obj) for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with feasibility checks\n    n = len(new_solution)\n    for _ in range(3):  # Fewer perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move with probability 0.6\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Validate feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{The algorithm selects a solution from the archive based on the worst-performing objective to target improvement, then applies a hybrid local search combining edge insertion and segment reversal moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with the worst objective to target improvement\n    def worst_objective(solution):\n        obj = archive[solution][1]\n        return max(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: worst_objective(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and segment reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion move\n        if random.random() < 0.5:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n        # Segment reversal move\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.3462999322579031,
            1.5274043679237366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with the worst objective to target improvement\n    def worst_objective(solution):\n        obj = archive[solution][1]\n        return max(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: worst_objective(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and segment reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion move\n        if random.random() < 0.5:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n        # Segment reversal move\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{The algorithm selects a solution from the archive based on its diversity in objective values, then applies a novel segment-based local search operator that combines adaptive segment reversal with objective-aware segment insertion, guided by a Pareto-dominance-aware objective function to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(obj):\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    if random.random() < 0.7:\n        new_solution[start:start+segment_length] = segment[::-1]\n    else:\n        insert_pos = random.randint(0, n - segment_length)\n        if insert_pos >= start:\n            insert_pos += segment_length\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.3973451181297524,
            1.6511438727378844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(obj):\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    if random.random() < 0.7:\n        new_solution[start:start+segment_length] = segment[::-1]\n    else:\n        insert_pos = random.randint(0, n - segment_length)\n        if insert_pos >= start:\n            insert_pos += segment_length\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel multi-objective local search operator that combines segment reversal and node insertion, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            j = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, j, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.41987425629087155,
            1.8106318593025208
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            j = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, j, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by an objective-balance-aware function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = (obj[0] + obj[1] + obj[2]) / 3\n        return 1 / (1 + (abs(obj[0] - mean_obj) + abs(obj[1] - mean_obj) + abs(obj[2] - mean_obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9114915804434759,
            1.629270613193512
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = (obj[0] + obj[1] + obj[2]) / 3\n        return 1 / (1 + (abs(obj[0] - mean_obj) + abs(obj[1] - mean_obj) + abs(obj[2] - mean_obj)))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced and diverse objectives, then applies a hybrid local search operator that combines 4-opt and edge insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_score(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        balance = -sum((x - mean) ** 2 for x in obj)\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        return balance + diversity\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.694551540931577,
            1.8357913732528686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_score(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        balance = -sum((x - mean) ** 2 for x in obj)\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        return balance + diversity\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with high variance in objectives, then applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function, while ensuring feasibility through a novel feasibility check.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((o - mean) ** 2 for o in obj) / 3\n        return variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with feasibility check\n    n = len(new_solution)\n    for _ in range(5):\n        a, b, c = sorted(random.sample(range(n), 3))\n        d = random.randint(a, b) if b - a >= 2 else b\n\n        # 2-opt move with feasibility check\n        if random.random() < 0.6:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        # 3-opt move with feasibility check\n        else:\n            new_solution[a:d+1] = new_solution[a:d+1][::-1]\n            new_solution[d:b+1] = new_solution[d:b+1][::-1]\n\n        # Novel feasibility check\n        if len(np.unique(new_solution)) == n and all(new_solution[i] != new_solution[(i+1) % n] for i in range(n)):\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.46045286550480996,
            2.294596791267395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((o - mean) ** 2 for o in obj) / 3\n        return variance\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with feasibility check\n    n = len(new_solution)\n    for _ in range(5):\n        a, b, c = sorted(random.sample(range(n), 3))\n        d = random.randint(a, b) if b - a >= 2 else b\n\n        # 2-opt move with feasibility check\n        if random.random() < 0.6:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        # 3-opt move with feasibility check\n        else:\n            new_solution[a:d+1] = new_solution[a:d+1][::-1]\n            new_solution[d:b+1] = new_solution[d:b+1][::-1]\n\n        # Novel feasibility check\n        if len(np.unique(new_solution)) == n and all(new_solution[i] != new_solution[(i+1) % n] for i in range(n)):\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This algorithm selects a solution from the archive based on the balance between objective values and applies a novel 4-opt local search operator with Pareto-dominance-aware edge selection to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = (obj[0] + obj[1] + obj[2]) / 3\n        return -sum((o - mean_obj) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # 4-opt local search with Pareto-aware edge selection\n    n = len(new_solution)\n    for _ in range(5):\n        # Select 4 distinct edges\n        edges = sorted(random.sample(range(n), 4))\n        a, b, c, d = edges\n\n        # Apply 4-opt move\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a:d+1] = new_solution[a:d+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8321941986177188,
            1.6872033715248107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = (obj[0] + obj[1] + obj[2]) / 3\n        return -sum((o - mean_obj) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # 4-opt local search with Pareto-aware edge selection\n    n = len(new_solution)\n    for _ in range(5):\n        # Select 4 distinct edges\n        edges = sorted(random.sample(range(n), 4))\n        a, b, c, d = edges\n\n        # Apply 4-opt move\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a:d+1] = new_solution[a:d+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{The algorithm selects a solution from the archive based on a novel dominance-aware selection criterion that balances objective diversity and solution quality, then applies a hybrid local search combining edge exchange and segment relocation moves guided by Pareto front proximity to generate an improved neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Selection criterion: balance between objective diversity and solution quality\n    def selection_score(solution):\n        obj = solution[1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        quality = -(obj[0] + obj[1] + obj[2])  # Negative because we want to minimize\n        return diversity * 0.4 + quality * 0.6\n\n    selected_idx = max(range(len(archive)), key=lambda i: selection_score(archive[i]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange and segment relocation\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge exchange move\n        if random.random() < 0.6:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Segment relocation move\n        else:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4726297645439505,
            1.739362633228302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Selection criterion: balance between objective diversity and solution quality\n    def selection_score(solution):\n        obj = solution[1]\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        quality = -(obj[0] + obj[1] + obj[2])  # Negative because we want to minimize\n        return diversity * 0.4 + quality * 0.6\n\n    selected_idx = max(range(len(archive)), key=lambda i: selection_score(archive[i]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange and segment relocation\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge exchange move\n        if random.random() < 0.6:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Segment relocation move\n        else:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{The new algorithm prioritizes solutions with high variance in objective values to target under-explored regions of the Pareto front, applying a hybrid local search combining 4-opt and insertion moves guided by a dominance-aware objective function to generate diverse neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.6:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n        else:\n            segment = new_solution[b:c+1]\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b], new_solution[c+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4586719809737197,
            1.6399422645568849
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.6:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n        else:\n            segment = new_solution[b:c+1]\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b], new_solution[c+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a novel multi-objective local search operator that combines 2-opt with a custom 3-opt variant, guided by a Pareto-dominance-aware objective function and a novel objective-space weighted distance metric to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    def weighted_distance(solution):\n        obj = archive[solution][1]\n        weights = np.array([1.0, 1.0, 1.0])\n        if len(obj) == 3:\n            weights[np.argmax(obj)] *= 1.5\n        return np.dot(weights, obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i) - 0.3 * weighted_distance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            temp = new_solution[i:j+1]\n            temp = np.concatenate((temp[k-i:], temp[:k-i]))\n            new_solution[i:j+1] = temp\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.745656500552763,
            4.021401417255402
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    def weighted_distance(solution):\n        obj = archive[solution][1]\n        weights = np.array([1.0, 1.0, 1.0])\n        if len(obj) == 3:\n            weights[np.argmax(obj)] *= 1.5\n        return np.dot(weights, obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i) - 0.3 * weighted_distance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            temp = new_solution[i:j+1]\n            temp = np.concatenate((temp[k-i:], temp[:k-i]))\n            new_solution[i:j+1] = temp\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with balanced objectives and applies a hybrid local search operator that combines 4-opt and swap moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return - (abs(obj[0] - mean) + abs(obj[1] - mean) + abs(obj[2] - mean))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and swap moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j, k, l = sorted(random.sample(range(n), 4))\n\n        # 4-opt move\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        # Swap move\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8370112869676765,
            1.5433568239212037
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return - (abs(obj[0] - mean) + abs(obj[1] - mean) + abs(obj[2] - mean))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and swap moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j, k, l = sorted(random.sample(range(n), 4))\n\n        # 4-opt move\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        # Swap move\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objective values, applies a hybrid local search combining 2-opt, 3-opt, and a novel edge-swap operator, and ensures feasibility by validating node uniqueness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution based on weighted sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Weight for each objective\n    scores = np.dot(norm_objectives, weights)\n    selected_idx = np.argmin(scores)  # Select solution with lowest score (potential for improvement)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt, 3-opt, and edge-swap\n    n = len(new_solution)\n    for _ in range(10):  # Increased perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.random()\n        if move_type < 0.4:  # 2-opt\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.7:  # 3-opt\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:  # Edge-swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6752485497368991,
            1.7588325142860413
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution based on weighted sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Weight for each objective\n    scores = np.dot(norm_objectives, weights)\n    selected_idx = np.argmin(scores)  # Select solution with lowest score (potential for improvement)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt, 3-opt, and edge-swap\n    n = len(new_solution)\n    for _ in range(10):  # Increased perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.random()\n        if move_type < 0.4:  # 2-opt\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.7:  # 3-opt\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:  # Edge-swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high objective diversity and applies a novel segment-swap and inversion-based local search operator that dynamically balances improvements across all three objectives, guided by a weighted Pareto-dominance criterion to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Segment swap with inversion\n        if random.random() < 0.5:\n            segment = new_solution[i:j+1]\n            if random.random() < 0.5:\n                segment = segment[::-1]\n            new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n        # Dynamic segment inversion\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            if k < j:\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4312997746491938,
            2.169784665107727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # Segment swap with inversion\n        if random.random() < 0.5:\n            segment = new_solution[i:j+1]\n            if random.random() < 0.5:\n                segment = segment[::-1]\n            new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n        # Dynamic segment inversion\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            if k < j:\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{The algorithm selects a solution from the archive based on its diversity in objectives and applies a novel multi-objective local search operator that combines path relinking with a dynamic neighborhood exploration strategy, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: path relinking with dynamic neighborhood\n    n = len(new_solution)\n    for _ in range(3):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Dynamic neighborhood exploration\n        if random.random() < 0.5:\n            # Path relinking: blend with another solution\n            other_idx = random.choice([k for k in range(len(archive)) if k != selected_idx])\n            other_solution = archive[other_idx][0]\n            for k in range(i, j+1):\n                if random.random() < 0.3:\n                    new_solution[k] = other_solution[k]\n        else:\n            # Dynamic segment reversal\n            if random.random() < 0.5:\n                segment = segment[::-1]\n            else:\n                segment = np.roll(segment, random.randint(1, len(segment)-1))\n\n        new_solution[i:j+1] = segment\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.41980338785304927,
            1.5900721430778504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search: path relinking with dynamic neighborhood\n    n = len(new_solution)\n    for _ in range(3):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Dynamic neighborhood exploration\n        if random.random() < 0.5:\n            # Path relinking: blend with another solution\n            other_idx = random.choice([k for k in range(len(archive)) if k != selected_idx])\n            other_solution = archive[other_idx][0]\n            for k in range(i, j+1):\n                if random.random() < 0.3:\n                    new_solution[k] = other_solution[k]\n        else:\n            # Dynamic segment reversal\n            if random.random() < 0.5:\n                segment = segment[::-1]\n            else:\n                segment = np.roll(segment, random.randint(1, len(segment)-1))\n\n        new_solution[i:j+1] = segment\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement based on the average of the objectives' ranks across all solutions, then applies a novel multi-objective local search operator that combines a probabilistic segment reversal with a Pareto-dominance-aware swap move to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Rank solutions based on each objective\n    objectives = [obj for _, obj in archive]\n    ranks = []\n    for i in range(3):\n        sorted_idx = sorted(range(len(objectives)), key=lambda x: objectives[x][i])\n        rank = [0] * len(objectives)\n        for j, idx in enumerate(sorted_idx):\n            rank[idx] = j\n        ranks.append(rank)\n\n    # Select solution with highest average rank (potential for improvement)\n    avg_ranks = [sum(r[i] for r in ranks) / 3 for i in range(len(archive))]\n    selected_idx = min(range(len(archive)), key=lambda i: avg_ranks[i])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Probabilistic segment reversal\n        if random.random() < 0.4:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Pareto-dominance-aware swap\n            a, b = random.sample(range(n), 2)\n            temp = new_solution[a]\n            new_solution[a] = new_solution[b]\n            new_solution[b] = temp\n\n            # Check for improvement in any objective\n            old_costs = [sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n)),\n                         sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n)),\n                         sum(distance_matrix_3[base_solution[i-1], base_solution[i]] for i in range(n))]\n            new_costs = [sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n                         sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n                         sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))]\n\n            if not all(nc >= oc for nc, oc in zip(new_costs, old_costs)):\n                new_solution[b] = new_solution[a]\n                new_solution[a] = temp\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.5492369424818951,
            3.039278256893158
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Rank solutions based on each objective\n    objectives = [obj for _, obj in archive]\n    ranks = []\n    for i in range(3):\n        sorted_idx = sorted(range(len(objectives)), key=lambda x: objectives[x][i])\n        rank = [0] * len(objectives)\n        for j, idx in enumerate(sorted_idx):\n            rank[idx] = j\n        ranks.append(rank)\n\n    # Select solution with highest average rank (potential for improvement)\n    avg_ranks = [sum(r[i] for r in ranks) / 3 for i in range(len(archive))]\n    selected_idx = min(range(len(archive)), key=lambda i: avg_ranks[i])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Probabilistic segment reversal\n        if random.random() < 0.4:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Pareto-dominance-aware swap\n            a, b = random.sample(range(n), 2)\n            temp = new_solution[a]\n            new_solution[a] = new_solution[b]\n            new_solution[b] = temp\n\n            # Check for improvement in any objective\n            old_costs = [sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n)),\n                         sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n)),\n                         sum(distance_matrix_3[base_solution[i-1], base_solution[i]] for i in range(n))]\n            new_costs = [sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n                         sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)),\n                         sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))]\n\n            if not all(nc >= oc for nc, oc in zip(new_costs, old_costs)):\n                new_solution[b] = new_solution[a]\n                new_solution[a] = temp\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with extreme objective values (either very high or very low in any objective) and applies a novel \"Objective-Space Guided Reinsertion\" operator that selectively reinserts segments of the tour into different positions based on their contribution to each objective, ensuring feasibility and potentially improving multiple objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with extreme objective values\n    def extreme_objective(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: extreme_objective(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Objective-Space Guided Reinsertion\n    n = len(new_solution)\n    for _ in range(3):  # Number of reinsertion attempts\n        # Randomly select a segment of the tour\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1].copy()\n\n        # Remove the segment from the tour\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n        # Calculate the contribution of the segment to each objective\n        def segment_contribution(segment, distance_matrix):\n            total = 0\n            for a, b in zip(segment[:-1], segment[1:]):\n                total += distance_matrix[a, b]\n            return total\n\n        contrib1 = segment_contribution(segment, distance_matrix_1)\n        contrib2 = segment_contribution(segment, distance_matrix_2)\n        contrib3 = segment_contribution(segment, distance_matrix_3)\n\n        # Determine the objective with the highest contribution\n        max_contrib = max(contrib1, contrib2, contrib3)\n\n        # Reinsert the segment at a position that could improve the objective with highest contribution\n        if contrib1 == max_contrib:\n            # Find position that minimizes distance_matrix_1\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(len(new_solution)):\n                cost = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n        elif contrib2 == max_contrib:\n            # Find position that minimizes distance_matrix_2\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(len(new_solution)):\n                cost = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n        else:\n            # Find position that minimizes distance_matrix_3\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(len(new_solution)):\n                cost = distance_matrix_3[new_solution[pos-1], segment[0]] + distance_matrix_3[segment[-1], new_solution[pos]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n\n        # Reinsert the segment at the best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6221985183610366,
            1.7731253504753113
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with extreme objective values\n    def extreme_objective(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: extreme_objective(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Objective-Space Guided Reinsertion\n    n = len(new_solution)\n    for _ in range(3):  # Number of reinsertion attempts\n        # Randomly select a segment of the tour\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1].copy()\n\n        # Remove the segment from the tour\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n        # Calculate the contribution of the segment to each objective\n        def segment_contribution(segment, distance_matrix):\n            total = 0\n            for a, b in zip(segment[:-1], segment[1:]):\n                total += distance_matrix[a, b]\n            return total\n\n        contrib1 = segment_contribution(segment, distance_matrix_1)\n        contrib2 = segment_contribution(segment, distance_matrix_2)\n        contrib3 = segment_contribution(segment, distance_matrix_3)\n\n        # Determine the objective with the highest contribution\n        max_contrib = max(contrib1, contrib2, contrib3)\n\n        # Reinsert the segment at a position that could improve the objective with highest contribution\n        if contrib1 == max_contrib:\n            # Find position that minimizes distance_matrix_1\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(len(new_solution)):\n                cost = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n        elif contrib2 == max_contrib:\n            # Find position that minimizes distance_matrix_2\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(len(new_solution)):\n                cost = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n        else:\n            # Find position that minimizes distance_matrix_3\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(len(new_solution)):\n                cost = distance_matrix_3[new_solution[pos-1], segment[0]] + distance_matrix_3[segment[-1], new_solution[pos]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n\n        # Reinsert the segment at the best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a novel segment-based crossover operator that combines segments from two solutions, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = base_solution[i:j+1]\n\n        if random.random() < 0.5:\n            other_idx = random.choice([k for k in range(len(archive)) if k != selected_idx])\n            other_solution = archive[other_idx][0]\n            start = random.randint(0, len(other_solution) - len(segment))\n            new_segment = other_solution[start:start+len(segment)]\n        else:\n            new_segment = segment[::-1]\n\n        new_solution[i:j+1] = new_segment\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8617674758527807,
            1.4649862408638001
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = base_solution[i:j+1]\n\n        if random.random() < 0.5:\n            other_idx = random.choice([k for k in range(len(archive)) if k != selected_idx])\n            other_solution = archive[other_idx][0]\n            start = random.randint(0, len(other_solution) - len(segment))\n            new_segment = other_solution[start:start+len(segment)]\n        else:\n            new_segment = segment[::-1]\n\n        new_solution[i:j+1] = new_segment\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines edge insertion and path reversal moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            temp = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, temp)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8249941556417655,
            2.182937729358673
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            temp = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, temp)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel multi-objective crossover operator that combines segments of two solutions while ensuring feasibility through a repair mechanism guided by Pareto-dominance awareness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Select another solution for crossover\n    other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n    other_solution = archive[other_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = np.zeros(n, dtype=int)\n\n    # Multi-objective crossover\n    crossover_point = random.randint(1, n-2)\n    new_solution[:crossover_point] = base_solution[:crossover_point]\n\n    # Fill remaining positions with nodes from other_solution not already in new_solution\n    remaining_nodes = [node for node in other_solution if node not in new_solution[:crossover_point]]\n    new_solution[crossover_point:] = remaining_nodes\n\n    # Repair to ensure feasibility\n    missing_nodes = [node for node in base_solution if node not in new_solution]\n    for i in range(crossover_point, n):\n        if new_solution[i] in new_solution[:i]:\n            new_solution[i] = missing_nodes.pop(0)\n\n    # Apply Pareto-aware local improvement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        # Accept if improvement in at least one objective\n        original_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        ]\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n            sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n            sum(distance_matrix_3[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6203088001279791,
            2.99248126745224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Select another solution for crossover\n    other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n    other_solution = archive[other_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = np.zeros(n, dtype=int)\n\n    # Multi-objective crossover\n    crossover_point = random.randint(1, n-2)\n    new_solution[:crossover_point] = base_solution[:crossover_point]\n\n    # Fill remaining positions with nodes from other_solution not already in new_solution\n    remaining_nodes = [node for node in other_solution if node not in new_solution[:crossover_point]]\n    new_solution[crossover_point:] = remaining_nodes\n\n    # Repair to ensure feasibility\n    missing_nodes = [node for node in base_solution if node not in new_solution]\n    for i in range(crossover_point, n):\n        if new_solution[i] in new_solution[:i]:\n            new_solution[i] = missing_nodes.pop(0)\n\n    # Apply Pareto-aware local improvement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        # Accept if improvement in at least one objective\n        original_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        ]\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n            sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n            sum(distance_matrix_3[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n        ]\n\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{The algorithm selects a solution from the archive with the highest diversity in objective values and applies a hybrid local search operator that combines edge insertion and node relocation, guided by a crowding-distance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def crowding_distance(obj):\n        sorted_obj = sorted(obj)\n        distances = [0.0] * len(obj)\n        for i in range(len(obj)):\n            if i == 0 or i == len(obj) - 1:\n                distances[i] = float('inf')\n            else:\n                distances[i] = sorted_obj[i+1] - sorted_obj[i-1]\n        return sum(distances)\n\n    selected_idx = max(range(len(archive)), key=lambda i: crowding_distance(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n        else:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7695590029153312,
            1.3828768849372863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def crowding_distance(obj):\n        sorted_obj = sorted(obj)\n        distances = [0.0] * len(obj)\n        for i in range(len(obj)):\n            if i == 0 or i == len(obj) - 1:\n                distances[i] = float('inf')\n            else:\n                distances[i] = sorted_obj[i+1] - sorted_obj[i-1]\n        return sum(distances)\n\n    selected_idx = max(range(len(archive)), key=lambda i: crowding_distance(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n        else:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8967032626498466,
            1.7293689131736756
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return -sum(abs(x - y) for x in obj for y in obj if x != y)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8304073025138013,
            1.8400414705276489
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return -sum(abs(x - y) for x in obj for y in obj if x != y)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objective values\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return min(obj) / max(obj) if max(obj) != 0 else 1.0\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8833482107897053,
            1.5810656547546387
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objective values\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return min(obj) / max(obj) if max(obj) != 0 else 1.0\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the highest diversity in objective values, then applies a hybrid local search operator that combines edge swaps and node insertions, guided by a crowding-distance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution[i:j] = np.roll(new_solution[i:j], 1)\n            new_solution[j:k] = np.roll(new_solution[j:k], -1)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4153648252234225,
            1.5570674180984496
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution[i:j] = np.roll(new_solution[i:j], 1)\n            new_solution[j:k] = np.roll(new_solution[j:k], -1)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with low variance in objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = min(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7849427983439373,
            1.2162477850914002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = min(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{The algorithm selects a solution from the archive with the highest combined objective value across all three spaces, then applies a novel segment reordering and inversion strategy that dynamically adjusts segment lengths based on the relative magnitudes of the objectives, ensuring feasibility while promoting balanced optimization across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective weights\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total = obj1 + obj2 + obj3\n    w1, w2, w3 = obj1/total, obj2/total, obj3/total\n\n    n = len(new_solution)\n    for _ in range(3):  # Number of perturbation attempts\n        # Determine segment length based on objective weights\n        seg_len = max(2, int(round((w1 * 2 + w2 * 3 + w3 * 4) * (n/10))))\n\n        # Randomly select segment\n        start = random.randint(0, n - seg_len)\n        end = start + seg_len\n\n        # Apply weighted operation\n        if random.random() < w1:\n            # Simple inversion\n            new_solution[start:end] = new_solution[start:end][::-1]\n        elif random.random() < w2:\n            # Cyclic shift\n            shift = random.randint(1, seg_len-1)\n            new_solution[start:end] = np.concatenate([new_solution[start+shift:end], new_solution[start:start+shift]])\n        else:\n            # Objective-aware reordering\n            segment = new_solution[start:end]\n            distances = np.array([\n                np.sum(distance_matrix_1[segment[:-1], segment[1:]]),\n                np.sum(distance_matrix_2[segment[:-1], segment[1:]]),\n                np.sum(distance_matrix_3[segment[:-1], segment[1:]])\n            ])\n            if np.argmax(distances) == 0:\n                segment = np.sort(segment)\n            else:\n                segment = segment[::-1]\n            new_solution[start:end] = segment\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7269448901624181,
            1.4679762482643128
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective weights\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total = obj1 + obj2 + obj3\n    w1, w2, w3 = obj1/total, obj2/total, obj3/total\n\n    n = len(new_solution)\n    for _ in range(3):  # Number of perturbation attempts\n        # Determine segment length based on objective weights\n        seg_len = max(2, int(round((w1 * 2 + w2 * 3 + w3 * 4) * (n/10))))\n\n        # Randomly select segment\n        start = random.randint(0, n - seg_len)\n        end = start + seg_len\n\n        # Apply weighted operation\n        if random.random() < w1:\n            # Simple inversion\n            new_solution[start:end] = new_solution[start:end][::-1]\n        elif random.random() < w2:\n            # Cyclic shift\n            shift = random.randint(1, seg_len-1)\n            new_solution[start:end] = np.concatenate([new_solution[start+shift:end], new_solution[start:start+shift]])\n        else:\n            # Objective-aware reordering\n            segment = new_solution[start:end]\n            distances = np.array([\n                np.sum(distance_matrix_1[segment[:-1], segment[1:]]),\n                np.sum(distance_matrix_2[segment[:-1], segment[1:]]),\n                np.sum(distance_matrix_3[segment[:-1], segment[1:]])\n            ])\n            if np.argmax(distances) == 0:\n                segment = np.sort(segment)\n            else:\n                segment = segment[::-1]\n            new_solution[start:end] = segment\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with high objective variance and applies a hybrid local search operator combining 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function, while ensuring feasibility and considering the three objectives' trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return ((obj[0] - mean)**2 + (obj[1] - mean)**2 + (obj[2] - mean)**2) / 3\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.43598477015061327,
            1.776988959312439
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return ((obj[0] - mean)**2 + (obj[1] - mean)**2 + (obj[2] - mean)**2) / 3\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced and diverse objectives, then applies a novel multi-objective local search operator that combines segment reversal and insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_metric(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        return (diversity * 0.3) - (sum((x - mean) ** 2 for x in obj) * 0.7)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_metric(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            new_solution = np.delete(new_solution, slice(i, j+1))\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.883246553872719,
            2.0177739024162293
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_metric(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        return (diversity * 0.3) - (sum((x - mean) ** 2 for x in obj) * 0.7)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_metric(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            new_solution = np.delete(new_solution, slice(i, j+1))\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a novel segment-based local search operator that combines random segment reversal and segment rotation, guided by a multi-objective improvement heuristic to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return - (abs(obj[0] - mean) + abs(obj[1] - mean) + abs(obj[2] - mean))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based local search\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Random segment reversal\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Segment rotation\n        else:\n            segment = new_solution[i:j+1]\n            shift = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n            new_solution[i:j+1] = np.concatenate([segment[shift:], segment[:shift]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7902865700580401,
            1.4823367238044738
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = (obj[0] + obj[1] + obj[2]) / 3\n        return - (abs(obj[0] - mean) + abs(obj[1] - mean) + abs(obj[2] - mean))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based local search\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Random segment reversal\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Segment rotation\n        else:\n            segment = new_solution[i:j+1]\n            shift = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n            new_solution[i:j+1] = np.concatenate([segment[shift:], segment[:shift]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{The algorithm selects a solution from the archive with the highest combined objective value (sum of all three objectives) and applies a novel \"multi-objective inversion\" local search operator that inverts segments of the tour while considering the trade-offs between objectives, ensuring feasibility and potentially improving all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        # Randomly select two points and invert the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            # Calculate the new objectives\n            obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n            # If the new solution is better in at least one objective, keep it\n            if obj1 < archive[selected_idx][1][0] or obj2 < archive[selected_idx][1][1] or obj3 < archive[selected_idx][1][2]:\n                break\n            else:\n                new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5888367198407598,
            1.4506008863449096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        # Randomly select two points and invert the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            # Calculate the new objectives\n            obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n            # If the new solution is better in at least one objective, keep it\n            if obj1 < archive[selected_idx][1][0] or obj2 < archive[selected_idx][1][1] or obj3 < archive[selected_idx][1][2]:\n                break\n            else:\n                new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{The algorithm selects a solution from the archive based on its Pareto-frontier proximity and applies a novel edge-swapping and insertion hybrid operator to generate a neighbor solution, ensuring feasibility while balancing exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with the best trade-off between objectives\n    def pareto_score(solution):\n        obj = archive[solution][1]\n        return sum(obj)  # Simple sum as a proxy for Pareto optimality\n\n    selected_idx = min(range(len(archive)), key=lambda i: pareto_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(3):  # Limited perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Hybrid edge-swapping and insertion\n        if random.random() < 0.5:\n            # Edge-swapping\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Insertion\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6848003217575068,
            1.6532141447067261
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with the best trade-off between objectives\n    def pareto_score(solution):\n        obj = archive[solution][1]\n        return sum(obj)  # Simple sum as a proxy for Pareto optimality\n\n    selected_idx = min(range(len(archive)), key=lambda i: pareto_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(3):  # Limited perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Hybrid edge-swapping and insertion\n        if random.random() < 0.5:\n            # Edge-swapping\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Insertion\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel local search operator that combines segment reversal, insertion, and swap moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment reversal, insertion, and swap moves\n    n = len(new_solution)\n    for _ in range(5):\n        move_type = random.random()\n\n        if move_type < 0.4:  # Segment reversal\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.7:  # Insertion\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n        else:  # Swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4447509571413823,
            1.7736751675605773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: segment reversal, insertion, and swap moves\n    n = len(new_solution)\n    for _ in range(5):\n        move_type = random.random()\n\n        if move_type < 0.4:  # Segment reversal\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.7:  # Insertion\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n        else:  # Swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a hybrid local search combining edge insertion and node reversal moves, guided by a multi-objective improvement criterion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and node reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion move\n        if random.random() < 0.6:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n        # Node reversal move\n        else:\n            k = random.randint(i, j)\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6605648269218116,
            1.4318444848060607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high combined objective value\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and node reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion move\n        if random.random() < 0.6:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n        # Node reversal move\n        else:\n            k = random.randint(i, j)\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objective values and applies a hybrid local search operator that combines 4-opt and 5-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        m = random.randint(l, j) if j - l >= 1 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            new_solution[l:m+1] = new_solution[l:m+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.45602702849394916,
            1.5931491017341615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        m = random.randint(l, j) if j - l >= 1 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            new_solution[l:m+1] = new_solution[l:m+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{This new algorithm selects a solution from the archive by prioritizing those with the highest Pareto-dominance score, calculated as the sum of normalized objective values, and applies a hybrid local search operator that combines 4-opt and random segment reversal moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high Pareto-dominance score\n    def pareto_score(solution):\n        obj = archive[solution][1]\n        max_obj = max(max(obj[0], obj[1]), obj[2])\n        return (obj[0] / max_obj) + (obj[1] / max_obj) + (obj[2] / max_obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: pareto_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and random segment reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n        l = random.randint(k, j) if j - k >= 2 else j\n\n        # 4-opt move\n        if random.random() < 0.6:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            new_solution[l:j+1] = new_solution[l:j+1][::-1]\n        # Random segment reversal\n        else:\n            segment = new_solution[i:j+1]\n            random.shuffle(segment)\n            new_solution[i:j+1] = segment\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8322162516149584,
            1.4671115279197693
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high Pareto-dominance score\n    def pareto_score(solution):\n        obj = archive[solution][1]\n        max_obj = max(max(obj[0], obj[1]), obj[2])\n        return (obj[0] / max_obj) + (obj[1] / max_obj) + (obj[2] / max_obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: pareto_score(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt and random segment reversal\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n        l = random.randint(k, j) if j - k >= 2 else j\n\n        # 4-opt move\n        if random.random() < 0.6:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            new_solution[l:j+1] = new_solution[l:j+1][::-1]\n        # Random segment reversal\n        else:\n            segment = new_solution[i:j+1]\n            random.shuffle(segment)\n            new_solution[i:j+1] = segment\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst-case objective value (maximizing the minimum objective) and applies a hybrid local search combining 2-opt, 3-opt, and a novel \"objective-aware\" 4-opt move to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_worst(solution):\n        obj = archive[solution][1]\n        return min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_worst(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n        l = random.randint(k, j) if j - k >= 1 else j\n\n        if random.random() < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif random.random() < 0.7:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            new_solution[l:j+1] = new_solution[l:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6283560073827632,
            1.4606318831443788
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_worst(solution):\n        obj = archive[solution][1]\n        return min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_worst(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n        l = random.randint(k, j) if j - k >= 1 else j\n\n        if random.random() < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif random.random() < 0.7:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            new_solution[l:j+1] = new_solution[l:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a novel local search operator that combines a multi-objective aware swap and a dynamic segment reversal move, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)) / sum(obj))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Multi-objective aware swap\n        if random.random() < 0.5:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Dynamic segment reversal\n        else:\n            segment_size = random.randint(2, min(5, n-1))\n            start = random.randint(0, n - segment_size)\n            new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8369005264744827,
            1.5154666304588318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return 1 / (1 + (max(obj) - min(obj)) / sum(obj))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        # Multi-objective aware swap\n        if random.random() < 0.5:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Dynamic segment reversal\n        else:\n            segment_size = random.randint(2, min(5, n-1))\n            start = random.randint(0, n - segment_size)\n            new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objectives and applies a novel multi-objective local search operator that combines a custom edge-swap strategy with a Pareto-dominance-aware perturbation to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return min(obj) / max(obj) if max(obj) != 0 else 1.0\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search with edge-swap and perturbation\n    n = len(new_solution)\n    for _ in range(5):\n        # Randomly select two distinct edges\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Perform a custom edge-swap\n        if random.random() < 0.5:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7725821839709417,
            1.626213538646698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        return min(obj) / max(obj) if max(obj) != 0 else 1.0\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective local search with edge-swap and perturbation\n    n = len(new_solution)\n    for _ in range(5):\n        # Randomly select two distinct edges\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Perform a custom edge-swap\n        if random.random() < 0.5:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{The algorithm selects a solution from the archive based on a novel objective balance metric that considers both the variance and the maximum deviation of objective values, then applies a hybrid local search operator combining 4-opt and 5-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((x - mean) ** 2 for x in obj)\n        max_dev = max(abs(x - mean) for x in obj)\n        return -(variance + max_dev)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        m = random.randint(k, j) if j - k >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:m+1] = new_solution[k:m+1][::-1]\n            new_solution[m:j+1] = new_solution[m:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9049840525967203,
            1.6711020112037658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((x - mean) ** 2 for x in obj)\n        max_dev = max(abs(x - mean) for x in obj)\n        return -(variance + max_dev)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        m = random.randint(k, j) if j - k >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:m+1] = new_solution[k:m+1][::-1]\n            new_solution[m:j+1] = new_solution[m:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high Pareto front proximity, then applies a novel 'tri-objective segment inversion' operator that reverses segments of the tour in all three objective spaces simultaneously, ensuring feasibility through a multi-space validation check.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def pareto_proximity(solution):\n        obj = archive[solution][1]\n        return -sum(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: pareto_proximity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        for k in range(len(segment)-1):\n            if random.random() < 0.4:\n                segment[k], segment[k+1] = segment[k+1], segment[k]\n\n        new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6400431827429542,
            1.8955750107765197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def pareto_proximity(solution):\n        obj = archive[solution][1]\n        return -sum(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: pareto_proximity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        for k in range(len(segment)-1):\n            if random.random() < 0.4:\n                segment[k], segment[k+1] = segment[k+1], segment[k]\n\n        new_solution[i:j+1] = segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a novel segment-based local search operator that combines adaptive segment reversal and segment insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n\n        if random.random() < 0.5:\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n        else:\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.47179116049993775,
            1.968510091304779
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n\n        if random.random() < 0.5:\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n        else:\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced and diverse objectives, then applies a novel local search operator that combines 2-opt, 3-opt, and adaptive edge insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_potential(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        return (diversity + 1) / (sum((x - mean) ** 2 for x in obj) + 1)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_potential(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        move_type = random.random()\n        if move_type < 0.4:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(i, j) if j - i >= 2 else j\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8144776971138967,
            1.8716256141662597
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_potential(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        return (diversity + 1) / (sum((x - mean) ** 2 for x in obj) + 1)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_potential(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        move_type = random.random()\n        if move_type < 0.4:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            k = random.randint(i, j) if j - i >= 2 else j\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{The new algorithm selects a solution from the archive based on its objective diversity and applies a hybrid local search operator that combines edge insertion and node relocation moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            # Edge insertion move\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n        else:\n            # Node relocation move\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4427462113046565,
            1.6625683784484864
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        if random.random() < 0.5:\n            # Edge insertion move\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n        else:\n            # Node relocation move\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and diverse objectives, then applies a novel hybrid local search operator that combines 2-opt, 3-opt, and a novel \"objective-aware\" move guided by Pareto-dominance, ensuring feasibility and diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def combined_metric(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        balance = -sum((x - mean) ** 2 for x in obj)\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        return balance + diversity\n\n    selected_idx = max(range(len(archive)), key=lambda i: combined_metric(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.random()\n        if move_type < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.8:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            obj_weights = [random.random() for _ in range(3)]\n            obj_weights = [w / sum(obj_weights) for w in obj_weights]\n            total_cost = sum(obj_weights[m] * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                              distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                              distance_matrix_3[new_solution[i-1], new_solution[j]]) for m in range(3))\n            if total_cost > 0:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7779639932547914,
            2.0374629974365233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def combined_metric(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        balance = -sum((x - mean) ** 2 for x in obj)\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        return balance + diversity\n\n    selected_idx = max(range(len(archive)), key=lambda i: combined_metric(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.random()\n        if move_type < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.8:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            obj_weights = [random.random() for _ in range(3)]\n            obj_weights = [w / sum(obj_weights) for w in obj_weights]\n            total_cost = sum(obj_weights[m] * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                              distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                              distance_matrix_3[new_solution[i-1], new_solution[j]]) for m in range(3))\n            if total_cost > 0:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high variation in objectives and applies a hybrid local search combining edge insertion and node relocation moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high objective variation\n    def objective_variation(solution):\n        obj = archive[solution][1]\n        return (max(obj) - min(obj)) / (sum(obj) + 1e-6)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variation(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and node relocation\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.5:\n            # Edge insertion move\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:k+1], new_solution[i+1:j], new_solution[k+1:]])\n        else:\n            # Node relocation move\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4404852089244563,
            1.8781862020492555
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high objective variation\n    def objective_variation(solution):\n        obj = archive[solution][1]\n        return (max(obj) - min(obj)) / (sum(obj) + 1e-6)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variation(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and node relocation\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.5:\n            # Edge insertion move\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:k+1], new_solution[i+1:j], new_solution[k+1:]])\n        else:\n            # Node relocation move\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{The algorithm selects a solution from the archive that has the most balanced objective values across the three objectives and applies a hybrid local search operator that combines segment reversal and node insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            node = new_solution[j]\n            new_solution = np.concatenate((new_solution[:j], new_solution[j+1:], [node]))\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.850794788735409,
            1.3019879102706908
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            node = new_solution[j]\n            new_solution = np.concatenate((new_solution[:j], new_solution[j+1:], [node]))\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4220715043832981,
            1.5858042240142822
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4271449767782691,
            1.480706524848938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values and applies a novel multi-objective local search that combines edge insertion and segment relocation moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution, while ensuring feasibility through a dynamic feasibility check.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    nodes = set(range(n))\n\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            segment_length = random.randint(2, min(5, n//2))\n            i = random.randint(0, n - segment_length)\n            j = random.randint(0, n - segment_length)\n            segment = new_solution[i:i+segment_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7747998656405941,
            1.2253855228424073
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    nodes = set(range(n))\n\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            segment_length = random.randint(2, min(5, n//2))\n            i = random.randint(0, n - segment_length)\n            j = random.randint(0, n - segment_length)\n            segment = new_solution[i:i+segment_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{The algorithm selects a solution from the archive that has the worst objective value in at least one dimension, then applies a novel segment reversal and insertion operator that intelligently combines segments of the tour while ensuring feasibility, guided by a multi-objective improvement criterion that balances all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the worst objective in at least one dimension\n    selected_idx = max(range(len(archive)), key=lambda i: max(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(3):  # Number of perturbation attempts\n        # Randomly select two segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure segments are of sufficient length\n        if b - a < 2 or d - c < 2:\n            continue\n\n        # Extract segments\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Reverse one segment and insert it before the other\n        if random.random() < 0.5:\n            segment1 = segment1[::-1]\n            new_solution = np.concatenate([new_solution[:c], segment1, new_solution[c:]])\n        else:\n            segment2 = segment2[::-1]\n            new_solution = np.concatenate([new_solution[:a], segment2, new_solution[a:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7065431074398836,
            0.2632530927658081
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the worst objective in at least one dimension\n    selected_idx = max(range(len(archive)), key=lambda i: max(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(3):  # Number of perturbation attempts\n        # Randomly select two segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure segments are of sufficient length\n        if b - a < 2 or d - c < 2:\n            continue\n\n        # Extract segments\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Reverse one segment and insert it before the other\n        if random.random() < 0.5:\n            segment1 = segment1[::-1]\n            new_solution = np.concatenate([new_solution[:c], segment1, new_solution[c:]])\n        else:\n            segment2 = segment2[::-1]\n            new_solution = np.concatenate([new_solution[:a], segment2, new_solution[a:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{The algorithm selects a solution from the archive that has the worst objective value in at least one dimension, then applies a novel segment reversal and insertion operator that intelligently combines segments of the tour while ensuring feasibility, guided by a multi-objective improvement criterion that balances all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the worst objective in at least one dimension\n    selected_idx = max(range(len(archive)), key=lambda i: max(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(3):  # Number of perturbation attempts\n        # Randomly select two segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure segments are of sufficient length\n        if b - a < 2 or d - c < 2:\n            continue\n\n        # Extract segments\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Reverse one segment and insert it before the other\n        if random.random() < 0.5:\n            segment1 = segment1[::-1]\n            new_solution = np.concatenate([new_solution[:c], segment1, new_solution[c:]])\n        else:\n            segment2 = segment2[::-1]\n            new_solution = np.concatenate([new_solution[:a], segment2, new_solution[a:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7065431074398836,
            0.2632530927658081
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the worst objective in at least one dimension\n    selected_idx = max(range(len(archive)), key=lambda i: max(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(3):  # Number of perturbation attempts\n        # Randomly select two segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure segments are of sufficient length\n        if b - a < 2 or d - c < 2:\n            continue\n\n        # Extract segments\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Reverse one segment and insert it before the other\n        if random.random() < 0.5:\n            segment1 = segment1[::-1]\n            new_solution = np.concatenate([new_solution[:c], segment1, new_solution[c:]])\n        else:\n            segment2 = segment2[::-1]\n            new_solution = np.concatenate([new_solution[:a], segment2, new_solution[a:]])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = sum(obj) / 3\n        return -sum((o - mean_obj) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8948613265775155,
            1.3704429984092712
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with balanced objectives\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean_obj = sum(obj) / 3\n        return -sum((o - mean_obj) ** 2 for o in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with extreme objective values (to explore diverse regions) and applies a hybrid local search operator that combines 2-opt, 3-opt, and a novel segment inversion move, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.random()\n        if move_type < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.7:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            new_segment = np.concatenate([segment[1:], segment[:1]])\n            new_solution[i:j+1] = new_segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.46905246729661965,
            1.7229381561279298
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.random()\n        if move_type < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.7:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            new_segment = np.concatenate([segment[1:], segment[:1]])\n            new_solution[i:j+1] = new_segment\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values and applies a novel hybrid local search operator that combines adaptive segment inversion and objective-aware edge swapping to generate a neighbor solution while ensuring Pareto-dominance awareness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment_length = j - i + 1\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            if segment_length >= 3:\n                k = random.randint(i+1, j-1)\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n            else:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    for _ in range(3):\n        a, b = random.sample(range(n), 2)\n        node_a = new_solution[a]\n        node_b = new_solution[b]\n\n        obj_a = sum([distance_matrix_1[node_a][node_b], distance_matrix_2[node_a][node_b], distance_matrix_3[node_a][node_b]])\n        obj_b = sum([distance_matrix_1[new_solution[(a-1)%n]][node_b] + distance_matrix_1[node_b][new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[(a-1)%n]][node_b] + distance_matrix_2[node_b][new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[(a-1)%n]][node_b] + distance_matrix_3[node_b][new_solution[(a+1)%n]]])\n\n        if obj_b < obj_a:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7327707273211603,
            1.8140174508094788
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment_length = j - i + 1\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            if segment_length >= 3:\n                k = random.randint(i+1, j-1)\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n            else:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    for _ in range(3):\n        a, b = random.sample(range(n), 2)\n        node_a = new_solution[a]\n        node_b = new_solution[b]\n\n        obj_a = sum([distance_matrix_1[node_a][node_b], distance_matrix_2[node_a][node_b], distance_matrix_3[node_a][node_b]])\n        obj_b = sum([distance_matrix_1[new_solution[(a-1)%n]][node_b] + distance_matrix_1[node_b][new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[(a-1)%n]][node_b] + distance_matrix_2[node_b][new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[(a-1)%n]][node_b] + distance_matrix_3[node_b][new_solution[(a+1)%n]]])\n\n        if obj_b < obj_a:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a novel local search operator that combines segment inversion and segment rotation, guided by a multi-objective improvement heuristic to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = segment[::-1]\n        else:\n            rotation = random.randint(1, len(segment)-1)\n            new_solution[i:j+1] = np.roll(segment, rotation)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8845246415509138,
            1.7520997166633605
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = segment[::-1]\n        else:\n            rotation = random.randint(1, len(segment)-1)\n            new_solution[i:j+1] = np.roll(segment, rotation)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the highest normalized objective diversity, then applies a novel multi-objective local search combining adaptive segment reversal and objective-aware swaps, ensuring feasibility and balancing improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest normalized objective diversity\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        if max_val == 0:\n            return 0\n        normalized = [o / max_val for o in obj]\n        return sum(abs(normalized[i] - normalized[j]) for i in range(3) for j in range(i+1, 3))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal and objective-aware swaps\n    for _ in range(3):\n        # Select segment with potential for multi-objective improvement\n        segment_size = min(5, n // 2)\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Reverse segment and evaluate objectives\n        reversed_segment = new_solution[start:end][::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = reversed_segment\n\n        # Calculate objective improvements\n        def calculate_improvement(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(n))\n            cost3 = sum(distance_matrix_3[solution[i-1], solution[i]] for i in range(n))\n            return (cost1, cost2, cost3)\n\n        original_costs = calculate_improvement(new_solution)\n        new_costs = calculate_improvement(temp_solution)\n\n        # Accept if at least one objective improves\n        if any(new_costs[i] < original_costs[i] for i in range(3)):\n            new_solution = temp_solution\n\n        # Objective-aware swap\n        if random.random() < 0.3:\n            i, j = random.sample(range(n), 2)\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            new_costs = calculate_improvement(temp_solution)\n            if any(new_costs[i] < original_costs[i] for i in range(3)):\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.4774152427184412,
            2.867590570449829
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest normalized objective diversity\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        if max_val == 0:\n            return 0\n        normalized = [o / max_val for o in obj]\n        return sum(abs(normalized[i] - normalized[j]) for i in range(3) for j in range(i+1, 3))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal and objective-aware swaps\n    for _ in range(3):\n        # Select segment with potential for multi-objective improvement\n        segment_size = min(5, n // 2)\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Reverse segment and evaluate objectives\n        reversed_segment = new_solution[start:end][::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = reversed_segment\n\n        # Calculate objective improvements\n        def calculate_improvement(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(n))\n            cost3 = sum(distance_matrix_3[solution[i-1], solution[i]] for i in range(n))\n            return (cost1, cost2, cost3)\n\n        original_costs = calculate_improvement(new_solution)\n        new_costs = calculate_improvement(temp_solution)\n\n        # Accept if at least one objective improves\n        if any(new_costs[i] < original_costs[i] for i in range(3)):\n            new_solution = temp_solution\n\n        # Objective-aware swap\n        if random.random() < 0.3:\n            i, j = random.sample(range(n), 2)\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            new_costs = calculate_improvement(temp_solution)\n            if any(new_costs[i] < original_costs[i] for i in range(3)):\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8038642795416904,
            1.764283788204193
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with diverse objective values and applies a hybrid local search operator that combines edge insertion and node relocation moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(i+1, 3))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n:\n            j = random.randint(0, n-1)\n\n        if random.random() < 0.7:\n            new_solution = np.roll(new_solution, 1) if i < j else np.roll(new_solution, -1)\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4952860809138172,
            2.506691873073578
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(i+1, 3))\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n:\n            j = random.randint(0, n-1)\n\n        if random.random() < 0.7:\n            new_solution = np.roll(new_solution, 1) if i < j else np.roll(new_solution, -1)\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a novel multi-objective local search operator that combines segment inversion, segment rotation, and segment insertion moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1) if n > 1 else 0\n\n        move_type = random.random()\n        if move_type < 0.33:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.66:\n            segment = new_solution[i:j+1]\n            rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n            new_solution[i:j+1] = rotated_segment\n        else:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8364425286375056,
            1.5326408267021179
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1) if n > 1 else 0\n\n        move_type = random.random()\n        if move_type < 0.33:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.66:\n            segment = new_solution[i:j+1]\n            rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n            new_solution[i:j+1] = rotated_segment\n        else:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with low variance in objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = min(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8542606899758635,
            1.7367990255355834
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = min(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with low variance in objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = min(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8748587957160767,
            1.6700567483901978
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = min(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high variance in objective values and applies an adaptive local search operator that dynamically switches between 2-opt, 3-opt, and a novel \"objective-aware segment reversal\" move, guided by the current dominance relationships between objectives to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.random()\n        if move_type < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.7:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            obj1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            obj2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            obj3 = sum(distance_matrix_3[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            if obj1 > obj2 and obj1 > obj3:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                new_solution[i:j+1] = np.roll(new_solution[i:j+1], 1)\n            else:\n                new_solution[i:j+1] = np.roll(new_solution[i:j+1], -1)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4140409001351011,
            1.694836711883545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        move_type = random.random()\n        if move_type < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif move_type < 0.7:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            obj1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            obj2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            obj3 = sum(distance_matrix_3[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            if obj1 > obj2 and obj1 > obj3:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                new_solution[i:j+1] = np.roll(new_solution[i:j+1], 1)\n            else:\n                new_solution[i:j+1] = np.roll(new_solution[i:j+1], -1)\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with extreme objective values in any dimension, then applies a novel \"objective-aware\" local search that combines segment reversal with multi-objective-aware edge swaps, ensuring feasibility and promoting diverse improvements across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            obj_weights = [1.0, 0.8, 0.6]\n            best_swap = None\n            min_cost = float('inf')\n\n            for l in range(i, j):\n                for m in range(l+1, j+1):\n                    temp_solution = new_solution.copy()\n                    temp_solution[l], temp_solution[m] = temp_solution[m], temp_solution[l]\n\n                    cost = 0\n                    for o in range(3):\n                        dist_mat = [distance_matrix_1, distance_matrix_2, distance_matrix_3][o]\n                        cost += obj_weights[o] * (dist_mat[temp_solution[l-1], temp_solution[l]] +\n                                                 dist_mat[temp_solution[m], temp_solution[m+1 if m+1 < n else 0]] -\n                                                 dist_mat[temp_solution[l-1], temp_solution[m]] -\n                                                 dist_mat[temp_solution[l], temp_solution[m+1 if m+1 < n else 0]])\n\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_swap = (l, m)\n\n            if best_swap:\n                l, m = best_swap\n                new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.43629041330608287,
            2.373513567447662
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_extremity(solution):\n        obj = archive[solution][1]\n        max_val = max(obj)\n        min_val = min(obj)\n        return max_val - min_val\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_extremity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            obj_weights = [1.0, 0.8, 0.6]\n            best_swap = None\n            min_cost = float('inf')\n\n            for l in range(i, j):\n                for m in range(l+1, j+1):\n                    temp_solution = new_solution.copy()\n                    temp_solution[l], temp_solution[m] = temp_solution[m], temp_solution[l]\n\n                    cost = 0\n                    for o in range(3):\n                        dist_mat = [distance_matrix_1, distance_matrix_2, distance_matrix_3][o]\n                        cost += obj_weights[o] * (dist_mat[temp_solution[l-1], temp_solution[l]] +\n                                                 dist_mat[temp_solution[m], temp_solution[m+1 if m+1 < n else 0]] -\n                                                 dist_mat[temp_solution[l-1], temp_solution[m]] -\n                                                 dist_mat[temp_solution[l], temp_solution[m+1 if m+1 < n else 0]])\n\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_swap = (l, m)\n\n            if best_swap:\n                l, m = best_swap\n                new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high objective diversity and applies a novel multi-objective local search operator that combines 2-opt and 3-opt moves with a Pareto-dominance-aware objective function, while also incorporating a segment-based perturbation strategy to explore diverse regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        if random.random() < 0.5:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            mid = random.randint(start + 1, end - 1)\n            new_solution[start:mid] = new_solution[start:mid][::-1]\n            new_solution[mid:end] = new_solution[mid:end][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.43670965024577885,
            2.404542362689972
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        if random.random() < 0.5:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            mid = random.randint(start + 1, end - 1)\n            new_solution[start:mid] = new_solution[start:mid][::-1]\n            new_solution[mid:end] = new_solution[mid:end][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a novel multi-objective local search operator that combines segment reversal, insertion, and swap moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        move_type = random.choice(['reverse', 'insert', 'swap'])\n\n        if move_type == 'reverse':\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif move_type == 'insert':\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n        elif move_type == 'swap':\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8311751902782799,
            1.8093311071395874
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        move_type = random.choice(['reverse', 'insert', 'swap'])\n\n        if move_type == 'reverse':\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif move_type == 'insert':\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n        elif move_type == 'swap':\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a novel multi-objective local search operator that combines adaptive segment reversal and objective-aware edge swaps to generate a neighbor solution, while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            obj_weights = [random.random() for _ in range(3)]\n            obj_weights = [w/sum(obj_weights) for w in obj_weights]\n\n            def edge_cost(a, b):\n                return (distance_matrix_1[a, b] * obj_weights[0] +\n                        distance_matrix_2[a, b] * obj_weights[1] +\n                        distance_matrix_3[a, b] * obj_weights[2])\n\n            if random.random() < 0.7:\n                for _ in range(2):\n                    a, b = random.sample(range(n), 2)\n                    if edge_cost(new_solution[a-1], new_solution[a]) + edge_cost(new_solution[b-1], new_solution[b]) > edge_cost(new_solution[a-1], new_solution[b]) + edge_cost(new_solution[a], new_solution[b-1]):\n                        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            else:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8834713109922653,
            2.104068171977997
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            obj_weights = [random.random() for _ in range(3)]\n            obj_weights = [w/sum(obj_weights) for w in obj_weights]\n\n            def edge_cost(a, b):\n                return (distance_matrix_1[a, b] * obj_weights[0] +\n                        distance_matrix_2[a, b] * obj_weights[1] +\n                        distance_matrix_3[a, b] * obj_weights[2])\n\n            if random.random() < 0.7:\n                for _ in range(2):\n                    a, b = random.sample(range(n), 2)\n                    if edge_cost(new_solution[a-1], new_solution[a]) + edge_cost(new_solution[b-1], new_solution[b]) > edge_cost(new_solution[a-1], new_solution[b]) + edge_cost(new_solution[a], new_solution[b-1]):\n                        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            else:\n                new_solution[i:k+1] = new_solution[i:k+1][::-1]\n                new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.837396499499208,
            1.6804751873016357
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with high objective values and applies a hybrid local search operator that combines edge swaps and segment reversals, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_sum(solution):\n        obj = archive[solution][1]\n        return sum(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_sum(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps and segment reversals\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge swap\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Segment reversal\n        else:\n            k = random.randint(i, min(i+2, n-1))\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7343668078826254,
            1.4793473958969117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_sum(solution):\n        obj = archive[solution][1]\n        return sum(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_sum(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps and segment reversals\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge swap\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        # Segment reversal\n        else:\n            k = random.randint(i, min(i+2, n-1))\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with diverse objectives and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n\n    # Prioritize solutions with higher objective diversity\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt and 3-opt moves\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        # 2-opt move\n        if random.random() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # 3-opt move\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with high variance in objective values and applies a hybrid local search operator that combines edge reinsertion and node swap moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((o - mean) ** 2 for o in obj) / 3\n        return variance\n\n    # Prioritize solutions with higher objective variance\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge reinsertion and node swap\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.5:\n            # Edge reinsertion\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n        else:\n            # Node swap\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.42345686103102853,
            1.6148905873298645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def objective_variance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        variance = sum((o - mean) ** 2 for o in obj) / 3\n        return variance\n\n    # Prioritize solutions with higher objective variance\n    selected_idx = max(range(len(archive)), key=lambda i: objective_variance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge reinsertion and node swap\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        if random.random() < 0.5:\n            # Edge reinsertion\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n        else:\n            # Node swap\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing those with balanced objective values and applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a Pareto-dominance-aware objective function to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_balance(solution):\n        obj = archive[solution][1]\n        mean = sum(obj) / 3\n        return -sum((x - mean) ** 2 for x in obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_balance(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j) if j - i >= 2 else j\n\n        if random.random() < 0.6:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n            new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{This algorithm selects a solution from the archive based on its diversity in objective values, then applies a hybrid local search combining edge insertion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i >= 2:\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n            if len(np.unique(new_solution)) == n:\n                break\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.40866940639822413,
            1.4569827556610107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def objective_diversity(solution):\n        obj = archive[solution][1]\n        return max(obj) - min(obj)\n\n    selected_idx = max(range(len(archive)), key=lambda i: objective_diversity(i))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i >= 2:\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n            if len(np.unique(new_solution)) == n:\n                break\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    }
]