[
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7075858936603054,
            2.2624062061309815
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ]
    }
]