[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7075858936603054,
            2.2624062061309815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7075858936603054,
            2.2624062061309815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7075858936603054,
            2.2624062061309815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve the worst objective\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap: select a node that improves the worst objective\n    worst_obj = archive[selected_idx][1]\n    worst_dim = np.argmax(worst_obj)\n    if worst_dim == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_dim == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best swap to improve the worst objective\n    best_improvement = 0\n    best_swap = None\n    for a in range(n):\n        for b in range(a+1, n):\n            # Calculate current and new distances for the worst objective\n            current_dist = (dist_matrix[new_solution[a-1], new_solution[a]] +\n                           dist_matrix[new_solution[b-1], new_solution[b]])\n            new_dist = (dist_matrix[new_solution[a-1], new_solution[b]] +\n                        dist_matrix[new_solution[b-1], new_solution[a]])\n            improvement = current_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n\n    if best_swap is not None:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5954185406515675,
            3.1966228246688844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve the worst objective\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap: select a node that improves the worst objective\n    worst_obj = archive[selected_idx][1]\n    worst_dim = np.argmax(worst_obj)\n    if worst_dim == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_dim == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best swap to improve the worst objective\n    best_improvement = 0\n    best_swap = None\n    for a in range(n):\n        for b in range(a+1, n):\n            # Calculate current and new distances for the worst objective\n            current_dist = (dist_matrix[new_solution[a-1], new_solution[a]] +\n                           dist_matrix[new_solution[b-1], new_solution[b]])\n            new_dist = (dist_matrix[new_solution[a-1], new_solution[b]] +\n                        dist_matrix[new_solution[b-1], new_solution[a]])\n            improvement = current_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n\n    if best_swap is not None:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{This heuristic first identifies the solution in the archive with the highest average objective value, then applies a novel segment inversion and rotation operator that considers the three objectives simultaneously, ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_objectives = [obj for sol, obj in archive]\n    objective_avgs = [sum(obj)/3 for obj in archive_objectives]\n    selected_idx = np.argmax(objective_avgs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to invert and rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Apply segment inversion and rotation\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j+1] = rotated_segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6853027334304664,
            1.6494604825973511
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_objectives = [obj for sol, obj in archive]\n    objective_avgs = [sum(obj)/3 for obj in archive_objectives]\n    selected_idx = np.argmax(objective_avgs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to invert and rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Apply segment inversion and rotation\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j+1] = rotated_segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{This heuristic first identifies the solution in the archive with the highest average objective value, then applies a novel segment inversion and rotation operator that considers the three objectives simultaneously, ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_objectives = [obj for sol, obj in archive]\n    objective_avgs = [sum(obj)/3 for obj in archive_objectives]\n    selected_idx = np.argmax(objective_avgs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to invert and rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Apply segment inversion and rotation\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j+1] = rotated_segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6853027334304664,
            1.6494604825973511
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_objectives = [obj for sol, obj in archive]\n    objective_avgs = [sum(obj)/3 for obj in archive_objectives]\n    selected_idx = np.argmax(objective_avgs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to invert and rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Apply segment inversion and rotation\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j+1] = rotated_segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to potentially swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    # Additional random perturbation to escape local optima\n    if random.random() < 0.3:\n        k = random.randint(0, n - 2)\n        l = random.randint(0, n - 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7611015908412745,
            3.673111009597778
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to potentially swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    # Additional random perturbation to escape local optima\n    if random.random() < 0.3:\n        k = random.randint(0, n - 2)\n        l = random.randint(0, n - 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to potentially swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    # Additional random perturbation to escape local optima\n    if random.random() < 0.3:\n        k = random.randint(0, n - 2)\n        l = random.randint(0, n - 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7611015908412745,
            3.673111009597778
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to potentially swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    # Additional random perturbation to escape local optima\n    if random.random() < 0.3:\n        k = random.randint(0, n - 2)\n        l = random.randint(0, n - 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective 3-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (combination of diversity and objective values)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    diversity_scores = [len(set(obj)) for obj in archive_objectives]\n    combined_scores = [sum_val * (div + 1) for sum_val, div in zip(objective_sums, diversity_scores)]\n    selection_probs = [1.0 / (score + 1e-6) for score in combined_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on combined scores\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt heuristic\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select three random edges to reconnect (ensuring feasibility)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reconnecting edges (3-opt move)\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n    candidate[i:k+1] = candidate[i:k+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7446715192078994,
            3.047483265399933
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (combination of diversity and objective values)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    diversity_scores = [len(set(obj)) for obj in archive_objectives]\n    combined_scores = [sum_val * (div + 1) for sum_val, div in zip(objective_sums, diversity_scores)]\n    selection_probs = [1.0 / (score + 1e-6) for score in combined_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on combined scores\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt heuristic\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select three random edges to reconnect (ensuring feasibility)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reconnecting edges (3-opt move)\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n    candidate[i:k+1] = candidate[i:k+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective 3-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt heuristic\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select three random edges to reconnect (ensuring feasibility)\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[a:b+1] = candidate[a:b+1][::-1]\n    candidate[b:c+1] = candidate[b:c+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7583183156985881,
            2.8197679042816164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt heuristic\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select three random edges to reconnect (ensuring feasibility)\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[a:b+1] = candidate[a:b+1][::-1]\n    candidate[b:c+1] = candidate[b:c+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate normalized objective values\n    max_obj1 = max(obj[0] for obj in archive_objectives)\n    max_obj2 = max(obj[1] for obj in archive_objectives)\n    max_obj3 = max(obj[2] for obj in archive_objectives)\n\n    # Calculate selection weights (inverse of normalized objectives)\n    weights = []\n    for obj in archive_objectives:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 1.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 1.0\n        norm_obj3 = obj[2] / max_obj3 if max_obj3 > 0 else 1.0\n        weight = 1.0 / (norm_obj1 + norm_obj2 + norm_obj3 + 1e-6)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    selection_probs = [w / total_weight for w in weights]\n\n    # Randomly select a solution based on weighted probabilities\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try random 2-opt moves\n    for _ in range(min(10, n)):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == i + 1 or (i == 0 and j == n - 1):\n            continue\n\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8155338491122228,
            2.458009123802185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate normalized objective values\n    max_obj1 = max(obj[0] for obj in archive_objectives)\n    max_obj2 = max(obj[1] for obj in archive_objectives)\n    max_obj3 = max(obj[2] for obj in archive_objectives)\n\n    # Calculate selection weights (inverse of normalized objectives)\n    weights = []\n    for obj in archive_objectives:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 1.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 1.0\n        norm_obj3 = obj[2] / max_obj3 if max_obj3 > 0 else 1.0\n        weight = 1.0 / (norm_obj1 + norm_obj2 + norm_obj3 + 1e-6)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    selection_probs = [w / total_weight for w in weights]\n\n    # Randomly select a solution based on weighted probabilities\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try random 2-opt moves\n    for _ in range(min(10, n)):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == i + 1 or (i == 0 and j == n - 1):\n            continue\n\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This algorithm selects a solution from the archive based on the most underperforming objective and applies a hybrid 2-opt and 3-opt local search operator that considers all three objectives simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Select solution with the worst objective\n    worst_obj_idx = np.argmax([max(obj) for obj in archive_objectives])\n    base_solution = archive_solutions[worst_obj_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 2-opt and 3-opt local search\n    if n >= 4:\n        # 2-opt move\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        current_cost = calculate_cost(new_solution)\n\n        # Generate candidate solution by reversing segment\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n        # 3-opt move if improvement found\n        if not np.array_equal(new_solution, base_solution):\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 1, n - 2)\n            k = random.randint(j + 1, n - 1)\n\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n            candidate[j:k+1] = candidate[j:k+1][::-1]\n\n            candidate_cost = calculate_cost(candidate)\n            if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n                new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.5657838554186786,
            2.262654995918274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Select solution with the worst objective\n    worst_obj_idx = np.argmax([max(obj) for obj in archive_objectives])\n    base_solution = archive_solutions[worst_obj_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 2-opt and 3-opt local search\n    if n >= 4:\n        # 2-opt move\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        current_cost = calculate_cost(new_solution)\n\n        # Generate candidate solution by reversing segment\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n        # 3-opt move if improvement found\n        if not np.array_equal(new_solution, base_solution):\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 1, n - 2)\n            k = random.randint(j + 1, n - 1)\n\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n            candidate[j:k+1] = candidate[j:k+1][::-1]\n\n            candidate_cost = calculate_cost(candidate)\n            if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n                new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{This heuristic selects a solution from the archive based on objective diversity and improvement potential, then applies a multi-objective 2-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    max_sum = max(objective_sums)\n    selection_probs = [(max_sum - sum_val) / max_sum for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on selection probabilities\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to reconnect (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7113734013893211,
            3.259762334823608
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    max_sum = max(objective_sums)\n    selection_probs = [(max_sum - sum_val) / max_sum for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on selection probabilities\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to reconnect (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and their improvement potential, then applies a multi-objective 2-opt heuristic that considers all three objectives simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted selection score (using inverse of weighted sum)\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    weighted_sums = [sum(w * obj for w, obj in zip(weights, objs)) for objs in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted selection score\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select four distinct nodes to perform 2-opt\n    a, b, c, d = random.sample(range(n), 4)\n    a, b = min(a, b), max(a, b)\n    c, d = min(c, d), max(c, d)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by performing 2-opt\n    candidate = new_solution.copy()\n    candidate[a:b+1] = candidate[a:b+1][::-1]  # Reverse segment between a and b\n    candidate[c:d+1] = candidate[c:d+1][::-1]  # Reverse segment between c and d\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8008375975388056,
            3.567482817173004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted selection score (using inverse of weighted sum)\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    weighted_sums = [sum(w * obj for w, obj in zip(weights, objs)) for objs in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted selection score\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select four distinct nodes to perform 2-opt\n    a, b, c, d = random.sample(range(n), 4)\n    a, b = min(a, b), max(a, b)\n    c, d = min(c, d), max(c, d)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by performing 2-opt\n    candidate = new_solution.copy()\n    candidate[a:b+1] = candidate[a:b+1][::-1]  # Reverse segment between a and b\n    candidate[c:d+1] = candidate[c:d+1][::-1]  # Reverse segment between c and d\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all three objectives)\n    weights = [0.4, 0.3, 0.3]  # Higher weight for the first objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic with larger segment swaps\n    n = len(new_solution)\n    if n < 6:\n        return new_solution\n\n    # Select a larger segment to swap (ensuring feasibility)\n    segment_size = random.randint(3, min(6, n // 2))\n    i = random.randint(0, n - segment_size - 1)\n    j = i + segment_size - 1\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7445188149986746,
            3.157284367084503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all three objectives)\n    weights = [0.4, 0.3, 0.3]  # Higher weight for the first objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic with larger segment swaps\n    n = len(new_solution)\n    if n < 6:\n        return new_solution\n\n    # Select a larger segment to swap (ensuring feasibility)\n    segment_size = random.randint(3, min(6, n // 2))\n    i = random.randint(0, n - segment_size - 1)\n    j = i + segment_size - 1\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective insertion heuristic that considers the three distance matrices simultaneously, inserting a randomly selected node into a different position while ensuring feasibility and potentially improving at least one objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Calculate current costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random node to move\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Select a random new position for the node\n    new_pos = random.randint(0, n-2)\n    if new_pos >= node_idx:\n        new_pos += 1\n\n    # Generate candidate solution by inserting the node at the new position\n    candidate = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    candidate = np.insert(candidate, new_pos, node)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8201268752851695,
            3.0178431034088136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Calculate current costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random node to move\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Select a random new position for the node\n    new_pos = random.randint(0, n-2)\n    if new_pos >= node_idx:\n        new_pos += 1\n\n    # Generate candidate solution by inserting the node at the new position\n    candidate = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    candidate = np.insert(candidate, new_pos, node)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously, prioritizing segments that show high potential for improvement across all objectives, while ensuring feasibility through careful validation of the relocation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Multi-objective segment relocation heuristic\n    # Select a random segment to relocate\n    segment_length = random.randint(2, min(5, n // 2))\n    segment_start = random.randint(0, n - segment_length)\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Find the best insertion point that improves at least one objective\n    best_candidate = None\n    best_improvement = 0\n\n    for i in range(n - segment_length + 1):\n        if i == segment_start:\n            continue\n\n        candidate = new_solution.copy()\n        candidate = np.concatenate([candidate[:i], segment, candidate[i:segment_start], candidate[segment_start + segment_length:]])\n\n        candidate_cost = calculate_cost(candidate)\n        improvement = sum(current - new for current, new in zip(current_cost, candidate_cost))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6126467908709173,
            3.0414188861846925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Multi-objective segment relocation heuristic\n    # Select a random segment to relocate\n    segment_length = random.randint(2, min(5, n // 2))\n    segment_start = random.randint(0, n - segment_length)\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Find the best insertion point that improves at least one objective\n    best_candidate = None\n    best_improvement = 0\n\n    for i in range(n - segment_length + 1):\n        if i == segment_start:\n            continue\n\n        candidate = new_solution.copy()\n        candidate = np.concatenate([candidate[:i], segment, candidate[i:segment_start], candidate[segment_start + segment_length:]])\n\n        candidate_cost = calculate_cost(candidate)\n        improvement = sum(current - new for current, new in zip(current_cost, candidate_cost))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity\n    objective_diversity = []\n    for obj in archive_objectives:\n        diversity = sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(i+1, 3))\n        objective_diversity.append(diversity)\n\n    total_diversity = sum(objective_diversity)\n    selection_probs = [d / total_diversity for d in objective_diversity]\n\n    # Randomly select a solution based on objective diversity\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.5920987097663419,
            3.3565333485603333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity\n    objective_diversity = []\n    for obj in archive_objectives:\n        diversity = sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(i+1, 3))\n        objective_diversity.append(diversity)\n\n    total_diversity = sum(objective_diversity)\n    selection_probs = [d / total_diversity for d in objective_diversity]\n\n    # Randomly select a solution based on objective diversity\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a hybrid local search operator that combines edge swaps and node insertions, considering all three objectives simultaneously to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted selection score (diversity + improvement potential)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    diversity_scores = [np.std([obj[i] for obj in archive_objectives]) for i in range(3)]\n    selection_scores = [0.6 * (1.0 / (sum_val + 1e-6)) + 0.4 * sum(diversity_scores) for sum_val in objective_sums]\n    total_score = sum(selection_scores)\n    selection_probs = [s / total_score for s in selection_scores]\n\n    # Randomly select a solution based on the weighted score\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Choose between edge swap and node insertion with probability 0.7 and 0.3\n    if random.random() < 0.7:\n        # Edge swap operation\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n    else:\n        # Node insertion operation\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = random.randint(0, n - 1)\n        candidate = new_solution.copy()\n        node = candidate[i]\n        candidate = np.delete(candidate, i)\n        candidate = np.insert(candidate, j, node)\n\n    # Calculate costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n    candidate_cost = calculate_cost(candidate)\n\n    # Accept if better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8240571655468777,
            3.581340825557709
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted selection score (diversity + improvement potential)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    diversity_scores = [np.std([obj[i] for obj in archive_objectives]) for i in range(3)]\n    selection_scores = [0.6 * (1.0 / (sum_val + 1e-6)) + 0.4 * sum(diversity_scores) for sum_val in objective_sums]\n    total_score = sum(selection_scores)\n    selection_probs = [s / total_score for s in selection_scores]\n\n    # Randomly select a solution based on the weighted score\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Choose between edge swap and node insertion with probability 0.7 and 0.3\n    if random.random() < 0.7:\n        # Edge swap operation\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n    else:\n        # Node insertion operation\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = random.randint(0, n - 1)\n        candidate = new_solution.copy()\n        node = candidate[i]\n        candidate = np.delete(candidate, i)\n        candidate = np.insert(candidate, j, node)\n\n    # Calculate costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n    candidate_cost = calculate_cost(candidate)\n\n    # Accept if better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment and a random insertion point\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, n - 1)\n    while k >= i and k <= j:\n        k = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating segment\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    if k >= len(candidate):\n        candidate = np.concatenate([candidate, segment])\n    else:\n        candidate = np.concatenate([candidate[:k], segment, candidate[k:]])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7881649329189193,
            2.8662505984306335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment and a random insertion point\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, n - 1)\n    while k >= i and k <= j:\n        k = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating segment\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    if k >= len(candidate):\n        candidate = np.concatenate([candidate, segment])\n    else:\n        candidate = np.concatenate([candidate[:k], segment, candidate[k:]])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation operator that considers the three distance matrices simultaneously, ensuring feasibility by carefully handling node dependencies across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Select a random insertion point\n    insert_pos = random.randint(0, n - segment_length)\n    while insert_pos >= start and insert_pos < end:\n        insert_pos = random.randint(0, n - segment_length)\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating segment\n    candidate = new_solution.copy()\n    segment = candidate[start:end]\n    candidate = np.concatenate([candidate[:start], candidate[end:]])\n    if insert_pos == 0:\n        candidate = np.concatenate([segment, candidate])\n    else:\n        candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7369224914120807,
            2.954187297821045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Select a random insertion point\n    insert_pos = random.randint(0, n - segment_length)\n    while insert_pos >= start and insert_pos < end:\n        insert_pos = random.randint(0, n - segment_length)\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating segment\n    candidate = new_solution.copy()\n    segment = candidate[start:end]\n    candidate = np.concatenate([candidate[:start], candidate[end:]])\n    if insert_pos == 0:\n        candidate = np.concatenate([segment, candidate])\n    else:\n        candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by rotating segments of the tour in a way that maintains tour validity and explores diverse trade-offs across objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment rotation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to rotate\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by rotating the segment\n    candidate = new_solution.copy()\n    segment = candidate[start:end]\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    candidate[start:end] = rotated_segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7132212476738016,
            2.982358086109161
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment rotation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to rotate\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by rotating the segment\n    candidate = new_solution.copy()\n    segment = candidate[start:end]\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    candidate[start:end] = rotated_segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt* local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt* heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges (2-opt*)\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7612344166300791,
            2.8331992626190186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt* heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges (2-opt*)\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid multi-objective local search operator that combines 2-opt edge-swaps with node relocations, considering all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid local search: randomly choose between 2-opt swap and node relocation\n    if random.random() < 0.5:\n        # 2-opt edge swap\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n    else:\n        # Node relocation\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        candidate = new_solution.copy()\n        candidate = np.insert(candidate, i, candidate[j])\n        candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.780253433624993,
            2.809039831161499
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid local search: randomly choose between 2-opt swap and node relocation\n    if random.random() < 0.5:\n        # 2-opt edge swap\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n    else:\n        # Node relocation\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j:\n            j = random.randint(0, n - 1)\n        candidate = new_solution.copy()\n        candidate = np.insert(candidate, i, candidate[j])\n        candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]  # Swap nodes\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.801381060949842,
            3.884421706199646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]  # Swap nodes\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{This heuristic selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 3-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential considering all three objectives\n    objective_weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_sums = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt heuristic\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select three random edges to reconnect\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[m], sol[m+1]] for m in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[m], sol[m+1]] for m in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[m], sol[m+1]] for m in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]  # Reverse segment between i and j\n    candidate[j:k] = candidate[j:k][::-1]  # Reverse segment between j and k\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7813241923041689,
            4.109199965000153
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential considering all three objectives\n    objective_weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_sums = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt heuristic\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select three random edges to reconnect\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[m], sol[m+1]] for m in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[m], sol[m+1]] for m in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[m], sol[m+1]] for m in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]  # Reverse segment between i and j\n    candidate[j:k] = candidate[j:k][::-1]  # Reverse segment between j and k\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a hybrid local search operator that combines edge swaps and 2-opt moves, considering all three objectives simultaneously to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection weights based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    diversity_weights = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    improvement_weights = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_weight = sum(diversity_weights) + sum(improvement_weights)\n    selection_probs = [(d + i) / total_weight for d, i in zip(diversity_weights, improvement_weights)]\n\n    # Randomly select a solution based on combined weights\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random indices for edge swap or 2-opt\n    i = random.randint(0, n - 2)\n    j = random.randint(0, n - 2)\n    while i == j:\n        j = random.randint(0, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Apply either edge swap or 2-opt based on a random choice\n    if random.random() < 0.5:\n        # Edge swap\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n    else:\n        # 2-opt move\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7365451063912606,
            3.8275585055351256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection weights based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    diversity_weights = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    improvement_weights = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_weight = sum(diversity_weights) + sum(improvement_weights)\n    selection_probs = [(d + i) / total_weight for d, i in zip(diversity_weights, improvement_weights)]\n\n    # Randomly select a solution based on combined weights\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random indices for edge swap or 2-opt\n    i = random.randint(0, n - 2)\n    j = random.randint(0, n - 2)\n    while i == j:\n        j = random.randint(0, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Apply either edge swap or 2-opt based on a random choice\n    if random.random() < 0.5:\n        # Edge swap\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n    else:\n        # 2-opt move\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation strategy that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, n - 2)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a random insertion point\n    insert_pos = random.randint(0, n - 1)\n    while insert_pos >= seg_start and insert_pos <= seg_end:\n        insert_pos = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6947748265309233,
            1.960955762863159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, n - 2)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a random insertion point\n    insert_pos = random.randint(0, n - 1)\n    while insert_pos >= seg_start and insert_pos <= seg_end:\n        insert_pos = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a 3-opt local search operator that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    weights = [0.4, 0.3, 0.3]\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    k = random.randint(0, n - 1)\n    while i == j or j == k or k == i:\n        j = random.randint(0, n - 1)\n        k = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]\n    candidate[j:k] = candidate[j:k][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8221239004313408,
            3.6368529558181764
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    weights = [0.4, 0.3, 0.3]\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    k = random.randint(0, n - 1)\n    while i == j or j == k or k == i:\n        j = random.randint(0, n - 1)\n        k = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]\n    candidate[j:k] = candidate[j:k][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Randomly select a segment to relocate\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, n - 1)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Randomly select a new position to insert the segment\n    new_pos = random.randint(0, n - (seg_end - seg_start + 1))\n\n    candidate = new_solution.copy()\n    candidate = np.delete(candidate, range(seg_start, seg_end + 1))\n    candidate = np.insert(candidate, new_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7424212697115847,
            2.903475451469421
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Randomly select a segment to relocate\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, n - 1)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Randomly select a new position to insert the segment\n    new_pos = random.randint(0, n - (seg_end - seg_start + 1))\n\n    candidate = new_solution.copy()\n    candidate = np.delete(candidate, range(seg_start, seg_end + 1))\n    candidate = np.insert(candidate, new_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and their derivatives, then applies a multi-objective 2-opt local search that simultaneously considers the three distance matrices to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = random.sample(range(n), 2)\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7313770450614834,
            3.4212806105613707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = random.sample(range(n), 2)\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective 2-opt* local search operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on selection probabilities\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective 2-opt* heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select four random nodes to create two edges\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Generate candidate solution by reconnecting edges (2-opt* move)\n    candidate = new_solution.copy()\n    candidate[a:b+1] = new_solution[a:b+1][::-1]\n    candidate[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7842503865573518,
            2.8351557731628416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on selection probabilities\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective 2-opt* heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select four random nodes to create two edges\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Generate candidate solution by reconnecting edges (2-opt* move)\n    candidate = new_solution.copy()\n    candidate[a:b+1] = new_solution[a:b+1][::-1]\n    candidate[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid multi-objective 2-opt and node swap heuristic that considers the three distance matrices simultaneously, while ensuring feasibility by carefully validating all potential moves and maintaining the tour's validity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid heuristic: 2-opt with node swap\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # First, perform a 2-opt move\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Then, perform a node swap\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    while k == l:\n        l = random.randint(0, n - 1)\n    candidate[k], candidate[l] = candidate[l], candidate[k]\n\n    # Check feasibility and improvement\n    if len(np.unique(candidate)) == n:  # Ensure no duplicates\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7141236338732078,
            3.173164701461792
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid heuristic: 2-opt with node swap\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # First, perform a 2-opt move\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Then, perform a node swap\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    while k == l:\n        l = random.randint(0, n - 1)\n    candidate[k], candidate[l] = candidate[l], candidate[k]\n\n    # Check feasibility and improvement\n    if len(np.unique(candidate)) == n:  # Ensure no duplicates\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, n - 1)\n    while k in [i, j, (i + 1) % n, (j + 1) % n]:\n        k = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8302573013516014,
            3.0501066565513613
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, n - 1)\n    while k in [i, j, (i + 1) % n, (j + 1) % n]:\n        k = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and their diversity, then applies a multi-objective 2-opt local search that considers all three distance matrices simultaneously to generate an improved neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted objective score (prioritize solutions with lower objectives)\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    objective_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in objective_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted objective scores\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7549918342858701,
            3.2349050521850584
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted objective score (prioritize solutions with lower objectives)\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    objective_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in objective_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted objective scores\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted combination of objective values and spatial diversity, then applies a multi-objective 2-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    weights = [0.4, 0.3, 0.3]\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8085193932417265,
            3.0712854981422426
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    weights = [0.4, 0.3, 0.3]\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation and inversion operator that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility and potentially improving multiple objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment to relocate and potentially invert\n    segment_start = random.randint(0, n - 4)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n    segment_end = segment_start + segment_length\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n - segment_length)\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate by relocating the segment\n    candidate = new_solution.copy()\n    segment = candidate[segment_start:segment_end]\n\n    # With 50% probability, invert the segment\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    candidate = np.concatenate([\n        candidate[:segment_start],\n        candidate[segment_end:new_pos],\n        segment,\n        candidate[new_pos:]\n    ])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6727006062389833,
            1.8500903725624085
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment to relocate and potentially invert\n    segment_start = random.randint(0, n - 4)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n    segment_end = segment_start + segment_length\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n - segment_length)\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate by relocating the segment\n    candidate = new_solution.copy()\n    segment = candidate[segment_start:segment_end]\n\n    # With 50% probability, invert the segment\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    candidate = np.concatenate([\n        candidate[:segment_start],\n        candidate[segment_end:new_pos],\n        segment,\n        candidate[new_pos:]\n    ])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of crowding distance and objective diversity, then applies a multi-objective 2-opt* local search operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(3):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n\n        # Assign infinite crowding to boundary solutions\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        # Calculate crowding for intermediate solutions\n        range_obj = sorted_obj[-1] - sorted_obj[0]\n        if range_obj == 0:\n            continue\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / range_obj\n\n    # Select solution with highest crowding distance (most diverse)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # 2-opt* local search with multi-objective consideration\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try multiple 2-opt* moves to find the best improvement\n    best_improvement = 0\n    best_candidate = None\n\n    for _ in range(min(10, n*(n-1)//2)):  # Limit iterations\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) < 2:\n            continue\n\n        if i > j:\n            i, j = j, i\n\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]  # Reverse the segment\n\n        candidate_cost = calculate_cost(candidate)\n        improvement = sum((curr - c) for c, curr in zip(candidate_cost, current_cost) if c < curr)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.4218524655417868,
            4.091092669963837
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(3):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n\n        # Assign infinite crowding to boundary solutions\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        # Calculate crowding for intermediate solutions\n        range_obj = sorted_obj[-1] - sorted_obj[0]\n        if range_obj == 0:\n            continue\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / range_obj\n\n    # Select solution with highest crowding distance (most diverse)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # 2-opt* local search with multi-objective consideration\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try multiple 2-opt* moves to find the best improvement\n    best_improvement = 0\n    best_candidate = None\n\n    for _ in range(min(10, n*(n-1)//2)):  # Limit iterations\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) < 2:\n            continue\n\n        if i > j:\n            i, j = j, i\n\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]  # Reverse the segment\n\n        candidate_cost = calculate_cost(candidate)\n        improvement = sum((curr - c) for c, curr in zip(candidate_cost, current_cost) if c < curr)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility, by strategically moving segments of the tour to potentially better positions across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    if not archive_solutions:\n        return np.array([])\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment relocation heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Try to insert the segment in a different position\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        new_pos = random.randint(0, n - segment_length)\n        if new_pos >= start and new_pos <= start + segment_length - 1:\n            continue  # Skip if the segment would be inserted in its original position\n\n        candidate = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:start],\n            new_solution[start+segment_length:]\n        ])\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7931252123891792,
            1.5524226784706117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    if not archive_solutions:\n        return np.array([])\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment relocation heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Try to insert the segment in a different position\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        new_pos = random.randint(0, n - segment_length)\n        if new_pos >= start and new_pos <= start + segment_length - 1:\n            continue  # Skip if the segment would be inserted in its original position\n\n        candidate = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:start],\n            new_solution[start+segment_length:]\n        ])\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility, by strategically moving segments of the tour to potentially better positions across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    if not archive_solutions:\n        return np.array([])\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment relocation heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Try to insert the segment in a different position\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        new_pos = random.randint(0, n - segment_length)\n        if new_pos >= start and new_pos <= start + segment_length - 1:\n            continue  # Skip if the segment would be inserted in its original position\n\n        candidate = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:start],\n            new_solution[start+segment_length:]\n        ])\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7931252123891792,
            1.5524226784706117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    if not archive_solutions:\n        return np.array([])\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment relocation heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Try to insert the segment in a different position\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        new_pos = random.randint(0, n - segment_length)\n        if new_pos >= start and new_pos <= start + segment_length - 1:\n            continue  # Skip if the segment would be inserted in its original position\n\n        candidate = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:start],\n            new_solution[start+segment_length:]\n        ])\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective path relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j or abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    if i < j:\n        segment = candidate[i:j]\n        candidate = np.concatenate([candidate[:i], candidate[j:], segment])\n    else:\n        segment = candidate[j:i]\n        candidate = np.concatenate([candidate[:j], candidate[i:], segment])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7190406813943494,
            2.51310156583786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j or abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    if i < j:\n        segment = candidate[i:j]\n        candidate = np.concatenate([candidate[:i], candidate[j:], segment])\n    else:\n        segment = candidate[j:i]\n        candidate = np.concatenate([candidate[:j], candidate[i:], segment])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or (i + 1) % n == j or (j + 1) % n == i:\n        j = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    if i < j:\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n    else:\n        candidate[i:] = candidate[i:][::-1]\n        candidate[:j+1] = candidate[:j+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8020521193715121,
            2.8988900542259217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or (i + 1) % n == j or (j + 1) % n == i:\n        j = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    if i < j:\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n    else:\n        candidate[i:] = candidate[i:][::-1]\n        candidate[:j+1] = candidate[:j+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (combining diversity and objective values)\n    objective_weights = [0.4, 0.3, 0.3]  # Weighted importance of each objective\n    weighted_sums = [sum(obj[i] * weight for i, weight in enumerate(objective_weights)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7665045235004899,
            3.1251992702484133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (combining diversity and objective values)\n    objective_weights = [0.4, 0.3, 0.3]  # Weighted importance of each objective\n    weighted_sums = [sum(obj[i] * weight for i, weight in enumerate(objective_weights)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and edge diversity, then applies a multi-objective 2-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted scores (higher weight for solutions with better objective values)\n    weights = [1.0 / (sum(obj) + 1e-6) for obj in archive_objectives]\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights]\n\n    # Randomly select a solution based on weighted scores\n    selected_idx = np.random.choice(len(archive_solutions), p=weights)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7710570478944254,
            2.7265602231025694
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted scores (higher weight for solutions with better objective values)\n    weights = [1.0 / (sum(obj) + 1e-6) for obj in archive_objectives]\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights]\n\n    # Randomly select a solution based on weighted scores\n    selected_idx = np.random.choice(len(archive_solutions), p=weights)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective 3-opt heuristic that simultaneously optimizes all three objectives by considering the combined effect of three edge swaps while ensuring feasibility through careful segment selection and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three distinct positions for 3-opt operation\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Generate candidate solution by performing 3-opt operation\n    candidate = new_solution.copy()\n    candidate[a:b+1] = candidate[a:b+1][::-1]\n    candidate[b:c+1] = candidate[b:c+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7099745799688397,
            3.1178377270698547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three distinct positions for 3-opt operation\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Generate candidate solution by performing 3-opt operation\n    candidate = new_solution.copy()\n    candidate[a:b+1] = candidate[a:b+1][::-1]\n    candidate[b:c+1] = candidate[b:c+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by intelligently relocating a segment of the tour to a new position without violating TSP constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.delete(candidate, slice(i, j+1))\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7586168041156098,
            3.0151758551597596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.delete(candidate, slice(i, j+1))\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by relocating a segment between two randomly selected nodes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    while b == a or abs(b - a) < 2:\n        b = random.randint(0, n - 1)\n\n    if a > b:\n        a, b = b, a\n\n    candidate = new_solution.copy()\n    segment = candidate[a:b]\n    candidate = np.concatenate([candidate[:a], candidate[b:]])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7580090424133715,
            3.4222723841667175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    while b == a or abs(b - a) < 2:\n        b = random.randint(0, n - 1)\n\n    if a > b:\n        a, b = b, a\n\n    candidate = new_solution.copy()\n    segment = candidate[a:b]\n    candidate = np.concatenate([candidate[:a], candidate[b:]])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 3-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential using a weighted combination of objectives\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt local search\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select three random edges to reconnect (ensuring feasibility)\n    a, b, c = sorted(random.sample(range(n), 3))\n    if b - a <= 1 or c - b <= 1 or n - c + a <= 1:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solutions by reconnecting the edges\n    candidates = []\n    # Option 1: Reconnect a-b, b-c, c-a to a-c, b-a, a-b\n    candidate1 = new_solution.copy()\n    candidate1[a:b+1] = candidate1[a:b+1][::-1]\n    candidate1[b:c+1] = candidate1[b:c+1][::-1]\n    candidates.append(candidate1)\n\n    # Option 2: Reconnect a-b, b-c, c-a to a-b, c-a, b-c\n    candidate2 = new_solution.copy()\n    candidate2[b:c+1] = candidate2[b:c+1][::-1]\n    candidates.append(candidate2)\n\n    # Option 3: Reconnect a-b, b-c, c-a to a-c, b-a, c-b\n    candidate3 = new_solution.copy()\n    candidate3[a:b+1] = candidate3[a:b+1][::-1]\n    candidate3[a:c+1] = candidate3[a:c+1][::-1]\n    candidates.append(candidate3)\n\n    # Evaluate all candidates and select the best one\n    for candidate in candidates:\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7541096201340746,
            3.289875566959381
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential using a weighted combination of objectives\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt local search\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select three random edges to reconnect (ensuring feasibility)\n    a, b, c = sorted(random.sample(range(n), 3))\n    if b - a <= 1 or c - b <= 1 or n - c + a <= 1:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solutions by reconnecting the edges\n    candidates = []\n    # Option 1: Reconnect a-b, b-c, c-a to a-c, b-a, a-b\n    candidate1 = new_solution.copy()\n    candidate1[a:b+1] = candidate1[a:b+1][::-1]\n    candidate1[b:c+1] = candidate1[b:c+1][::-1]\n    candidates.append(candidate1)\n\n    # Option 2: Reconnect a-b, b-c, c-a to a-b, c-a, b-c\n    candidate2 = new_solution.copy()\n    candidate2[b:c+1] = candidate2[b:c+1][::-1]\n    candidates.append(candidate2)\n\n    # Option 3: Reconnect a-b, b-c, c-a to a-c, b-a, c-b\n    candidate3 = new_solution.copy()\n    candidate3[a:b+1] = candidate3[a:b+1][::-1]\n    candidate3[a:c+1] = candidate3[a:c+1][::-1]\n    candidates.append(candidate3)\n\n    # Evaluate all candidates and select the best one\n    for candidate in candidates:\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment relocation heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a segment to relocate\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Find a new position to insert the segment\n    new_pos = random.randint(0, n - segment_length)\n    while new_pos >= start and new_pos <= start + segment_length - 1:\n        new_pos = random.randint(0, n - segment_length)\n\n    # Create candidate solution\n    candidate = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_length:],\n        segment\n    ])\n\n    # Insert the segment at the new position\n    if new_pos > start:\n        new_pos -= segment_length\n\n    candidate = np.insert(candidate, new_pos, segment)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6883166470514489,
            2.53325115442276
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment relocation heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a segment to relocate\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Find a new position to insert the segment\n    new_pos = random.randint(0, n - segment_length)\n    while new_pos >= start and new_pos <= start + segment_length - 1:\n        new_pos = random.randint(0, n - segment_length)\n\n    # Create candidate solution\n    candidate = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_length:],\n        segment\n    ])\n\n    # Insert the segment at the new position\n    if new_pos > start:\n        new_pos -= segment_length\n\n    candidate = np.insert(candidate, new_pos, segment)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by moving a random segment of the tour to a new position.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 2)\n    seg_end = random.randint(seg_start + 1, n - 1)\n    segment = new_solution[seg_start:seg_end]\n\n    # Remove the segment\n    candidate = np.delete(new_solution, range(seg_start, seg_end))\n\n    # Insert the segment at a random new position\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7594813114420257,
            3.0023505210876467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 2)\n    seg_end = random.randint(seg_start + 1, n - 1)\n    segment = new_solution[seg_start:seg_end]\n\n    # Remove the segment\n    candidate = np.delete(new_solution, range(seg_start, seg_end))\n\n    # Insert the segment at a random new position\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (normalized objectives)\n    max_obj = np.max([np.max(archive_objectives, axis=0)], axis=0)\n    normalized_obj = np.array(archive_objectives) / (max_obj + 1e-6)\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_scores = np.dot(normalized_obj, weights)\n    selection_probs = weighted_scores / np.sum(weighted_scores)\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7910626188419291,
            2.8816667675971983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (normalized objectives)\n    max_obj = np.max([np.max(archive_objectives, axis=0)], axis=0)\n    normalized_obj = np.array(archive_objectives) / (max_obj + 1e-6)\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_scores = np.dot(normalized_obj, weights)\n    selection_probs = weighted_scores / np.sum(weighted_scores)\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This heuristic selects a solution from the archive based on objective diversity and applies a multi-objective 2-opt* local search operator that considers all three distance matrices simultaneously, prioritizing segments that show potential for improvement in multiple objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate diversity scores (standard deviation of objectives)\n    diversity_scores = []\n    for i in range(3):\n        obj_values = [obj[i] for obj in archive_objectives]\n        diversity_scores.append(np.std(obj_values))\n\n    # Select solution with highest diversity\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt* local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try to find an improving 2-opt* move\n    improved = False\n    for i in range(n):\n        for j in range(i+2, n):\n            # Create candidate solution\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n\n            # Check if candidate is better in at least two objectives\n            candidate_cost = calculate_cost(candidate)\n            improvements = sum(1 for c, curr in zip(candidate_cost, current_cost) if c < curr)\n\n            if improvements >= 2:\n                new_solution = candidate\n                improved = True\n                break\n        if improved:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6517006522474357,
            3.6424869537353515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate diversity scores (standard deviation of objectives)\n    diversity_scores = []\n    for i in range(3):\n        obj_values = [obj[i] for obj in archive_objectives]\n        diversity_scores.append(np.std(obj_values))\n\n    # Select solution with highest diversity\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt* local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try to find an improving 2-opt* move\n    improved = False\n    for i in range(n):\n        for j in range(i+2, n):\n            # Create candidate solution\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n\n            # Check if candidate is better in at least two objectives\n            candidate_cost = calculate_cost(candidate)\n            improvements = sum(1 for c, curr in zip(candidate_cost, current_cost) if c < curr)\n\n            if improvements >= 2:\n                new_solution = candidate\n                improved = True\n                break\n        if improved:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7620371748780024,
            2.7654592633247375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers all three objectives simultaneously, ensuring feasibility by carefully relocating a segment of the tour to a new position while maintaining tour validity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Select a new position to insert the segment\n    k = random.randint(0, n - 1)\n    while k >= i and k <= j:\n        k = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    if k == 0:\n        candidate = np.concatenate([segment, candidate])\n    else:\n        candidate = np.concatenate([candidate[:k], segment, candidate[k:]])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8199001925169045,
            2.655721068382263
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Select a new position to insert the segment\n    k = random.randint(0, n - 1)\n    while k >= i and k <= j:\n        k = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    if k == 0:\n        candidate = np.concatenate([segment, candidate])\n    else:\n        candidate = np.concatenate([candidate[:k], segment, candidate[k:]])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a segment to rotate\n    segment_length = random.randint(2, min(5, n // 2))\n    start_idx = random.randint(0, n - segment_length)\n\n    # Rotate the segment\n    segment = new_solution[start_idx:start_idx + segment_length]\n    rotation = random.randint(1, len(segment) - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    candidate = new_solution.copy()\n    candidate[start_idx:start_idx + segment_length] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.76687814025733,
            3.1145156741142275
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a segment to rotate\n    segment_length = random.randint(2, min(5, n // 2))\n    start_idx = random.randint(0, n - segment_length)\n\n    # Rotate the segment\n    segment = new_solution[start_idx:start_idx + segment_length]\n    rotation = random.randint(1, len(segment) - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    candidate = new_solution.copy()\n    candidate[start_idx:start_idx + segment_length] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment reversal operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    while a == b:\n        b = random.randint(0, n - 1)\n\n    start, end = min(a, b), max(a, b)\n    candidate = new_solution.copy()\n    candidate[start:end+1] = candidate[start:end+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7576782830064029,
            2.6745995044708253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    while a == b:\n        b = random.randint(0, n - 1)\n\n    start, end = min(a, b), max(a, b)\n    candidate = new_solution.copy()\n    candidate[start:end+1] = candidate[start:end+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three random positions to rotate a segment\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, n - 1)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by rotating a segment\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, k - i)\n    candidate[i:j+1] = rotated_segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.753999411310535,
            3.2040282130241393
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three random positions to rotate a segment\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, n - 1)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by rotating a segment\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, k - i)\n    candidate[i:j+1] = rotated_segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7587205984678504,
            2.5758689761161806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(i + 1, j - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, k - i)\n\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7956824112488503,
            2.7273134350776673
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(i + 1, j - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, k - i)\n\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt* heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by performing a more extensive segment reversal that can involve multiple non-adjacent edges.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    if i > j:\n        i, j = j, i\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8274523097763626,
            2.739259397983551
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    if i > j:\n        i, j = j, i\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7331712805362648,
            2.7130381584167482
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search operator that combines 2-opt and node insertion moves to generate a neighbor solution while considering the three distance matrices simultaneously to ensure feasibility and multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Apply 2-opt move\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if all(c <= curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n        return new_solution\n\n    # Apply node insertion move if 2-opt didn't improve\n    i, j = random.sample(range(n), 2)\n    while i == j:\n        j = random.sample(range(n), 1)[0]\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7634320642253445,
            3.284909176826477
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Apply 2-opt move\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if all(c <= curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n        return new_solution\n\n    # Apply node insertion move if 2-opt didn't improve\n    i, j = random.sample(range(n), 2)\n    while i == j:\n        j = random.sample(range(n), 1)[0]\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by carefully validating the insertion points.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective node insertion heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select a random node to relocate\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by inserting the node in a new position\n    candidate = new_solution.copy()\n    candidate = np.delete(candidate, node_idx)\n    insert_pos = random.randint(0, n - 2)\n    candidate = np.insert(candidate, insert_pos, node)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8054330336268917,
            3.3463467001914977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective node insertion heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select a random node to relocate\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by inserting the node in a new position\n    candidate = new_solution.copy()\n    candidate = np.delete(candidate, node_idx)\n    insert_pos = random.randint(0, n - 2)\n    candidate = np.insert(candidate, insert_pos, node)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (diversity-aware selection)\n    objective_weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_sums = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7257349666928046,
            3.554731917381287
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (diversity-aware selection)\n    objective_weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_sums = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all three objectives)\n    objective_weights = [0.4, 0.3, 0.3]  # Weighted more on the first objective\n    weighted_sums = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8026913302731868,
            3.647811162471771
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all three objectives)\n    objective_weights = [0.4, 0.3, 0.3]  # Weighted more on the first objective\n    weighted_sums = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective path reversal with segment insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to reverse and insert elsewhere\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 2, n - 1)\n\n    # Generate candidate solution by reversing segment and inserting\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1][::-1]\n    candidate = np.delete(candidate, np.s_[i:j+1])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7825144442997323,
            3.0012658834457397
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to reverse and insert elsewhere\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 2, n - 1)\n\n    # Generate candidate solution by reversing segment and inserting\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1][::-1]\n    candidate = np.delete(candidate, np.s_[i:j+1])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Segment rotation heuristic\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(1, j - i - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.824589644137669,
            3.0138833284378053
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Segment rotation heuristic\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(1, j - i - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7555119545595975,
            3.009714698791504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{This new algorithm selects a solution from the archive based on the diversity of its objectives, then applies a multi-objective 2-opt* local search that considers all three objectives simultaneously, ensuring feasibility and potentially improving at least one objective while maintaining non-dominated status.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate objective diversity (standard deviation across objectives)\n    obj1 = [obj[0] for obj in archive_objectives]\n    obj2 = [obj[1] for obj in archive_objectives]\n    obj3 = [obj[2] for obj in archive_objectives]\n\n    std1 = np.std(obj1)\n    std2 = np.std(obj2)\n    std3 = np.std(obj3)\n    diversity_scores = [std1 + std2 + std3]\n\n    # Select solution with highest diversity (or random if all equal)\n    if all(d == 0 for d in diversity_scores):\n        selected_idx = random.randint(0, len(archive_solutions) - 1)\n    else:\n        max_diversity = max(diversity_scores)\n        candidates = [i for i, d in enumerate(diversity_scores) if d == max_diversity]\n        selected_idx = random.choice(candidates)\n\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective 2-opt* local search\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try multiple random 2-opt* moves\n    for _ in range(5):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[j:i-1 if i > 0 else None:-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n",
        "score": [
            -0.7737723541466967,
            2.513134407997131
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate objective diversity (standard deviation across objectives)\n    obj1 = [obj[0] for obj in archive_objectives]\n    obj2 = [obj[1] for obj in archive_objectives]\n    obj3 = [obj[2] for obj in archive_objectives]\n\n    std1 = np.std(obj1)\n    std2 = np.std(obj2)\n    std3 = np.std(obj3)\n    diversity_scores = [std1 + std2 + std3]\n\n    # Select solution with highest diversity (or random if all equal)\n    if all(d == 0 for d in diversity_scores):\n        selected_idx = random.randint(0, len(archive_solutions) - 1)\n    else:\n        max_diversity = max(diversity_scores)\n        candidates = [i for i, d in enumerate(diversity_scores) if d == max_diversity]\n        selected_idx = random.choice(candidates)\n\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective 2-opt* local search\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try multiple random 2-opt* moves\n    for _ in range(5):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[j:i-1 if i > 0 else None:-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by rotating a randomly selected segment of the tour and checking for Pareto dominance in all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7951347256157439,
            2.7441643834114076
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously, ensuring feasibility by intelligently relocating segments of the tour while maintaining connectivity and node uniqueness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment to relocate\n    seg_start = random.randint(0, n - 4)\n    seg_length = random.randint(2, min(5, n - seg_start - 1))\n    seg_end = seg_start + seg_length\n\n    # Select a new position to insert the segment\n    insert_pos = random.randint(0, n - seg_length - 1)\n    while insert_pos >= seg_start and insert_pos < seg_end:\n        insert_pos = random.randint(0, n - seg_length - 1)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating segment\n    candidate = new_solution.copy()\n    segment = candidate[seg_start:seg_end]\n    candidate = np.concatenate([candidate[:seg_start], candidate[seg_end:]])\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7779230363548159,
            3.1891611218452454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment to relocate\n    seg_start = random.randint(0, n - 4)\n    seg_length = random.randint(2, min(5, n - seg_start - 1))\n    seg_end = seg_start + seg_length\n\n    # Select a new position to insert the segment\n    insert_pos = random.randint(0, n - seg_length - 1)\n    while insert_pos >= seg_start and insert_pos < seg_end:\n        insert_pos = random.randint(0, n - seg_length - 1)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating segment\n    candidate = new_solution.copy()\n    segment = candidate[seg_start:seg_end]\n    candidate = np.concatenate([candidate[:seg_start], candidate[seg_end:]])\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7896601598120763,
            2.677841818332672
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random nodes to swap (ensuring feasibility)\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping nodes\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7915074064840947,
            2.9759759187698362
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random nodes to swap (ensuring feasibility)\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping nodes\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential\n    weights = [0.3, 0.3, 0.4]  # Higher weight for the third objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7876882617364461,
            3.1485833048820497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential\n    weights = [0.3, 0.3, 0.4]  # Higher weight for the third objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, where weights are inversely proportional to the current objective values, then applies a multi-objective 2-opt local search that simultaneously considers all three distance matrices to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    weights = [1.0 / (obj[0] + 1e-6) + 1.0 / (obj[1] + 1e-6) + 1.0 / (obj[2] + 1e-6) for obj in archive_objectives]\n    total_weight = sum(weights)\n    selection_probs = [w / total_weight for w in weights]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.764646712831622,
            3.1227654099464415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    weights = [1.0 / (obj[0] + 1e-6) + 1.0 / (obj[1] + 1e-6) + 1.0 / (obj[2] + 1e-6) for obj in archive_objectives]\n    total_weight = sum(weights)\n    selection_probs = [w / total_weight for w in weights]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt heuristic with a novel segment insertion strategy that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt with segment insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random segments to insert\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by inserting segment\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6932109572667681,
            1.6648859620094298
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt with segment insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random segments to insert\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by inserting segment\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel three-objective path relocation operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select a random segment to relocate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate by relocating the segment\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8097116079512288,
            3.103750538825989
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select a random segment to relocate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate by relocating the segment\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective improvements and diversity, then applies a multi-objective 3-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential\n    weights = [0.4, 0.3, 0.3]  # Higher weight for the primary objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective 3-opt local search\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three random edges to reconnect\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n    candidate[j:k+1] = candidate[j:k+1][::-1]  # Reverse another segment\n\n    candidate_cost = calculate_cost(candidate)\n\n    # Accept if better in at least one objective with a small tolerance\n    if any(c < curr * 1.02 for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7508334277098724,
            3.22148334980011
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential\n    weights = [0.4, 0.3, 0.3]  # Higher weight for the primary objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective 3-opt local search\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three random edges to reconnect\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n    candidate[j:k+1] = candidate[j:k+1][::-1]  # Reverse another segment\n\n    candidate_cost = calculate_cost(candidate)\n\n    # Accept if better in at least one objective with a small tolerance\n    if any(c < curr * 1.02 for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation operator that considers the three distance matrices simultaneously, ensuring feasibility by always relocating segments while maintaining valid TSP tours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 4)\n    seg_end = random.randint(seg_start + 2, n - 2)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n - len(segment))\n\n    # Remove the segment and insert it at the new position\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:],\n        segment\n    ])\n\n    # Insert the segment at the new position\n    candidate = np.concatenate([\n        candidate[:new_pos],\n        segment,\n        candidate[new_pos:]\n    ])\n\n    # Verify the solution remains valid (no duplicates)\n    if len(np.unique(candidate)) == n:\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.699679353962122,
            0.7773993015289307
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 4)\n    seg_end = random.randint(seg_start + 2, n - 2)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n - len(segment))\n\n    # Remove the segment and insert it at the new position\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:],\n        segment\n    ])\n\n    # Insert the segment at the new position\n    candidate = np.concatenate([\n        candidate[:new_pos],\n        segment,\n        candidate[new_pos:]\n    ])\n\n    # Verify the solution remains valid (no duplicates)\n    if len(np.unique(candidate)) == n:\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation operator that considers the three distance matrices simultaneously, ensuring feasibility by always relocating segments while maintaining valid TSP tours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 4)\n    seg_end = random.randint(seg_start + 2, n - 2)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n - len(segment))\n\n    # Remove the segment and insert it at the new position\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:],\n        segment\n    ])\n\n    # Insert the segment at the new position\n    candidate = np.concatenate([\n        candidate[:new_pos],\n        segment,\n        candidate[new_pos:]\n    ])\n\n    # Verify the solution remains valid (no duplicates)\n    if len(np.unique(candidate)) == n:\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.699679353962122,
            0.7773993015289307
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 4)\n    seg_end = random.randint(seg_start + 2, n - 2)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n - len(segment))\n\n    # Remove the segment and insert it at the new position\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:],\n        segment\n    ])\n\n    # Insert the segment at the new position\n    candidate = np.concatenate([\n        candidate[:new_pos],\n        segment,\n        candidate[new_pos:]\n    ])\n\n    # Verify the solution remains valid (no duplicates)\n    if len(np.unique(candidate)) == n:\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective diversity and solution quality, then applies a multi-objective 2-opt heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential considering all three objectives\n    objective_weights = [0.4, 0.3, 0.3]  # Custom weights for each objective\n    weighted_sums = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(0, n - 2)\n    if i == j:\n        j = (j + 1) % n\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8435634789770738,
            3.739787793159485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential considering all three objectives\n    objective_weights = [0.4, 0.3, 0.3]  # Custom weights for each objective\n    weighted_sums = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(0, n - 2)\n    if i == j:\n        j = (j + 1) % n\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation strategy that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    segment_start = random.randint(0, n - 4)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n    segment_end = segment_start + segment_length\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n - segment_length - 1)\n    while new_pos >= segment_start and new_pos < segment_end:\n        new_pos = random.randint(0, n - segment_length - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    segment = candidate[segment_start:segment_end]\n    candidate = np.concatenate([candidate[:segment_start], candidate[segment_end:]])\n    candidate = np.insert(candidate, new_pos, segment)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7133065911142902,
            2.9232943534851072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    segment_start = random.randint(0, n - 4)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n    segment_end = segment_start + segment_length\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n - segment_length - 1)\n    while new_pos >= segment_start and new_pos < segment_end:\n        new_pos = random.randint(0, n - segment_length - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    segment = candidate[segment_start:segment_end]\n    candidate = np.concatenate([candidate[:segment_start], candidate[segment_end:]])\n    candidate = np.insert(candidate, new_pos, segment)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by rotating a randomly selected segment of the tour in a direction that improves at least one objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Generate candidate solutions by rotating the segment in both directions\n    candidates = []\n    for direction in [1, -1]:  # 1 for clockwise, -1 for counter-clockwise\n        candidate = new_solution.copy()\n        segment = candidate[i:j+1]\n        rotated_segment = np.roll(segment, direction)\n        candidate[i:j+1] = rotated_segment\n        candidates.append(candidate)\n\n    # Evaluate candidates and select the best one\n    best_candidate = new_solution\n    best_cost = current_cost\n\n    for candidate in candidates:\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            best_candidate = candidate\n            best_cost = candidate_cost\n\n    return best_candidate\n\n",
        "score": [
            -0.8321254656938473,
            2.8667800545692446
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Generate candidate solutions by rotating the segment in both directions\n    candidates = []\n    for direction in [1, -1]:  # 1 for clockwise, -1 for counter-clockwise\n        candidate = new_solution.copy()\n        segment = candidate[i:j+1]\n        rotated_segment = np.roll(segment, direction)\n        candidate[i:j+1] = rotated_segment\n        candidates.append(candidate)\n\n    # Evaluate candidates and select the best one\n    best_candidate = new_solution\n    best_cost = current_cost\n\n    for candidate in candidates:\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            best_candidate = candidate\n            best_cost = candidate_cost\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (2-opt move)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current cost for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges (2-opt move)\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7294019441305355,
            2.784997248649597
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (2-opt move)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current cost for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges (2-opt move)\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility, by moving a random segment of nodes to a different position in the tour while optimizing for all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 4)\n    seg_end = random.randint(seg_start + 2, n - 2)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a new position to insert the segment\n    insert_pos = random.randint(0, n - 1)\n    while insert_pos >= seg_start and insert_pos <= seg_end:\n        insert_pos = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:seg_start], candidate[seg_end+1:]])\n    if insert_pos < len(candidate):\n        candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n    else:\n        candidate = np.concatenate([candidate, segment])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.730130514172471,
            2.646840679645538
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 4)\n    seg_end = random.randint(seg_start + 2, n - 2)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a new position to insert the segment\n    insert_pos = random.randint(0, n - 1)\n    while insert_pos >= seg_start and insert_pos <= seg_end:\n        insert_pos = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:seg_start], candidate[seg_end+1:]])\n    if insert_pos < len(candidate):\n        candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n    else:\n        candidate = np.concatenate([candidate, segment])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective node insertion heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select a random node to remove\n    remove_pos = random.randint(0, n - 1)\n    removed_node = new_solution[remove_pos]\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by inserting the removed node in a new position\n    candidate = np.delete(new_solution, remove_pos)\n    insert_pos = random.randint(0, n - 2)\n    candidate = np.insert(candidate, insert_pos, removed_node)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8055509434587498,
            2.6610252141952513
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective node insertion heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select a random node to remove\n    remove_pos = random.randint(0, n - 1)\n    removed_node = new_solution[remove_pos]\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by inserting the removed node in a new position\n    candidate = np.delete(new_solution, remove_pos)\n    insert_pos = random.randint(0, n - 2)\n    candidate = np.insert(candidate, insert_pos, removed_node)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt* heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # 2-opt* heuristic: select two random non-adjacent edges and reconnect\n    i = random.randint(0, n - 2)\n    j = random.randint(0, n - 2)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    if i < j:\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n    else:\n        candidate[j:i+1] = candidate[j:i+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7711714221379959,
            2.8222622632980348
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # 2-opt* heuristic: select two random non-adjacent edges and reconnect\n    i = random.randint(0, n - 2)\n    j = random.randint(0, n - 2)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    if i < j:\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n    else:\n        candidate[j:i+1] = candidate[j:i+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7281152799020765,
            2.6669885754585265
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probability based on objective diversity\n    objective_diversity = [max(obj) - min(obj) for obj in archive_objectives]\n    selection_probs = [div + 1e-6 for div in objective_diversity]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on diversity\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # 2-opt local search heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6849765764683962,
            2.785458493232727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probability based on objective diversity\n    objective_diversity = [max(obj) - min(obj) for obj in archive_objectives]\n    selection_probs = [div + 1e-6 for div in objective_diversity]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on diversity\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # 2-opt local search heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility, by randomly relocating a segment of nodes to a new position in the tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, min(start + 5, n - 1))\n    segment = new_solution[start:end+1]\n\n    # Select a new position for the segment\n    new_pos = random.randint(0, n - len(segment))\n    if new_pos >= start and new_pos <= end:\n        return new_solution\n\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:start], candidate[end+1:]])\n    candidate = np.insert(candidate, new_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8160220157240359,
            3.2192166566848757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, min(start + 5, n - 1))\n    segment = new_solution[start:end+1]\n\n    # Select a new position for the segment\n    new_pos = random.randint(0, n - len(segment))\n    if new_pos >= start and new_pos <= end:\n        return new_solution\n\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:start], candidate[end+1:]])\n    candidate = np.insert(candidate, new_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and their diversity, then applies a multi-objective 2-opt local search that simultaneously considers all three distance matrices to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8018866672849099,
            3.4151675581932066
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility, by rotating a randomly selected segment of the tour in a direction that improves at least one objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    candidate = new_solution.copy()\n    direction = random.choice([-1, 1])\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, direction * (j - i) // 2)\n\n    candidate[i:j+1] = rotated_segment\n    candidate_cost = calculate_cost(candidate)\n\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7481746870923753,
            3.070428121089935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    candidate = new_solution.copy()\n    direction = random.choice([-1, 1])\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, direction * (j - i) // 2)\n\n    candidate[i:j+1] = rotated_segment\n    candidate_cost = calculate_cost(candidate)\n\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective 2-opt local search that simultaneously considers all three distance matrices to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6914219399328951,
            2.5918347597122193
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective two-opt swap with weighted objective consideration to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n\n    weighted_improvement = 0\n    for curr, cand, weight in zip(current_cost, candidate_cost, [0.4, 0.3, 0.3]):\n        if cand < curr:\n            weighted_improvement += weight * (curr - cand)\n\n    if weighted_improvement > 0:\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7177916233772637,
            3.2832285165786743
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n\n    weighted_improvement = 0\n    for curr, cand, weight in zip(current_cost, candidate_cost, [0.4, 0.3, 0.3]):\n        if cand < curr:\n            weighted_improvement += weight * (curr - cand)\n\n    if weighted_improvement > 0:\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7018521052317448,
            2.9190457224845887
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt local search that considers all three objectives simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all three objectives)\n    weights = [0.4, 0.3, 0.3]  # Weighting the three objectives\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current cost for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7054449219005228,
            3.3050476193428038
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all three objectives)\n    weights = [0.4, 0.3, 0.3]  # Weighting the three objectives\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current cost for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective 2-opt local search\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try multiple random 2-opt moves\n    for _ in range(min(10, n)):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        # Check if the candidate is better in at least one objective\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n",
        "score": [
            -0.766439607558383,
            3.188895559310913
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective 2-opt local search\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try multiple random 2-opt moves\n    for _ in range(min(10, n)):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        # Check if the candidate is better in at least one objective\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously, ensuring feasibility by relocating entire segments of the tour while maintaining the order of nodes within the segment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, min(start + 2, n - 1))\n    segment = new_solution[start:end+1]\n\n    # Select a new position to insert the segment\n    insert_pos = random.randint(0, n - len(segment))\n    while insert_pos >= start and insert_pos <= end:\n        insert_pos = random.randint(0, n - len(segment))\n\n    # Create candidate solution by relocating the segment\n    candidate = np.concatenate([\n        new_solution[:start],\n        new_solution[end+1:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7027958937554917,
            2.071743333339691
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, min(start + 2, n - 1))\n    segment = new_solution[start:end+1]\n\n    # Select a new position to insert the segment\n    insert_pos = random.randint(0, n - len(segment))\n    while insert_pos >= start and insert_pos <= end:\n        insert_pos = random.randint(0, n - len(segment))\n\n    # Create candidate solution by relocating the segment\n    candidate = np.concatenate([\n        new_solution[:start],\n        new_solution[end+1:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that simultaneously considers all three distance matrices to generate a neighbor solution while ensuring feasibility through a dynamic segment relocation strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    segment_start = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n    segment_end = segment_start + segment_length\n\n    candidate = new_solution.copy()\n    segment = candidate[segment_start:segment_end]\n    candidate = np.delete(candidate, range(segment_start, segment_end))\n\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8104399292164128,
            3.0926588416099547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    segment_start = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n    segment_end = segment_start + segment_length\n\n    candidate = new_solution.copy()\n    segment = candidate[segment_start:segment_end]\n    candidate = np.delete(candidate, range(segment_start, segment_end))\n\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by intelligently relocating a segment of the tour between two random nodes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    start, end = sorted([i, j])\n    segment = new_solution[start:end]\n    candidate = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7418646140300432,
            3.126632368564606
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    start, end = sorted([i, j])\n    segment = new_solution[start:end]\n    candidate = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8346759507023986,
            2.6662267684936523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective 3-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probability based on objective diversity\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three random edges to reconnect (ensuring feasibility)\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[a:b] = candidate[a:b][::-1]  # Reverse segment between a and b\n    candidate[b:c] = candidate[b:c][::-1]  # Reverse segment between b and c\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7180363480512454,
            2.9327911496162415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probability based on objective diversity\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three random edges to reconnect (ensuring feasibility)\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[a:b] = candidate[a:b][::-1]  # Reverse segment between a and b\n    candidate[b:c] = candidate[b:c][::-1]  # Reverse segment between b and c\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a hybrid local search operator that combines 2-opt and node insertion to generate a neighbor solution while maintaining feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    weights = [0.4, 0.3, 0.3]\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while abs(i - j) < 2:\n            j = random.randint(0, n - 1)\n\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        candidate_cost = calculate_cost(candidate)\n        if sum(candidate_cost) < sum(current_cost):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8145633299586915,
            4.34935359954834
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    weights = [0.4, 0.3, 0.3]\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while abs(i - j) < 2:\n            j = random.randint(0, n - 1)\n\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        candidate_cost = calculate_cost(candidate)\n        if sum(candidate_cost) < sum(current_cost):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a multi-objective 2-opt local search that simultaneously considers all three distance matrices to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8262914697331698,
            3.5918442964553834
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8119095191434689,
            2.7210613250732423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{This heuristic selects a solution from the archive based on objective diversity and applies a novel multi-objective segment inversion operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    segment_start = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n\n    candidate = new_solution.copy()\n    candidate[segment_start:segment_start+segment_length] = candidate[segment_start:segment_start+segment_length][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7137581757191316,
            2.917658817768097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    segment_start = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n\n    candidate = new_solution.copy()\n    candidate[segment_start:segment_start+segment_length] = candidate[segment_start:segment_start+segment_length][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt* local search operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by carefully selecting and swapping non-adjacent edges to maintain tour validity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2 or abs(i - j) > n - 2:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7991739988401728,
            3.172957682609558
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2 or abs(i - j) > n - 2:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective path reversal heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.757283908726178,
            2.844328284263611
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7247866403358307,
            2.879909873008728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7903967623967474,
            2.749848246574402
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that simultaneously considers the three distance matrices to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6978477082163913,
            2.6945138812065124
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment reversal operation that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    start, end = min(i, j), max(i, j)\n    candidate = new_solution.copy()\n    candidate[start:end+1] = candidate[start:end+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.744099072714439,
            2.6679233074188233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    start, end = min(i, j), max(i, j)\n    candidate = new_solution.copy()\n    candidate[start:end+1] = candidate[start:end+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously, with a probability-based acceptance criterion to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate diversity score (inverse of normalized objective differences)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    mean_sum = np.mean(objective_sums)\n    diversity_scores = [1.0 / (abs(sum_val - mean_sum) + 1e-6) for sum_val in objective_sums]\n    total_score = sum(diversity_scores)\n    selection_probs = [s / total_score for s in diversity_scores]\n\n    # Randomly select a solution based on diversity\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    candidate_cost = calculate_cost(candidate)\n\n    # Acceptance criterion: accept if better in at least one objective or with probability if not better\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n    else:\n        # Calculate probability based on overall cost improvement\n        total_improvement = sum(curr - c for c, curr in zip(candidate_cost, current_cost))\n        if total_improvement > 0:\n            prob = min(0.3, total_improvement / sum(current_cost))\n            if random.random() < prob:\n                new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7021075391964189,
            2.6419686555862425
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate diversity score (inverse of normalized objective differences)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    mean_sum = np.mean(objective_sums)\n    diversity_scores = [1.0 / (abs(sum_val - mean_sum) + 1e-6) for sum_val in objective_sums]\n    total_score = sum(diversity_scores)\n    selection_probs = [s / total_score for s in diversity_scores]\n\n    # Randomly select a solution based on diversity\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    candidate_cost = calculate_cost(candidate)\n\n    # Acceptance criterion: accept if better in at least one objective or with probability if not better\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n    else:\n        # Calculate probability based on overall cost improvement\n        total_improvement = sum(curr - c for c, curr in zip(candidate_cost, current_cost))\n        if total_improvement > 0:\n            prob = min(0.3, total_improvement / sum(current_cost))\n            if random.random() < prob:\n                new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility, by randomly selecting a segment from one position and relocating it to another position in the tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(0, n - 2)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 2)\n\n    start, end = sorted([i, j])\n    segment = new_solution[start:end+1]\n\n    candidate = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(candidate) - 1)\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.717186289529549,
            3.190189301967621
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(0, n - 2)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 2)\n\n    start, end = sorted([i, j])\n    segment = new_solution[start:end+1]\n\n    candidate = np.concatenate([new_solution[:start], new_solution[end+1:]])\n    insert_pos = random.randint(0, len(candidate) - 1)\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective path reversal heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    start, end = min(i, j), max(i, j)\n    candidate = new_solution.copy()\n    candidate[start:end+1] = candidate[start:end+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7567155632716335,
            2.7072809815406798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    start, end = min(i, j), max(i, j)\n    candidate = new_solution.copy()\n    candidate[start:end+1] = candidate[start:end+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by always maintaining a valid tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    while a == b:\n        b = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[a], candidate[b] = candidate[b], candidate[a]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7737082982946972,
            2.6558626651763917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    while a == b:\n        b = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[a], candidate[b] = candidate[b], candidate[a]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7623613936828602,
            2.811305356025696
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation operator that identifies and relocates promising segments across the three objective spaces simultaneously while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment and a random insertion point\n    segment_length = random.randint(2, min(4, n-2))\n    start_pos = random.randint(0, n - segment_length)\n    end_pos = start_pos + segment_length\n\n    insertion_pos = random.randint(0, n - segment_length)\n    while insertion_pos >= start_pos and insertion_pos <= end_pos:\n        insertion_pos = random.randint(0, n - segment_length)\n\n    # Extract the segment and remove it from the solution\n    segment = new_solution[start_pos:end_pos]\n    remaining = np.concatenate([new_solution[:start_pos], new_solution[end_pos:]])\n\n    # Insert the segment at the new position\n    candidate = np.concatenate([remaining[:insertion_pos], segment, remaining[insertion_pos:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7516013106220061,
            2.9978443145751954
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment and a random insertion point\n    segment_length = random.randint(2, min(4, n-2))\n    start_pos = random.randint(0, n - segment_length)\n    end_pos = start_pos + segment_length\n\n    insertion_pos = random.randint(0, n - segment_length)\n    while insertion_pos >= start_pos and insertion_pos <= end_pos:\n        insertion_pos = random.randint(0, n - segment_length)\n\n    # Extract the segment and remove it from the solution\n    segment = new_solution[start_pos:end_pos]\n    remaining = np.concatenate([new_solution[:start_pos], new_solution[end_pos:]])\n\n    # Insert the segment at the new position\n    candidate = np.concatenate([remaining[:insertion_pos], segment, remaining[insertion_pos:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment reordering heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by dynamically adjusting segment boundaries to maintain tour validity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to reorder\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Generate candidate by reordering the segment\n    candidate = new_solution.copy()\n    segment = candidate[start:end]\n    np.random.shuffle(segment)\n    candidate[start:end] = segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6686431894644282,
            3.285610890388489
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to reorder\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Generate candidate by reordering the segment\n    candidate = new_solution.copy()\n    segment = candidate[start:end]\n    np.random.shuffle(segment)\n    candidate[start:end] = segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a multi-objective edge swap heuristic that simultaneously considers all three distance matrices to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7489720884452964,
            3.690559375286102
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by intelligently relocating a segment of nodes to a new position in the tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n\n    insert_pos = random.randint(0, len(candidate) - 1)\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7604530697373899,
            2.9425667405128477
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n\n    insert_pos = random.randint(0, len(candidate) - 1)\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by intelligently relocating segments of the tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    candidate = new_solution.copy()\n    candidate = np.delete(candidate, slice(start, start+segment_length))\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8336862547604074,
            3.2522468328475953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    candidate = new_solution.copy()\n    candidate = np.delete(candidate, slice(start, start+segment_length))\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a multi-objective 2-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * v for w, v in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = random.sample(range(n), 2)\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7510639471150165,
            3.9623982429504396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * v for w, v in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = random.sample(range(n), 2)\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7238400216926042,
            2.9335813999176024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a multi-objective edge-swapping heuristic that simultaneously considers all three distance matrices to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective sum\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Perform edge swapping\n    i, j = random.sample(range(n), 2)\n    candidate = new_solution.copy()\n\n    # Swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n    candidate[(i+1)%n], candidate[(j+1)%n] = candidate[(j+1)%n], candidate[(i+1)%n]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.808207366216522,
            2.696391534805298
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective sum\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Perform edge swapping\n    i, j = random.sample(range(n), 2)\n    candidate = new_solution.copy()\n\n    # Swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n    candidate[(i+1)%n], candidate[(j+1)%n] = candidate[(j+1)%n], candidate[(i+1)%n]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search operator that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6945980421556895,
            3.205991578102112
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, 1)\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7684575010614345,
            2.98412264585495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, 1)\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all three objectives)\n    weights = [0.4, 0.3, 0.3]  # Weighted importance of each objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7407212782470631,
            3.074271011352539
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all three objectives)\n    weights = [0.4, 0.3, 0.3]  # Weighted importance of each objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{This algorithm selects a solution from the archive based on objective diversity and applies a hybrid 2-opt and node swap heuristic that simultaneously optimizes across all three distance matrices to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if all(c <= curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7645286722109967,
            3.0845652341842653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if all(c <= curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution by rotating a randomly selected segment of the tour in a direction that shows promise for improvement in at least one objective, while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, 1)  # 0 for left rotation, 1 for right rotation\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n\n    if k == 0:\n        rotated_segment = np.roll(segment, -1)\n    else:\n        rotated_segment = np.roll(segment, 1)\n\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7940343128830165,
            2.887125480175018
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, 1)  # 0 for left rotation, 1 for right rotation\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n\n    if k == 0:\n        rotated_segment = np.roll(segment, -1)\n    else:\n        rotated_segment = np.roll(segment, 1)\n\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by moving a randomly selected segment to a new position in the tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    candidate = new_solution.copy()\n    segment = candidate[start:end]\n    candidate = np.concatenate([candidate[:start], candidate[end:]])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8462568297710453,
            3.0203354597091674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    candidate = new_solution.copy()\n    segment = candidate[start:end]\n    candidate = np.concatenate([candidate[:start], candidate[end:]])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a novel multi-objective 3-opt local search that simultaneously considers all three distance matrices to generate an improved neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate normalized objective values\n    obj1 = np.array([obj[0] for obj in archive_objectives])\n    obj2 = np.array([obj[1] for obj in archive_objectives])\n    obj3 = np.array([obj[2] for obj in archive_objectives])\n\n    obj1_norm = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-6)\n    obj2_norm = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-6)\n    obj3_norm = (obj3 - np.min(obj3)) / (np.max(obj3) - np.min(obj3) + 1e-6)\n\n    # Calculate diversity score (sum of normalized objectives)\n    diversity_scores = obj1_norm + obj2_norm + obj3_norm\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # 3-opt local search for multi-objective optimization\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three random edges to reconnect\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Generate candidate solutions by different 3-opt moves\n    candidates = [\n        new_solution.copy(),  # Original\n        np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]]),  # 2-opt\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]]),  # 3-opt\n        np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]]),  # 3-opt variant\n        np.concatenate([new_solution[:i], new_solution[k:], new_solution[j:i-1:-1], new_solution[k+1:j+1], new_solution[i:k]]),  # 3-opt complex\n    ]\n\n    # Evaluate all candidates\n    best_candidate = new_solution.copy()\n    best_cost = current_cost\n    best_improvement = 0\n\n    for candidate in candidates:\n        candidate_cost = calculate_cost(candidate)\n        # Count how many objectives are improved\n        improvement = sum(1 for c, curr in zip(candidate_cost, current_cost) if c < curr)\n        if improvement > best_improvement or (improvement == best_improvement and sum(candidate_cost) < sum(best_cost)):\n            best_improvement = improvement\n            best_cost = candidate_cost\n            best_candidate = candidate.copy()\n\n    return best_candidate\n\n",
        "score": [
            -0.7136118225988678,
            2.015597712993622
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate normalized objective values\n    obj1 = np.array([obj[0] for obj in archive_objectives])\n    obj2 = np.array([obj[1] for obj in archive_objectives])\n    obj3 = np.array([obj[2] for obj in archive_objectives])\n\n    obj1_norm = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-6)\n    obj2_norm = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-6)\n    obj3_norm = (obj3 - np.min(obj3)) / (np.max(obj3) - np.min(obj3) + 1e-6)\n\n    # Calculate diversity score (sum of normalized objectives)\n    diversity_scores = obj1_norm + obj2_norm + obj3_norm\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # 3-opt local search for multi-objective optimization\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three random edges to reconnect\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Generate candidate solutions by different 3-opt moves\n    candidates = [\n        new_solution.copy(),  # Original\n        np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]]),  # 2-opt\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]]),  # 3-opt\n        np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]]),  # 3-opt variant\n        np.concatenate([new_solution[:i], new_solution[k:], new_solution[j:i-1:-1], new_solution[k+1:j+1], new_solution[i:k]]),  # 3-opt complex\n    ]\n\n    # Evaluate all candidates\n    best_candidate = new_solution.copy()\n    best_cost = current_cost\n    best_improvement = 0\n\n    for candidate in candidates:\n        candidate_cost = calculate_cost(candidate)\n        # Count how many objectives are improved\n        improvement = sum(1 for c, curr in zip(candidate_cost, current_cost) if c < curr)\n        if improvement > best_improvement or (improvement == best_improvement and sum(candidate_cost) < sum(best_cost)):\n            best_improvement = improvement\n            best_cost = candidate_cost\n            best_candidate = candidate.copy()\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(i, j)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, k - i)\n\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6773402260334473,
            3.150954234600067
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(i, j)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, k - i)\n\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that simultaneously considers all three distance matrices to generate a neighbor solution while ensuring feasibility by rotating a randomly selected segment of the tour in a direction that improves at least one objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to rotate\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, n - 1)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Try rotating the segment in both directions\n    rotated_forward = np.concatenate([new_solution[:seg_start], segment[1:], segment[:1], new_solution[seg_end+1:]])\n    rotated_backward = np.concatenate([new_solution[:seg_start], segment[-1:], segment[:-1], new_solution[seg_end+1:]])\n\n    forward_cost = calculate_cost(rotated_forward)\n    backward_cost = calculate_cost(rotated_backward)\n\n    # Select the best rotation that improves at least one objective\n    if any(f < curr for f, curr in zip(forward_cost, current_cost)):\n        new_solution = rotated_forward\n    elif any(b < curr for b, curr in zip(backward_cost, current_cost)):\n        new_solution = rotated_backward\n\n    return new_solution\n\n",
        "score": [
            -0.7845210408685793,
            2.6112640738487243
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to rotate\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, n - 1)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Try rotating the segment in both directions\n    rotated_forward = np.concatenate([new_solution[:seg_start], segment[1:], segment[:1], new_solution[seg_end+1:]])\n    rotated_backward = np.concatenate([new_solution[:seg_start], segment[-1:], segment[:-1], new_solution[seg_end+1:]])\n\n    forward_cost = calculate_cost(rotated_forward)\n    backward_cost = calculate_cost(rotated_backward)\n\n    # Select the best rotation that improves at least one objective\n    if any(f < curr for f, curr in zip(forward_cost, current_cost)):\n        new_solution = rotated_forward\n    elif any(b < curr for b, curr in zip(backward_cost, current_cost)):\n        new_solution = rotated_backward\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{This new heuristic selects a solution from the archive based on a diversity-aware scoring function that combines objective values and solution structure, then applies a hybrid 2-opt and node insertion operator to generate a neighbor solution while ensuring feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate diversity-aware scores\n    objectives = [obj for _, obj in archive]\n    norm_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    diversity_scores = np.std(norm_objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n\n    scores = []\n    for sol, obj in archive:\n        weighted_score = sum(w * o for w, o in zip(weights, obj))\n        scores.append(weighted_score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid operator: 2-opt with node insertion consideration\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n\n    # Apply 2-opt\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Consider node insertion at random position\n    if random.random() < 0.3:  # 30% chance to apply insertion\n        k = random.randint(0, n-1)\n        node = candidate[j]\n        candidate = np.insert(candidate, k, node)\n        candidate = np.delete(candidate, j + (1 if j > k else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if all(c <= curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7078094884260872,
            3.13828444480896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate diversity-aware scores\n    objectives = [obj for _, obj in archive]\n    norm_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    diversity_scores = np.std(norm_objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n\n    scores = []\n    for sol, obj in archive:\n        weighted_score = sum(w * o for w, o in zip(weights, obj))\n        scores.append(weighted_score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid operator: 2-opt with node insertion consideration\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n\n    # Apply 2-opt\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Consider node insertion at random position\n    if random.random() < 0.3:  # 30% chance to apply insertion\n        k = random.randint(0, n-1)\n        node = candidate[j]\n        candidate = np.insert(candidate, k, node)\n        candidate = np.delete(candidate, j + (1 if j > k else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if all(c <= curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node relocation heuristic that considers the three distance matrices simultaneously, moving a randomly selected segment of nodes to a new position while ensuring feasibility and potentially improving at least one objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to move\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n\n    # Select a new position to insert the segment\n    insert_pos = random.randint(0, n - 1)\n    while insert_pos >= start and insert_pos <= end:\n        insert_pos = random.randint(0, n - 1)\n\n    # Create candidate solution by moving the segment\n    candidate = np.concatenate([\n        new_solution[:start],\n        new_solution[end+1:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7323264999627406,
            1.9489426851272582
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to move\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n\n    # Select a new position to insert the segment\n    insert_pos = random.randint(0, n - 1)\n    while insert_pos >= start and insert_pos <= end:\n        insert_pos = random.randint(0, n - 1)\n\n    # Create candidate solution by moving the segment\n    candidate = np.concatenate([\n        new_solution[:start],\n        new_solution[end+1:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt* heuristic that considers the three distance matrices simultaneously by randomly selecting two non-adjacent edges and reconnecting them in a way that optimizes at least one objective while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt* heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two non-adjacent edges to reconnect\n    i = random.randint(0, n - 1)\n    j = (i + 2 + random.randint(0, n - 3)) % n\n    k = (j + 2 + random.randint(0, n - 3)) % n\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[i] = new_solution[j]\n    candidate[j] = new_solution[i]\n    candidate[k] = new_solution[(k + 1) % n]\n    candidate[(k + 1) % n] = new_solution[k]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7466450801108697,
            2.8291934609413145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt* heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two non-adjacent edges to reconnect\n    i = random.randint(0, n - 1)\n    j = (i + 2 + random.randint(0, n - 3)) % n\n    k = (j + 2 + random.randint(0, n - 3)) % n\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[i] = new_solution[j]\n    candidate[j] = new_solution[i]\n    candidate[k] = new_solution[(k + 1) % n]\n    candidate[(k + 1) % n] = new_solution[k]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    start, end = min(i, j), max(i, j)\n    segment = new_solution[start:end+1]\n\n    candidate = new_solution.copy()\n    candidate[start:end+1] = np.roll(segment, random.randint(1, len(segment)-1))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7554089525095694,
            2.9483861327171326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    start, end = min(i, j), max(i, j)\n    segment = new_solution[start:end+1]\n\n    candidate = new_solution.copy()\n    candidate[start:end+1] = np.roll(segment, random.randint(1, len(segment)-1))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation strategy that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment to relocate\n    segment_length = random.randint(2, max(2, n // 4))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate by relocating the segment\n    candidate = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7649210787496487,
            3.0537275195121767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment to relocate\n    segment_length = random.randint(2, max(2, n // 4))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate by relocating the segment\n    candidate = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt local search that simultaneously considers the three distance matrices to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_weights = [0.4, 0.3, 0.3]\n    weighted_sums = [sum(obj[i] * weight for i, weight in enumerate(objective_weights)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    for _ in range(min(10, n // 2)):\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n",
        "score": [
            -0.7785000405923885,
            3.1994688510894775
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_weights = [0.4, 0.3, 0.3]\n    weighted_sums = [sum(obj[i] * weight for i, weight in enumerate(objective_weights)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    for _ in range(min(10, n // 2)):\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by rotating a randomly selected segment of the tour in a direction that improves at least one objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    candidate = new_solution.copy()\n    direction = random.choice([-1, 1])\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, direction)\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7777350180376337,
            2.9932027101516723
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    candidate = new_solution.copy()\n    direction = random.choice([-1, 1])\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, direction)\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously, with an additional random segment reversal for diversification, to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective 2-opt heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select two random edges to swap (2-opt)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Generate candidate solution by reversing segment\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Additional random segment reversal for diversification\n    if random.random() < 0.3:\n        k = random.randint(0, n - 4)\n        l = random.randint(k + 2, n - 2)\n        candidate[k:l+1] = candidate[k:l+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n\n    # Accept if better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7046021833790274,
            2.8661441564559937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective 2-opt heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select two random edges to swap (2-opt)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Generate candidate solution by reversing segment\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Additional random segment reversal for diversification\n    if random.random() < 0.3:\n        k = random.randint(0, n - 4)\n        l = random.randint(k + 2, n - 2)\n        candidate[k:l+1] = candidate[k:l+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n\n    # Accept if better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective path reversal heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility, by reversing a segment of the tour and evaluating the impact on all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7908781577748754,
            2.3208099603652954
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility, while also incorporating a probabilistic acceptance criterion to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n    else:\n        # With some probability, accept worse solution to escape local optima\n        if random.random() < 0.2:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6812322389696286,
            2.1998491287231445
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n    else:\n        # With some probability, accept worse solution to escape local optima\n        if random.random() < 0.2:\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{This heuristic selects a solution from the archive based on a weighted combination of objective values and neighborhood diversity, then applies a multi-objective 2-opt heuristic that evaluates the combined improvement across all three objectives to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted objective scores (higher weights for better objectives)\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on objective importance\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted scores\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8017852809079544,
            3.2354918718338013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted objective scores (higher weights for better objectives)\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on objective importance\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted scores\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_products = [obj[0] * obj[1] * obj[2] for obj in archive_objectives]\n    selection_probs = [1.0 / (prod + 1e-6) for prod in objective_products]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7311988456474118,
            2.937901771068573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_products = [obj[0] * obj[1] * obj[2] for obj in archive_objectives]\n    selection_probs = [1.0 / (prod + 1e-6) for prod in objective_products]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution by rotating a randomly selected segment of the tour in a direction that improves at least one objective while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Randomly select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(1, j - i - 1)  # Number of positions to rotate\n\n    # Generate candidate by rotating the segment\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, k)\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7772664732557062,
            2.9501551270484923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Randomly select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(1, j - i - 1)  # Number of positions to rotate\n\n    # Generate candidate by rotating the segment\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, k)\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7596986776017365,
            2.8865881085395815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation operator that considers all three distance matrices simultaneously, ensuring feasibility by carefully validating the relocation of segments while maintaining the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Select a random insertion point\n    k = random.randint(0, n - 1)\n    while k >= i and k <= j:\n        k = random.randint(0, n - 1)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    candidate = np.concatenate((candidate[:i], candidate[j+1:]))\n    if k == 0:\n        candidate = np.concatenate((segment, candidate))\n    else:\n        candidate = np.concatenate((candidate[:k], segment, candidate[k:]))\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7777824416140716,
            2.883462059497833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Select a random insertion point\n    k = random.randint(0, n - 1)\n    while k >= i and k <= j:\n        k = random.randint(0, n - 1)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    candidate = np.concatenate((candidate[:i], candidate[j+1:]))\n    if k == 0:\n        candidate = np.concatenate((segment, candidate))\n    else:\n        candidate = np.concatenate((candidate[:k], segment, candidate[k:]))\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that simultaneously optimizes across all three distance matrices to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j or abs(i - j) == 1:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6077433921212787,
            3.172862195968628
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j or abs(i - j) == 1:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective 2-opt* local search that optimizes across all three objectives simultaneously by considering the cumulative improvement potential and performing a segment reversal that maximizes the number of objectives improved, while ensuring feasibility through careful edge selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Multi-objective 2-opt* with segment reversal\n    best_candidate = None\n    best_improvement = 0\n\n    # Try multiple random segments to find the best improvement\n    for _ in range(min(10, n//2)):\n        i = random.randint(0, n-4)\n        j = random.randint(i+2, n-2)\n\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n\n        # Count how many objectives are improved\n        improvement_count = sum(1 for c, curr in zip(candidate_cost, current_cost) if c < curr)\n\n        if improvement_count > best_improvement:\n            best_improvement = improvement_count\n            best_candidate = candidate\n\n    if best_candidate is not None and best_improvement > 0:\n        new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.767989255683018,
            3.4724066495895385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Multi-objective 2-opt* with segment reversal\n    best_candidate = None\n    best_improvement = 0\n\n    # Try multiple random segments to find the best improvement\n    for _ in range(min(10, n//2)):\n        i = random.randint(0, n-4)\n        j = random.randint(i+2, n-2)\n\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n\n        # Count how many objectives are improved\n        improvement_count = sum(1 for c, curr in zip(candidate_cost, current_cost) if c < curr)\n\n        if improvement_count > best_improvement:\n            best_improvement = improvement_count\n            best_candidate = candidate\n\n    if best_candidate is not None and best_improvement > 0:\n        new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility, by randomly selecting two nodes and swapping their positions in the tour while checking for improvement in at least one objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective node-swap heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select two random nodes to swap\n    i, j = random.sample(range(n), 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping nodes\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7946028495614564,
            2.473872447013855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective node-swap heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select two random nodes to swap\n    i, j = random.sample(range(n), 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping nodes\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective improvements and solution diversity, then applies a multi-objective 2-opt heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all objectives)\n    objective_weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    weighted_scores = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reversing the segment between i and j\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[j:i-1:-1] if i != 0 else candidate[j::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7656774396491468,
            3.2193005204200746
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all objectives)\n    objective_weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    weighted_scores = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reversing the segment between i and j\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[j:i-1:-1] if i != 0 else candidate[j::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 3-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7521545271124499,
            3.13195253610611
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel three-way segment migration operator that simultaneously considers all three distance matrices to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 6:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    segment1 = candidate[i:j+1]\n    segment2 = candidate[j+1:k+1]\n    candidate[i:k+1] = np.concatenate([segment2, segment1])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7326605322169927,
            2.585012650489807
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 6:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    segment1 = candidate[i:j+1]\n    segment2 = candidate[j+1:k+1]\n    candidate[i:k+1] = np.concatenate([segment2, segment1])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This heuristic selects a solution from the archive based on objective diversity and improvement potential, then applies a novel multi-objective segment rotation operator that simultaneously optimizes across all three objectives by rotating segments of the tour while ensuring feasibility and potentially improving multiple objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    k = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - k - 1)\n    segment = new_solution[i:i+k]\n    rotated_segment = np.roll(segment, 1)\n\n    candidate = new_solution.copy()\n    candidate[i:i+k] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6695781255509233,
            3.0183537364006043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    k = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - k - 1)\n    segment = new_solution[i:i+k]\n    rotated_segment = np.roll(segment, 1)\n\n    candidate = new_solution.copy()\n    candidate[i:i+k] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by intelligently relocating a randomly selected segment to a new position, carefully checking for dominance in all three objectives before accepting the move.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, min(seg_start + 5, n - 1))\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n - 1)\n    while new_pos >= seg_start and new_pos <= seg_end:\n        new_pos = random.randint(0, n - 1)\n\n    # Create candidate solution\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:],\n        segment\n    ])\n\n    if new_pos > seg_start:\n        new_pos -= (seg_end - seg_start + 1)\n\n    candidate = np.concatenate([\n        candidate[:new_pos],\n        segment,\n        candidate[new_pos:]\n    ])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.4788826533784019,
            2.2923710107803346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, min(seg_start + 5, n - 1))\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n - 1)\n    while new_pos >= seg_start and new_pos <= seg_end:\n        new_pos = random.randint(0, n - 1)\n\n    # Create candidate solution\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:],\n        segment\n    ])\n\n    if new_pos > seg_start:\n        new_pos -= (seg_end - seg_start + 1)\n\n    candidate = np.concatenate([\n        candidate[:new_pos],\n        segment,\n        candidate[new_pos:]\n    ])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{This new heuristic selects a solution from the archive based on a combination of objective diversity and crowding distance, then applies a multi-objective 2-opt heuristic with adaptive segment selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate crowding distance for each objective\n    def crowding_distance(objectives):\n        n = len(objectives)\n        distances = [0.0] * n\n        for m in range(3):\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n            min_obj = objectives[sorted_idx[0]][m]\n            max_obj = objectives[sorted_idx[-1]][m]\n            if max_obj == min_obj:\n                continue\n            for i in range(1, n-1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (max_obj - min_obj)\n        return distances\n\n    crowding_distances = crowding_distance(archive_objectives)\n    selection_probs = [1.0 / (cd + 1e-6) for cd in crowding_distances]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection based on objective diversity\n    def segment_score(i, j):\n        segment = new_solution[i:j+1]\n        cost1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        cost3 = sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        diversity = (max(cost1, cost2, cost3) - min(cost1, cost2, cost3)) / (sum(archive_objectives[selected_idx]) + 1e-6)\n        return diversity\n\n    # Find the most diverse segment to reverse\n    best_score = -1\n    best_i, best_j = 0, 0\n    for _ in range(min(10, n//2)):\n        i = random.randint(0, n-4)\n        j = random.randint(i+2, min(i+10, n-2))\n        score = segment_score(i, j)\n        if score > best_score:\n            best_score = score\n            best_i, best_j = i, j\n\n    if best_score > 0:\n        candidate = new_solution.copy()\n        candidate[best_i:best_j+1] = candidate[best_i:best_j+1][::-1]\n        return candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6256696602567622,
            3.078147065639496
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate crowding distance for each objective\n    def crowding_distance(objectives):\n        n = len(objectives)\n        distances = [0.0] * n\n        for m in range(3):\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n            min_obj = objectives[sorted_idx[0]][m]\n            max_obj = objectives[sorted_idx[-1]][m]\n            if max_obj == min_obj:\n                continue\n            for i in range(1, n-1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (max_obj - min_obj)\n        return distances\n\n    crowding_distances = crowding_distance(archive_objectives)\n    selection_probs = [1.0 / (cd + 1e-6) for cd in crowding_distances]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection based on objective diversity\n    def segment_score(i, j):\n        segment = new_solution[i:j+1]\n        cost1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        cost3 = sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        diversity = (max(cost1, cost2, cost3) - min(cost1, cost2, cost3)) / (sum(archive_objectives[selected_idx]) + 1e-6)\n        return diversity\n\n    # Find the most diverse segment to reverse\n    best_score = -1\n    best_i, best_j = 0, 0\n    for _ in range(min(10, n//2)):\n        i = random.randint(0, n-4)\n        j = random.randint(i+2, min(i+10, n-2))\n        score = segment_score(i, j)\n        if score > best_score:\n            best_score = score\n            best_i, best_j = i, j\n\n    if best_score > 0:\n        candidate = new_solution.copy()\n        candidate[best_i:best_j+1] = candidate[best_i:best_j+1][::-1]\n        return candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n    k = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7708342712447716,
            2.0638219118118286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n    k = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 3-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7665124906158327,
            3.2292510509490966
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n-1)\n    node_to_insert = new_solution[i]\n\n    candidate = np.delete(new_solution, i)\n    insertion_pos = random.randint(0, len(candidate))\n\n    candidate = np.insert(candidate, insertion_pos, node_to_insert)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7591714094994976,
            3.087438929080963
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n-1)\n    node_to_insert = new_solution[i]\n\n    candidate = np.delete(new_solution, i)\n    insertion_pos = random.randint(0, len(candidate))\n\n    candidate = np.insert(candidate, insertion_pos, node_to_insert)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation operator that considers all three distance matrices simultaneously, rotating a randomly selected segment of the tour in a direction that shows promise of improving at least one objective while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Try rotating the segment in both directions\n    candidates = []\n    for direction in [1, -1]:\n        candidate = new_solution.copy()\n        segment = candidate[i:j+1]\n        rotated_segment = np.roll(segment, direction)\n        candidate[i:j+1] = rotated_segment\n        candidates.append(candidate)\n\n    # Evaluate all candidates\n    best_candidate = None\n    best_improvement = 0\n\n    for candidate in candidates:\n        candidate_cost = calculate_cost(candidate)\n        improvement = sum(curr - c for c, curr in zip(candidate_cost, current_cost) if c < curr)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7894436563927166,
            3.074168872833252
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Try rotating the segment in both directions\n    candidates = []\n    for direction in [1, -1]:\n        candidate = new_solution.copy()\n        segment = candidate[i:j+1]\n        rotated_segment = np.roll(segment, direction)\n        candidate[i:j+1] = rotated_segment\n        candidates.append(candidate)\n\n    # Evaluate all candidates\n    best_candidate = None\n    best_improvement = 0\n\n    for candidate in candidates:\n        candidate_cost = calculate_cost(candidate)\n        improvement = sum(curr - c for c, curr in zip(candidate_cost, current_cost) if c < curr)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective path relocation operator that simultaneously considers all three objectives to generate a neighbor solution while ensuring feasibility by carefully selecting and relocating segments of the tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    remaining = np.delete(candidate, slice(i, j+1))\n\n    k = random.randint(0, len(remaining))\n    candidate = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7189645753415723,
            2.924321687221527
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    remaining = np.delete(candidate, slice(i, j+1))\n\n    k = random.randint(0, len(remaining))\n    candidate = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    segment_length = random.randint(2, min(4, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:start], candidate[start+segment_length:]])\n    insert_pos = random.randint(0, len(candidate) - 1)\n    candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7181276140295563,
            2.8751689076423643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    segment_length = random.randint(2, min(4, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:start], candidate[start+segment_length:]])\n    insert_pos = random.randint(0, len(candidate) - 1)\n    candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 3-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8366939395521585,
            2.8595345616340637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously, with a probabilistic acceptance criterion to balance exploration and exploitation, to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    max_sum = max(objective_sums) if objective_sums else 1.0\n    selection_probs = [(max_sum - sum_val + 1e-6) / max_sum for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on diversity and improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Multi-objective 2-opt with probabilistic acceptance\n    for _ in range(10):  # Perform multiple trials\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i < 2:\n            continue\n\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        improvement_count = sum(1 for c, curr in zip(candidate_cost, current_cost) if c < curr)\n\n        # Probabilistic acceptance based on improvement count\n        if improvement_count > 0 or random.random() < 0.3:  # 30% chance to accept even without improvement\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n",
        "score": [
            -0.7627362993077551,
            3.1423058032989504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    max_sum = max(objective_sums) if objective_sums else 1.0\n    selection_probs = [(max_sum - sum_val + 1e-6) / max_sum for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on diversity and improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Multi-objective 2-opt with probabilistic acceptance\n    for _ in range(10):  # Perform multiple trials\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i < 2:\n            continue\n\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        improvement_count = sum(1 for c, curr in zip(candidate_cost, current_cost) if c < curr)\n\n        # Probabilistic acceptance based on improvement count\n        if improvement_count > 0 or random.random() < 0.3:  # 30% chance to accept even without improvement\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously, moving a random segment to a different position in the tour to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment relocation heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n\n    # Randomly select a new position for the segment\n    new_pos = random.randint(0, n - (end - start + 1))\n    if new_pos > start:\n        new_pos += (end - start + 1)\n\n    # Create candidate solution\n    candidate = np.concatenate([\n        new_solution[:start],\n        new_solution[end+1:new_pos],\n        segment,\n        new_solution[new_pos:]\n    ])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6654353868749948,
            2.065862035751343
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment relocation heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n\n    # Randomly select a new position for the segment\n    new_pos = random.randint(0, n - (end - start + 1))\n    if new_pos > start:\n        new_pos += (end - start + 1)\n\n    # Create candidate solution\n    candidate = np.concatenate([\n        new_solution[:start],\n        new_solution[end+1:new_pos],\n        segment,\n        new_solution[new_pos:]\n    ])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 3-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    a, b, c = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[a:b+1] = candidate[a:b+1][::-1]\n    candidate[b:c+1] = candidate[b:c+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6975016923642758,
            3.0538915753364564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    a, b, c = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[a:b+1] = candidate[a:b+1][::-1]\n    candidate[b:c+1] = candidate[b:c+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    remaining = np.delete(new_solution, range(i, j+1))\n\n    # Find the best insertion position for the segment\n    best_candidate = None\n    best_cost = current_cost\n\n    for k in range(len(remaining)):\n        candidate = np.insert(remaining, k, segment)\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, best_cost)):\n            best_candidate = candidate\n            best_cost = candidate_cost\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7803778506297097,
            4.273612225055695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    remaining = np.delete(new_solution, range(i, j+1))\n\n    # Find the best insertion position for the segment\n    best_candidate = None\n    best_cost = current_cost\n\n    for k in range(len(remaining)):\n        candidate = np.insert(remaining, k, segment)\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, best_cost)):\n            best_candidate = candidate\n            best_cost = candidate_cost\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{This new heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 3-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    a, b, c = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[a:b+1] = candidate[a:b+1][::-1]\n    candidate[b:c+1] = candidate[b:c+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7671341773811642,
            3.2013233065605164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    a, b, c = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[a:b+1] = candidate[a:b+1][::-1]\n    candidate[b:c+1] = candidate[b:c+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment inversion and relocation heuristic that simultaneously considers all three distance matrices to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n    else:\n        i, j, k = sorted(random.sample(range(n), 3))\n        candidate = new_solution.copy()\n        segment = candidate[i:j+1]\n        candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8072784239822755,
            2.9627190947532656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n    else:\n        i, j, k = sorted(random.sample(range(n), 3))\n        candidate = new_solution.copy()\n        segment = candidate[i:j+1]\n        candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective product)\n    objective_products = [np.prod(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (prod + 1e-6) for prod in objective_products]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try inserting the segment at different positions\n    best_candidate = new_solution.copy()\n    best_cost = current_cost\n\n    for i in range(n - segment_length + 1):\n        if i >= start and i <= start + segment_length - 1:\n            continue  # Skip original position\n\n        candidate = new_solution.copy()\n        candidate = np.concatenate([candidate[:i], segment, candidate[i:]])\n        candidate = np.delete(candidate, np.s_[start:start+segment_length])\n\n        candidate_cost = calculate_cost(candidate)\n\n        # Check if the candidate is better in at least one objective\n        if any(c < curr for c, curr in zip(candidate_cost, best_cost)):\n            best_candidate = candidate\n            best_cost = candidate_cost\n\n    return best_candidate\n\n",
        "score": [
            -0.7607713059970742,
            4.324555027484894
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective product)\n    objective_products = [np.prod(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (prod + 1e-6) for prod in objective_products]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try inserting the segment at different positions\n    best_candidate = new_solution.copy()\n    best_cost = current_cost\n\n    for i in range(n - segment_length + 1):\n        if i >= start and i <= start + segment_length - 1:\n            continue  # Skip original position\n\n        candidate = new_solution.copy()\n        candidate = np.concatenate([candidate[:i], segment, candidate[i:]])\n        candidate = np.delete(candidate, np.s_[start:start+segment_length])\n\n        candidate_cost = calculate_cost(candidate)\n\n        # Check if the candidate is better in at least one objective\n        if any(c < curr for c, curr in zip(candidate_cost, best_cost)):\n            best_candidate = candidate\n            best_cost = candidate_cost\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, n - 1)\n    while k == i or k == j or k == (i + 1) % n or k == (j + 1) % n:\n        k = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6949068699671683,
            1.6748283982276917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, n - 1)\n    while k == i or k == j or k == (i + 1) % n or k == (j + 1) % n:\n        k = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{This heuristic selects a solution from the archive based on the most under-represented objective space, then applies a novel multi-objective insertion heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_values = list(zip(*archive_objectives))\n    objective_means = [sum(obj) / len(obj) for obj in objective_values]\n\n    selected_idx = np.argmin(objective_means)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while i == j:\n        j = random.randint(0, n-1)\n\n    candidate = new_solution.copy()\n    node = candidate[i]\n    candidate = np.delete(candidate, i)\n    candidate = np.insert(candidate, j, node)\n\n    candidate_cost = calculate_cost(candidate)\n    if sum(candidate_cost) < sum(current_cost):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6842758250532758,
            2.4236168384552004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_values = list(zip(*archive_objectives))\n    objective_means = [sum(obj) / len(obj) for obj in objective_values]\n\n    selected_idx = np.argmin(objective_means)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while i == j:\n        j = random.randint(0, n-1)\n\n    candidate = new_solution.copy()\n    node = candidate[i]\n    candidate = np.delete(candidate, i)\n    candidate = np.insert(candidate, j, node)\n\n    candidate_cost = calculate_cost(candidate)\n    if sum(candidate_cost) < sum(current_cost):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective inversion operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Novel multi-objective inversion operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select a random segment to invert (ensuring feasibility)\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by inverting the segment\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Invert the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7343977687918767,
            2.3359076976776123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Novel multi-objective inversion operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select a random segment to invert (ensuring feasibility)\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by inverting the segment\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Invert the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and their diversity, then applies a hybrid local search operator that combines 2-opt exchanges with a novel objective-aware perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    weights = [0.4, 0.3, 0.3]\n    weighted_sums = [sum(w * val for w, val in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n            break\n\n    if random.random() < 0.2:\n        k = random.randint(1, n-2)\n        new_solution = np.concatenate([new_solution[k:], new_solution[:k]])\n\n    return new_solution\n\n",
        "score": [
            -0.7830969129639614,
            2.634280836582184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    weights = [0.4, 0.3, 0.3]\n    weighted_sums = [sum(w * val for w, val in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n            break\n\n    if random.random() < 0.2:\n        k = random.randint(1, n-2)\n        new_solution = np.concatenate([new_solution[k:], new_solution[:k]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by rotating a randomly selected segment of the tour in a clockwise or counter-clockwise direction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 2, n - 1)\n    direction = random.choice([-1, 1])\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, direction)\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7190671331371925,
            3.0704689502716063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 2, n - 1)\n    direction = random.choice([-1, 1])\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, direction)\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 3-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7326499398733721,
            3.1632742524147033
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{This heuristic selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt local search with adaptive segment selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential\n    weights = [0.4, 0.3, 0.3]  # Different weights for objectives\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection based on objective diversity\n    def calculate_diversity(sol):\n        costs = []\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            cost = sum(dm[sol[k], sol[k+1]] for k in range(n-1)) + dm[sol[-1], sol[0]]\n            costs.append(cost)\n        return np.std(costs)\n\n    # Generate multiple candidate segments and select the most diverse one\n    candidates = []\n    for _ in range(5):\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        candidates.append((i, j, calculate_diversity(candidate)))\n\n    i, j, _ = max(candidates, key=lambda x: x[2])\n\n    # Apply the selected swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.740481278071854,
            3.731695532798767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential\n    weights = [0.4, 0.3, 0.3]  # Different weights for objectives\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection based on objective diversity\n    def calculate_diversity(sol):\n        costs = []\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            cost = sum(dm[sol[k], sol[k+1]] for k in range(n-1)) + dm[sol[-1], sol[0]]\n            costs.append(cost)\n        return np.std(costs)\n\n    # Generate multiple candidate segments and select the most diverse one\n    candidates = []\n    for _ in range(5):\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        candidates.append((i, j, calculate_diversity(candidate)))\n\n    i, j, _ = max(candidates, key=lambda x: x[2])\n\n    # Apply the selected swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(0, n - 2)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 2)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    insert_pos = random.randint(0, len(candidate) - 1)\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7044593197684881,
            2.139636516571045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(0, n - 2)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 2)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    insert_pos = random.randint(0, len(candidate) - 1)\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective path relinking operator that combines segments from multiple solutions in the archive to create a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select another reference solution for path relinking\n    ref_idx = np.random.choice([i for i in range(len(archive_solutions)) if i != selected_idx])\n    ref_solution = archive_solutions[ref_idx].copy()\n\n    # Find common nodes between base and reference solutions\n    common_nodes = set(base_solution).intersection(set(ref_solution))\n\n    if len(common_nodes) < 2:\n        return new_solution\n\n    # Select two random common nodes as anchor points\n    anchor_nodes = random.sample(list(common_nodes), 2)\n    anchor_pos_base = [np.where(base_solution == node)[0][0] for node in anchor_nodes]\n    anchor_pos_ref = [np.where(ref_solution == node)[0][0] for node in anchor_nodes]\n\n    # Create a new solution by combining paths from base and reference\n    new_solution = np.zeros_like(base_solution)\n    start = min(anchor_pos_base)\n    end = max(anchor_pos_base)\n    ref_start = min(anchor_pos_ref)\n    ref_end = max(anchor_pos_ref)\n\n    # Copy the base path segment\n    new_solution[start:end+1] = base_solution[start:end+1]\n\n    # Fill the rest with nodes from reference solution in order\n    ref_nodes = ref_solution[ref_start:ref_end+1] if ref_start <= ref_end else np.concatenate([ref_solution[ref_start:], ref_solution[:ref_end+1]])\n    remaining_nodes = [node for node in ref_nodes if node not in new_solution[start:end+1]]\n\n    # Fill the remaining positions with remaining nodes\n    remaining_positions = [i for i in range(n) if new_solution[i] == 0]\n    for i, node in zip(remaining_positions, remaining_nodes):\n        new_solution[i] = node\n\n    # Ensure all nodes are included\n    missing_nodes = [node for node in base_solution if node not in new_solution]\n    if missing_nodes:\n        empty_positions = [i for i in range(n) if new_solution[i] == 0]\n        for i, node in zip(empty_positions, missing_nodes):\n            new_solution[i] = node\n\n    # Verify feasibility\n    if len(set(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7610072956387598,
            4.143328857421875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select another reference solution for path relinking\n    ref_idx = np.random.choice([i for i in range(len(archive_solutions)) if i != selected_idx])\n    ref_solution = archive_solutions[ref_idx].copy()\n\n    # Find common nodes between base and reference solutions\n    common_nodes = set(base_solution).intersection(set(ref_solution))\n\n    if len(common_nodes) < 2:\n        return new_solution\n\n    # Select two random common nodes as anchor points\n    anchor_nodes = random.sample(list(common_nodes), 2)\n    anchor_pos_base = [np.where(base_solution == node)[0][0] for node in anchor_nodes]\n    anchor_pos_ref = [np.where(ref_solution == node)[0][0] for node in anchor_nodes]\n\n    # Create a new solution by combining paths from base and reference\n    new_solution = np.zeros_like(base_solution)\n    start = min(anchor_pos_base)\n    end = max(anchor_pos_base)\n    ref_start = min(anchor_pos_ref)\n    ref_end = max(anchor_pos_ref)\n\n    # Copy the base path segment\n    new_solution[start:end+1] = base_solution[start:end+1]\n\n    # Fill the rest with nodes from reference solution in order\n    ref_nodes = ref_solution[ref_start:ref_end+1] if ref_start <= ref_end else np.concatenate([ref_solution[ref_start:], ref_solution[:ref_end+1]])\n    remaining_nodes = [node for node in ref_nodes if node not in new_solution[start:end+1]]\n\n    # Fill the remaining positions with remaining nodes\n    remaining_positions = [i for i in range(n) if new_solution[i] == 0]\n    for i, node in zip(remaining_positions, remaining_nodes):\n        new_solution[i] = node\n\n    # Ensure all nodes are included\n    missing_nodes = [node for node in base_solution if node not in new_solution]\n    if missing_nodes:\n        empty_positions = [i for i in range(n) if new_solution[i] == 0]\n        for i, node in zip(empty_positions, missing_nodes):\n            new_solution[i] = node\n\n    # Verify feasibility\n    if len(set(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.73044691394267,
            3.0253749012947084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment rotation heuristic that rotates a randomly selected segment of the tour in a direction that simultaneously improves multiple objectives, while ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment and rotation direction\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, min(i + n // 2, n - 1))\n    rotate_left = random.choice([True, False])\n\n    candidate = new_solution.copy()\n    if rotate_left:\n        candidate[i:j+1] = np.roll(candidate[i:j+1], -1)\n    else:\n        candidate[i:j+1] = np.roll(candidate[i:j+1], 1)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8030999384224385,
            2.9135470032691955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment and rotation direction\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, min(i + n // 2, n - 1))\n    rotate_left = random.choice([True, False])\n\n    candidate = new_solution.copy()\n    if rotate_left:\n        candidate[i:j+1] = np.roll(candidate[i:j+1], -1)\n    else:\n        candidate[i:j+1] = np.roll(candidate[i:j+1], 1)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate diversity score (standard deviation of objectives)\n    objective_matrix = np.array(archive_objectives)\n    diversity_scores = np.std(objective_matrix, axis=0)\n    selection_weights = [sum(diversity_scores) / (sum(obj) + 1e-6) for obj in archive_objectives]\n    total_weight = sum(selection_weights)\n    selection_probs = [w / total_weight for w in selection_weights]\n\n    # Randomly select a solution based on diversity and improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7917278325508929,
            4.392716085910797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate diversity score (standard deviation of objectives)\n    objective_matrix = np.array(archive_objectives)\n    diversity_scores = np.std(objective_matrix, axis=0)\n    selection_weights = [sum(diversity_scores) / (sum(obj) + 1e-6) for obj in archive_objectives]\n    total_weight = sum(selection_weights)\n    selection_probs = [w / total_weight for w in selection_weights]\n\n    # Randomly select a solution based on diversity and improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 3-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by randomly selecting three non-consecutive edges and performing a cyclic permutation to maintain tour validity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three non-consecutive edges for 3-opt\n    indices = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n\n    # Perform cyclic permutation of the selected edges\n    candidate[indices[0]:indices[1]+1] = candidate[indices[0]:indices[1]+1][::-1]\n    candidate[indices[1]:indices[2]+1] = candidate[indices[1]:indices[2]+1][::-1]\n    candidate[indices[0]:indices[2]+1] = candidate[indices[0]:indices[2]+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7981206534898422,
            2.9823534965515135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three non-consecutive edges for 3-opt\n    indices = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n\n    # Perform cyclic permutation of the selected edges\n    candidate[indices[0]:indices[1]+1] = candidate[indices[0]:indices[1]+1][::-1]\n    candidate[indices[1]:indices[2]+1] = candidate[indices[1]:indices[2]+1][::-1]\n    candidate[indices[0]:indices[2]+1] = candidate[indices[0]:indices[2]+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by relocating a random segment to a new position in the tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 3)\n    seg_length = random.randint(2, min(5, n - seg_start - 1))\n    seg_end = seg_start + seg_length\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n - seg_length)\n\n    # Create candidate solution\n    candidate = new_solution.copy()\n    segment = candidate[seg_start:seg_end]\n    candidate = np.concatenate([candidate[:seg_start], candidate[seg_end:]])\n    candidate = np.concatenate([candidate[:new_pos], segment, candidate[new_pos:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7694086670778996,
            3.0830623149871825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 3)\n    seg_length = random.randint(2, min(5, n - seg_start - 1))\n    seg_end = seg_start + seg_length\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n - seg_length)\n\n    # Create candidate solution\n    candidate = new_solution.copy()\n    segment = candidate[seg_start:seg_end]\n    candidate = np.concatenate([candidate[:seg_start], candidate[seg_end:]])\n    candidate = np.concatenate([candidate[:new_pos], segment, candidate[new_pos:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This new algorithm selects a solution from the archive based on objective diversity and applies a hybrid 2-opt and 3-opt local search that simultaneously considers all three objectives, using a weighted combination of improvements to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_weights = [0.4, 0.3, 0.3]\n    weighted_sums = [sum(w * obj[i] for i, w in enumerate(objective_weights)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    for _ in range(2):\n        i, j, k = sorted(random.sample(range(n), 3))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        candidate[j:k+1] = candidate[j:k+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8124477466987855,
            2.973352110385895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_weights = [0.4, 0.3, 0.3]\n    weighted_sums = [sum(w * obj[i] for i, w in enumerate(objective_weights)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    for _ in range(2):\n        i, j, k = sorted(random.sample(range(n), 3))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        candidate[j:k+1] = candidate[j:k+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective node insertion heuristic\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Select a random node to remove\n    remove_idx = random.randint(0, n - 1)\n    removed_node = new_solution[remove_idx]\n    new_solution = np.delete(new_solution, remove_idx)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-2)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-2)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-2)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Find the best insertion position for the removed node\n    best_position = 0\n    best_cost = current_cost\n    best_solution = new_solution.copy()\n\n    for pos in range(n - 1):\n        candidate = np.insert(new_solution, pos, removed_node)\n        candidate_cost = calculate_cost(candidate)\n\n        # Check if the candidate is better in at least one objective\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            best_position = pos\n            best_cost = candidate_cost\n            best_solution = candidate.copy()\n\n    # Insert the node at the best position\n    new_solution = np.insert(best_solution, best_position, removed_node)\n\n    return new_solution\n\n",
        "score": [
            -0.6521810181110975,
            4.327603876590729
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective node insertion heuristic\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Select a random node to remove\n    remove_idx = random.randint(0, n - 1)\n    removed_node = new_solution[remove_idx]\n    new_solution = np.delete(new_solution, remove_idx)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-2)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-2)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-2)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Find the best insertion position for the removed node\n    best_position = 0\n    best_cost = current_cost\n    best_solution = new_solution.copy()\n\n    for pos in range(n - 1):\n        candidate = np.insert(new_solution, pos, removed_node)\n        candidate_cost = calculate_cost(candidate)\n\n        # Check if the candidate is better in at least one objective\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            best_position = pos\n            best_cost = candidate_cost\n            best_solution = candidate.copy()\n\n    # Insert the node at the best position\n    new_solution = np.insert(best_solution, best_position, removed_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, k - i)\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7271881099618621,
            3.3726444005966187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    rotated_segment = np.roll(segment, k - i)\n    candidate[i:j+1] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7245441771237559,
            2.928792417049408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 1)\n    k = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6439416638320149,
            2.00784775018692
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 1)\n    k = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel 3-opt local search operator that simultaneously considers all three objectives to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.766885623950804,
            3.0840250849723816
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt* heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt* heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    if i < j:\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n    else:\n        candidate[j:i+1] = candidate[j:i+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7591774684331466,
            2.7446879386901855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt* heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    if i < j:\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n    else:\n        candidate[j:i+1] = candidate[j:i+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously, ensuring feasibility by only performing valid swaps that maintain a valid tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective product)\n    objective_products = [obj[0] * obj[1] * obj[2] for obj in archive_objectives]\n    selection_probs = [1.0 / (prod + 1e-6) for prod in objective_products]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8075228748033367,
            2.7692160844802856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective product)\n    objective_products = [obj[0] * obj[1] * obj[2] for obj in archive_objectives]\n    selection_probs = [1.0 / (prod + 1e-6) for prod in objective_products]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective hybrid local search strategy that combines segment reversal with node insertion, considering all three objectives simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid local search: segment reversal followed by node insertion\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n\n    # Randomly select a node to insert elsewhere\n    k = random.randint(0, n-1)\n    node = candidate[k]\n    candidate = np.delete(candidate, k)\n    new_pos = random.randint(0, len(candidate)-1)\n    candidate = np.insert(candidate, new_pos, node)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7176754165331614,
            3.220328211784363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid local search: segment reversal followed by node insertion\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n\n    # Randomly select a node to insert elsewhere\n    k = random.randint(0, n-1)\n    node = candidate[k]\n    candidate = np.delete(candidate, k)\n    new_pos = random.randint(0, len(candidate)-1)\n    candidate = np.insert(candidate, new_pos, node)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted combination of objective improvements and diversity, then applies a multi-objective segment inversion operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (weighted combination of objectives)\n    objective_weights = [0.4, 0.3, 0.3]  # Weighting for three objectives\n    weighted_sums = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment inversion heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment to invert (ensuring feasibility)\n    seg_start = random.randint(0, n - 4)\n    seg_end = random.randint(seg_start + 2, min(seg_start + 10, n - 2))\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by inverting the segment\n    candidate = new_solution.copy()\n    candidate[seg_start:seg_end+1] = candidate[seg_start:seg_end+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.732702726357341,
            3.12047199010849
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (weighted combination of objectives)\n    objective_weights = [0.4, 0.3, 0.3]  # Weighting for three objectives\n    weighted_sums = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment inversion heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment to invert (ensuring feasibility)\n    seg_start = random.randint(0, n - 4)\n    seg_end = random.randint(seg_start + 2, min(seg_start + 10, n - 2))\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by inverting the segment\n    candidate = new_solution.copy()\n    candidate[seg_start:seg_end+1] = candidate[seg_start:seg_end+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a hybrid local search operator that combines segment reversal with node insertion to generate a neighbor solution while ensuring feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted objective diversity\n    normalized_objectives = np.array(archive_objectives)\n    min_obj = np.min(normalized_objectives, axis=0)\n    max_obj = np.max(normalized_objectives, axis=0)\n    normalized_objectives = (normalized_objectives - min_obj) / (max_obj - min_obj + 1e-6)\n\n    # Calculate selection probabilities based on diversity and objective values\n    diversity_scores = np.std(normalized_objectives, axis=1)\n    objective_scores = np.mean(normalized_objectives, axis=1)\n    combined_scores = diversity_scores * 0.6 + objective_scores * 0.4\n\n    selection_probs = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search operator: segment reversal followed by node insertion\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # First operation: segment reversal\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Second operation: node insertion\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = candidate[k]\n        candidate = np.delete(candidate, k)\n        candidate = np.insert(candidate, l, node)\n\n    # Check if the candidate is better in at least one objective\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n    candidate_cost = calculate_cost(candidate)\n\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7572115897671494,
            3.5441667556762697
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted objective diversity\n    normalized_objectives = np.array(archive_objectives)\n    min_obj = np.min(normalized_objectives, axis=0)\n    max_obj = np.max(normalized_objectives, axis=0)\n    normalized_objectives = (normalized_objectives - min_obj) / (max_obj - min_obj + 1e-6)\n\n    # Calculate selection probabilities based on diversity and objective values\n    diversity_scores = np.std(normalized_objectives, axis=1)\n    objective_scores = np.mean(normalized_objectives, axis=1)\n    combined_scores = diversity_scores * 0.6 + objective_scores * 0.4\n\n    selection_probs = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search operator: segment reversal followed by node insertion\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # First operation: segment reversal\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Second operation: node insertion\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = candidate[k]\n        candidate = np.delete(candidate, k)\n        candidate = np.insert(candidate, l, node)\n\n    # Check if the candidate is better in at least one objective\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n    candidate_cost = calculate_cost(candidate)\n\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective 2-opt* local search operator that considers the three distance matrices simultaneously while ensuring feasibility by maintaining tour connectivity and node uniqueness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt* heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select four distinct random indices\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Generate candidate solution by reordering edges\n    candidate = new_solution.copy()\n    candidate[a:b+1] = candidate[a:b+1][::-1]\n    candidate[c:d+1] = candidate[c:d+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8579913641298663,
            2.66614693403244
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt* heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select four distinct random indices\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Generate candidate solution by reordering edges\n    candidate = new_solution.copy()\n    candidate[a:b+1] = candidate[a:b+1][::-1]\n    candidate[c:d+1] = candidate[c:d+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt local search heuristic that simultaneously considers all three distance matrices to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all three objectives)\n    objective_weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_sums = [sum(w * val for w, val in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6986514542298023,
            3.146193778514862
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all three objectives)\n    objective_weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_sums = [sum(w * val for w, val in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a multi-objective 3-opt exchange heuristic that simultaneously considers all three distance matrices to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.802992921202718,
            3.1212249636650085
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted combination of objective values and their normalized improvement potential, then applies a multi-objective 2-opt heuristic with adaptive segment selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic with adaptive segment selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Adaptive segment selection based on objective weights\n    segment_length = max(2, int(n * sum(weights) / 3))\n    i = random.randint(0, n - segment_length - 1)\n    j = i + segment_length\n\n    # Generate candidate solution\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7182407271783025,
            4.241021621227264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic with adaptive segment selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Adaptive segment selection based on objective weights\n    segment_length = max(2, int(n * sum(weights) / 3))\n    i = random.randint(0, n - segment_length - 1)\n    j = i + segment_length\n\n    # Generate candidate solution\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by rotating segments of the tour and checking for improvements in at least one objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[k:], candidate[j+1:k+1], segment])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6257471984468317,
            2.1320503830909727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[k:], candidate[j+1:k+1], segment])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective 3-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7570447274615992,
            3.0374390959739683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that reorders a randomly selected segment of the tour while considering the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to rotate\n    segment_length = random.randint(2, min(5, n-2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Generate candidate solution by rotating the segment\n    candidate = new_solution.copy()\n    segment = candidate[start:end]\n    rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n    candidate[start:end] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7015262948150066,
            3.16357604265213
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to rotate\n    segment_length = random.randint(2, min(5, n-2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Generate candidate solution by rotating the segment\n    candidate = new_solution.copy()\n    segment = candidate[start:end]\n    rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n    candidate[start:end] = rotated_segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search operator that combines 2-opt exchanges with a novel node insertion strategy to generate a neighbor solution while ensuring feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Apply hybrid local search: 2-opt exchange with node insertion\n    if random.random() < 0.5:\n        # 2-opt exchange\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n    else:\n        # Node insertion\n        candidate = new_solution.copy()\n        k = random.randint(0, n-1)\n        node = candidate[k]\n        candidate = np.delete(candidate, k)\n        pos = random.randint(0, n-2)\n        candidate = np.insert(candidate, pos, node)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8003358393442465,
            2.934267890453339
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Apply hybrid local search: 2-opt exchange with node insertion\n    if random.random() < 0.5:\n        # 2-opt exchange\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n    else:\n        # Node insertion\n        candidate = new_solution.copy()\n        k = random.randint(0, n-1)\n        node = candidate[k]\n        candidate = np.delete(candidate, k)\n        pos = random.randint(0, n-2)\n        candidate = np.insert(candidate, pos, node)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a hybrid local search operator that combines 2-opt moves with multi-objective edge-swap operations to generate a neighbor solution while ensuring feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential\n    weights = [0.4, 0.3, 0.3]  # Weights for each objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # First perform a 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[j:i-1 if i > 0 else None:-1]\n\n    # Then perform a multi-objective edge-swap\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n    candidate_cost = calculate_cost(candidate)\n\n    # Check if candidate is better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n    else:\n        # If not better, try a different edge-swap\n        k, l = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[k], candidate[l] = candidate[l], candidate[k]\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.816533361772365,
            2.7736443877220154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential\n    weights = [0.4, 0.3, 0.3]  # Weights for each objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # First perform a 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[j:i-1 if i > 0 else None:-1]\n\n    # Then perform a multi-objective edge-swap\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n    candidate_cost = calculate_cost(candidate)\n\n    # Check if candidate is better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n    else:\n        # If not better, try a different edge-swap\n        k, l = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[k], candidate[l] = candidate[l], candidate[k]\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{This heuristic selects a solution from the archive based on its objective diversity and applies a novel multi-segment inversion operator that simultaneously considers the three distance matrices to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    k = random.randint(2, min(5, n//2))\n    segments = sorted(random.sample(range(1, n), k-1))\n    segments = [0] + segments + [n]\n    candidate = new_solution.copy()\n    for i in range(len(segments)-1):\n        start, end = segments[i], segments[i+1]\n        if random.random() < 0.5:\n            candidate[start:end] = candidate[start:end][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if all(c <= curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.5089123601196578,
            3.850600242614746
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    k = random.randint(2, min(5, n//2))\n    segments = sorted(random.sample(range(1, n), k-1))\n    segments = [0] + segments + [n]\n    candidate = new_solution.copy()\n    for i in range(len(segments)-1):\n        start, end = segments[i], segments[i+1]\n        if random.random() < 0.5:\n            candidate[start:end] = candidate[start:end][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if all(c <= curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7395689792544009,
            2.6447706699371336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective improvements and diversity, then applies a novel multi-objective 2-opt heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all three objectives)\n    objective_weights = [0.4, 0.3, 0.3]  # Weighting for each objective\n    weighted_sums = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7590611224256368,
            3.180739951133728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all three objectives)\n    objective_weights = [0.4, 0.3, 0.3]  # Weighting for each objective\n    weighted_sums = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by intelligently relocating a segment of the tour to a new position.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a segment to relocate\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n - segment_length)\n    while new_pos >= start and new_pos <= start + segment_length - 1:\n        new_pos = random.randint(0, n - segment_length)\n\n    # Create candidate solution\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:start], candidate[start+segment_length:]])\n    candidate = np.insert(candidate, new_pos, segment)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8292835534974525,
            2.8664827585220336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a segment to relocate\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n - segment_length)\n    while new_pos >= start and new_pos <= start + segment_length - 1:\n        new_pos = random.randint(0, n - segment_length)\n\n    # Create candidate solution\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:start], candidate[start+segment_length:]])\n    candidate = np.insert(candidate, new_pos, segment)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{This heuristic selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all three objectives)\n    weighted_sums = [sum(w * o for w, o in zip([0.4, 0.3, 0.3], obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7821950139227909,
            3.1389209389686585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all three objectives)\n    weighted_sums = [sum(w * o for w, o in zip([0.4, 0.3, 0.3], obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on diversity\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7051988126323403,
            2.9810541033744813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on diversity\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility, by strategically relocating segments of the tour to potentially improve multiple objectives in a coordinated manner.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment to relocate\n    segment_length = random.randint(2, min(4, n - 2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start + segment_length]\n\n    # Calculate current costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate by relocating the segment\n    candidate = np.delete(new_solution, np.s_[start:start + segment_length])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7170381787205817,
            2.8738223195075987
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment to relocate\n    segment_length = random.randint(2, min(4, n - 2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start + segment_length]\n\n    # Calculate current costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate by relocating the segment\n    candidate = np.delete(new_solution, np.s_[start:start + segment_length])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a multi-objective hybrid local search operator that combines 2-opt with a novel segment relocation strategy to generate a neighbor solution while ensuring feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid local search: 2-opt + segment relocation\n    for _ in range(5):\n        move_type = random.choice(['2opt', 'relocate'])\n\n        if move_type == '2opt':\n            i, j = sorted(random.sample(range(n), 2))\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n        else:\n            i, j, k = random.sample(range(n), 3)\n            if i > j:\n                i, j = j, i\n            if k > i:\n                candidate = np.concatenate([new_solution[:i], new_solution[j+1:k+1], new_solution[i:j+1], new_solution[k+1:]])\n            else:\n                candidate = np.concatenate([new_solution[:k], new_solution[i:j+1], new_solution[k:i], new_solution[j+1:]])\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n",
        "score": [
            -0.729450340173839,
            1.991755437850952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid local search: 2-opt + segment relocation\n    for _ in range(5):\n        move_type = random.choice(['2opt', 'relocate'])\n\n        if move_type == '2opt':\n            i, j = sorted(random.sample(range(n), 2))\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n        else:\n            i, j, k = random.sample(range(n), 3)\n            if i > j:\n                i, j = j, i\n            if k > i:\n                candidate = np.concatenate([new_solution[:i], new_solution[j+1:k+1], new_solution[i:j+1], new_solution[k+1:]])\n            else:\n                candidate = np.concatenate([new_solution[:k], new_solution[i:j+1], new_solution[k:i], new_solution[j+1:]])\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation operator that considers the three distance matrices simultaneously, where it relocates a random segment to a new position while ensuring feasibility and potentially improving at least one objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 4)\n    seg_length = random.randint(2, min(4, n - seg_start - 1))\n    seg_end = seg_start + seg_length\n\n    # Calculate current costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    segment = candidate[seg_start:seg_end]\n    candidate = np.concatenate([candidate[:seg_start], candidate[seg_end:], segment])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7841879846020533,
            3.0378150224685667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 4)\n    seg_length = random.randint(2, min(4, n - seg_start - 1))\n    seg_end = seg_start + seg_length\n\n    # Calculate current costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    segment = candidate[seg_start:seg_end]\n    candidate = np.concatenate([candidate[:seg_start], candidate[seg_end:], segment])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a multi-objective 3-opt exchange heuristic that simultaneously optimizes all three objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7775174551067221,
            3.7213473439216616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment-shuffle heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    k = random.randint(2, min(5, n//2))\n    segments = []\n    start = 0\n    while start < n:\n        end = min(start + k, n)\n        segments.append(new_solution[start:end])\n        start = end\n\n    random.shuffle(segments)\n    candidate = np.concatenate(segments)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7592985228743836,
            3.4522421836853026
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    k = random.randint(2, min(5, n//2))\n    segments = []\n    start = 0\n    while start < n:\n        end = min(start + k, n)\n        segments.append(new_solution[start:end])\n        start = end\n\n    random.shuffle(segments)\n    candidate = np.concatenate(segments)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective path inversion heuristic that considers the three distance matrices simultaneously while ensuring feasibility by carefully selecting non-overlapping segments to invert and verifying the solution's validity after each modification.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select two non-overlapping segments to invert\n    seg1_start = random.randint(0, n - 2)\n    seg1_end = random.randint(seg1_start + 1, n - 1)\n    seg2_start = random.randint(0, n - 2)\n    seg2_end = random.randint(seg2_start + 1, n - 1)\n\n    # Ensure segments don't overlap\n    if seg1_end >= seg2_start and seg1_start <= seg2_end:\n        if seg1_start < seg2_start:\n            seg2_start = seg1_end + 1\n            seg2_end = min(seg2_end, n - 1)\n        else:\n            seg1_start = seg2_end + 1\n            seg1_end = min(seg1_end, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[seg1_start:seg1_end+1] = candidate[seg1_start:seg1_end+1][::-1]\n    candidate[seg2_start:seg2_end+1] = candidate[seg2_start:seg2_end+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n\n    # Verify the solution is still valid (visits each node exactly once)\n    if len(set(candidate)) == n and len(candidate) == n:\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7908504578906908,
            2.6525920391082765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select two non-overlapping segments to invert\n    seg1_start = random.randint(0, n - 2)\n    seg1_end = random.randint(seg1_start + 1, n - 1)\n    seg2_start = random.randint(0, n - 2)\n    seg2_end = random.randint(seg2_start + 1, n - 1)\n\n    # Ensure segments don't overlap\n    if seg1_end >= seg2_start and seg1_start <= seg2_end:\n        if seg1_start < seg2_start:\n            seg2_start = seg1_end + 1\n            seg2_end = min(seg2_end, n - 1)\n        else:\n            seg1_start = seg2_end + 1\n            seg1_end = min(seg1_end, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[seg1_start:seg1_end+1] = candidate[seg1_start:seg1_end+1][::-1]\n    candidate[seg2_start:seg2_end+1] = candidate[seg2_start:seg2_end+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n\n    # Verify the solution is still valid (visits each node exactly once)\n    if len(set(candidate)) == n and len(candidate) == n:\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 3-opt heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (weighted sum of normalized objectives)\n    normalized_objectives = []\n    for obj in archive_objectives:\n        norm_obj = [o / (sum(obj) + 1e-6) for o in obj]\n        normalized_objectives.append(norm_obj)\n\n    objective_weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_scores = [sum(w * n for w, n in zip(objective_weights, norm_obj)) for norm_obj in normalized_objectives]\n\n    # Select solution with highest weighted score\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt heuristic\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three random nodes for 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n\n    # Apply 3-opt move\n    candidate[a:b+1] = candidate[a:b+1][::-1]\n    candidate[b:c+1] = candidate[b:c+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7282590946972543,
            2.8961421966552736
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (weighted sum of normalized objectives)\n    normalized_objectives = []\n    for obj in archive_objectives:\n        norm_obj = [o / (sum(obj) + 1e-6) for o in obj]\n        normalized_objectives.append(norm_obj)\n\n    objective_weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_scores = [sum(w * n for w, n in zip(objective_weights, norm_obj)) for norm_obj in normalized_objectives]\n\n    # Select solution with highest weighted score\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt heuristic\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three random nodes for 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n\n    # Apply 3-opt move\n    candidate[a:b+1] = candidate[a:b+1][::-1]\n    candidate[b:c+1] = candidate[b:c+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective improvements and diversity, then applies a novel multi-objective 2-opt* local search that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential\n    objective_weights = [0.4, 0.3, 0.3]  # Weighting for three objectives\n    weighted_sums = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt* heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select two random edges and apply 2-opt*\n    i = random.randint(0, n - 2)\n    j = random.randint(0, n - 2)\n    if i > j:\n        i, j = j, i\n\n    # Generate candidate solution\n    candidate = new_solution.copy()\n    if i + 1 <= j:\n        candidate[i+1:j+1] = candidate[i+1:j+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7517880957908434,
            3.4422348856925966
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential\n    objective_weights = [0.4, 0.3, 0.3]  # Weighting for three objectives\n    weighted_sums = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt* heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select two random edges and apply 2-opt*\n    i = random.randint(0, n - 2)\n    j = random.randint(0, n - 2)\n    if i > j:\n        i, j = j, i\n\n    # Generate candidate solution\n    candidate = new_solution.copy()\n    if i + 1 <= j:\n        candidate[i+1:j+1] = candidate[i+1:j+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    insert_pos = random.randint(0, len(candidate) - 1)\n    candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7229946265167994,
            3.07775000333786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    insert_pos = random.randint(0, len(candidate) - 1)\n    candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment and a new position to relocate it\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n    remaining = np.setdiff1d(new_solution, segment, assume_unique=True)\n    new_pos = random.randint(0, len(remaining) - 1)\n\n    # Create candidate solution\n    candidate = np.concatenate([remaining[:new_pos], segment, remaining[new_pos:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7973790460433798,
            3.190649724006653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment and a new position to relocate it\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n    remaining = np.setdiff1d(new_solution, segment, assume_unique=True)\n    new_pos = random.randint(0, len(remaining) - 1)\n\n    # Create candidate solution\n    candidate = np.concatenate([remaining[:new_pos], segment, remaining[new_pos:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probability based on objective diversity\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on selection probability\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective node insertion heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select a random node to remove and a random position to insert\n    remove_idx = random.randint(0, n - 1)\n    insert_idx = random.randint(0, n - 1)\n\n    # Calculate current costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by removing a node and inserting it elsewhere\n    candidate = new_solution.copy()\n    node = candidate[remove_idx]\n    candidate = np.delete(candidate, remove_idx)\n    candidate = np.insert(candidate, insert_idx, node)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7267435512147751,
            2.8119462370872497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probability based on objective diversity\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on selection probability\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective node insertion heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select a random node to remove and a random position to insert\n    remove_idx = random.randint(0, n - 1)\n    insert_idx = random.randint(0, n - 1)\n\n    # Calculate current costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by removing a node and inserting it elsewhere\n    candidate = new_solution.copy()\n    node = candidate[remove_idx]\n    candidate = np.delete(candidate, remove_idx)\n    candidate = np.insert(candidate, insert_idx, node)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 3-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7054716412475803,
            3.1644764065742494
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and their gradients, then applies a multi-objective 3-opt exchange heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8089233746283092,
            3.6447216272354126
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_weights = [0.4, 0.3, 0.3]\n    weighted_scores = [sum(w * o for w, o in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation operator that considers all three distance matrices simultaneously, rotating segments of the tour to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment rotation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment to rotate\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n\n    # Rotate the segment by a random amount\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = new_solution[start:end]\n    rotated_segment = np.roll(rotated_segment, rotation)\n\n    # Create candidate solution\n    candidate = new_solution.copy()\n    candidate[start:end] = rotated_segment\n\n    # Calculate costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n    candidate_cost = calculate_cost(candidate)\n\n    # Accept if better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7358989663705826,
            3.473870885372162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment rotation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment to rotate\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n\n    # Rotate the segment by a random amount\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = new_solution[start:end]\n    rotated_segment = np.roll(rotated_segment, rotation)\n\n    # Create candidate solution\n    candidate = new_solution.copy()\n    candidate[start:end] = rotated_segment\n\n    # Calculate costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n    candidate_cost = calculate_cost(candidate)\n\n    # Accept if better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7273340025029704,
            2.926029348373413
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search operator that combines multi-objective 2-opt exchanges with a novel segment relocation strategy, considering all three distance matrices simultaneously while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    if not archive_solutions:\n        return instance[:, 0].astype(int)\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid local search: 2-opt with segment relocation\n    for _ in range(10):  # Perform multiple iterations\n        operation = random.choice(['2opt', 'relocate'])\n\n        if operation == '2opt':\n            i, j = sorted(random.sample(range(n), 2))\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n        else:\n            i, j, k = sorted(random.sample(range(n), 3))\n            candidate = new_solution.copy()\n            segment = candidate[i:j+1]\n            candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n",
        "score": [
            -0.742680179253044,
            3.367021954059601
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    if not archive_solutions:\n        return instance[:, 0].astype(int)\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid local search: 2-opt with segment relocation\n    for _ in range(10):  # Perform multiple iterations\n        operation = random.choice(['2opt', 'relocate'])\n\n        if operation == '2opt':\n            i, j = sorted(random.sample(range(n), 2))\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n        else:\n            i, j, k = sorted(random.sample(range(n), 3))\n            candidate = new_solution.copy()\n            segment = candidate[i:j+1]\n            candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 3-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # 3-opt local search heuristic\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three random edges to reconnect (ensuring feasibility)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n    candidate[j:k+1] = candidate[j:k+1][::-1]  # Reverse another segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7388378661648243,
            3.1324483156204224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # 3-opt local search heuristic\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three random edges to reconnect (ensuring feasibility)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n    candidate[j:k+1] = candidate[j:k+1][::-1]  # Reverse another segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-segment inversion operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by intelligently selecting non-overlapping segments to invert.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 6:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    segments = sorted(random.sample(range(1, n-1), 2))\n    a, b = segments[0], segments[1]\n\n    candidate = new_solution.copy()\n    candidate[a:b+1] = candidate[a:b+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7741695759575578,
            2.654245340824127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 6:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    segments = sorted(random.sample(range(1, n-1), 2))\n    a, b = segments[0], segments[1]\n\n    candidate = new_solution.copy()\n    candidate[a:b+1] = candidate[a:b+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of weighted objective sum)\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective 2-opt heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select two random edges to reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i == 1:\n        i, j = (i, j+1 if j+1 < n else 0)\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7484565721714052,
            3.212903046607971
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of weighted objective sum)\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective 2-opt heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select two random edges to reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i == 1:\n        i, j = (i, j+1 if j+1 < n else 0)\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This heuristic selects a solution from the archive based on crowding distance in objective space to promote diversity, then applies a novel multi-objective segment inversion operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    if len(archive) < 2:\n        return archive_solutions[0].copy() if archive else np.array([])\n\n    # Calculate crowding distances in objective space\n    objectives = np.array(archive_objectives)\n    crowding = np.zeros(len(archive))\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        if len(archive) > 2:\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-6)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Novel segment inversion operator\n    k = random.randint(3, min(10, n//2))  # Segment length between 3 and 10 nodes\n    start = random.randint(0, n - k)\n    end = start + k\n\n    candidate = new_solution.copy()\n    candidate[start:end] = candidate[start:end][::-1]  # Invert the segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.35129234594344855,
            4.347438156604767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    if len(archive) < 2:\n        return archive_solutions[0].copy() if archive else np.array([])\n\n    # Calculate crowding distances in objective space\n    objectives = np.array(archive_objectives)\n    crowding = np.zeros(len(archive))\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        if len(archive) > 2:\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-6)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Novel segment inversion operator\n    k = random.randint(3, min(10, n//2))  # Segment length between 3 and 10 nodes\n    start = random.randint(0, n - k)\n    end = start + k\n\n    candidate = new_solution.copy()\n    candidate[start:end] = candidate[start:end][::-1]  # Invert the segment\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a multi-objective 3-opt exchange heuristic that simultaneously considers all three distance matrices to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate selection weights based on normalized objective values\n    normalized_objectives = np.array(archive_objectives)\n    min_obj = np.min(normalized_objectives, axis=0)\n    max_obj = np.max(normalized_objectives, axis=0)\n    normalized_objectives = (normalized_objectives - min_obj) / (max_obj - min_obj + 1e-6)\n\n    # Weighted sum of normalized objectives with random weights\n    weights = np.random.rand(3)\n    weighted_scores = np.sum(normalized_objectives * weights, axis=1)\n    selection_probs = 1.0 / (weighted_scores + 1e-6)\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # 3-opt local search\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        candidate = new_solution.copy()\n\n        # Apply 3-opt move\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        candidate[j:k+1] = candidate[j:k+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7888283599383439,
            3.4983682870864867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate selection weights based on normalized objective values\n    normalized_objectives = np.array(archive_objectives)\n    min_obj = np.min(normalized_objectives, axis=0)\n    max_obj = np.max(normalized_objectives, axis=0)\n    normalized_objectives = (normalized_objectives - min_obj) / (max_obj - min_obj + 1e-6)\n\n    # Weighted sum of normalized objectives with random weights\n    weights = np.random.rand(3)\n    weighted_scores = np.sum(normalized_objectives * weights, axis=1)\n    selection_probs = 1.0 / (weighted_scores + 1e-6)\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # 3-opt local search\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        candidate = new_solution.copy()\n\n        # Apply 3-opt move\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        candidate[j:k+1] = candidate[j:k+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective edge insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while j == i or j == (i+1)%n or j == (i-1)%n:\n        j = random.randint(0, n-1)\n\n    candidate = new_solution.copy()\n    candidate = np.delete(candidate, i)\n    candidate = np.insert(candidate, j, new_solution[i])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8312068785042488,
            2.6525505781173706
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while j == i or j == (i+1)%n or j == (i-1)%n:\n        j = random.randint(0, n-1)\n\n    candidate = new_solution.copy()\n    candidate = np.delete(candidate, i)\n    candidate = np.insert(candidate, j, new_solution[i])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 3-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8222547540364454,
            2.7403117299079893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective node insertion and reversal hybrid operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by carefully maintaining tour validity through intelligent node selection and segment reversal.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid operator: Node insertion and segment reversal\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    node = candidate[i]\n    candidate = np.delete(candidate, i)\n    candidate = np.insert(candidate, j, node)\n\n    # Randomly decide whether to reverse a segment\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n        candidate[k:l+1] = candidate[k:l+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7151967470887507,
            3.086407423019409
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid operator: Node insertion and segment reversal\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    node = candidate[i]\n    candidate = np.delete(candidate, i)\n    candidate = np.insert(candidate, j, node)\n\n    # Randomly decide whether to reverse a segment\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n        candidate[k:l+1] = candidate[k:l+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt local search that considers all three distance matrices to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all three objectives)\n    objective_weights = [0.4, 0.3, 0.3]  # Assign weights to each objective\n    weighted_sums = [sum(w * obj[i] for i, w in enumerate(objective_weights)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try multiple 2-opt moves and keep the best improvement\n    best_candidate = new_solution.copy()\n    best_improvement = 0\n\n    for _ in range(10):  # Try 10 random 2-opt moves\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n        candidate_cost = calculate_cost(candidate)\n        # Calculate improvement as the sum of improvements in all objectives\n        improvement = sum(max(curr - c, 0) for c, curr in zip(candidate_cost, current_cost))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_candidate = candidate.copy()\n\n    if best_improvement > 0:\n        new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8616817061325396,
            4.107075822353363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all three objectives)\n    objective_weights = [0.4, 0.3, 0.3]  # Assign weights to each objective\n    weighted_sums = [sum(w * obj[i] for i, w in enumerate(objective_weights)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try multiple 2-opt moves and keep the best improvement\n    best_candidate = new_solution.copy()\n    best_improvement = 0\n\n    for _ in range(10):  # Try 10 random 2-opt moves\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n        candidate_cost = calculate_cost(candidate)\n        # Calculate improvement as the sum of improvements in all objectives\n        improvement = sum(max(curr - c, 0) for c, curr in zip(candidate_cost, current_cost))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_candidate = candidate.copy()\n\n    if best_improvement > 0:\n        new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{This heuristic selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a multi-objective 3-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    weights = [0.3, 0.3, 0.4]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7596596745385616,
            3.2492446422576906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    weights = [0.3, 0.3, 0.4]\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility, using a novel approach that intelligently balances exploration and exploitation of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment to relocate\n    segment_length = random.randint(2, min(5, n-1))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try to insert the segment at different positions\n    for _ in range(3):\n        candidate = new_solution.copy()\n        candidate = np.delete(candidate, range(start, start+segment_length))\n        insert_pos = random.randint(0, len(candidate))\n        candidate = np.insert(candidate, insert_pos, segment)\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8498690112525514,
            2.726147997379303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment to relocate\n    segment_length = random.randint(2, min(5, n-1))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try to insert the segment at different positions\n    for _ in range(3):\n        candidate = new_solution.copy()\n        candidate = np.delete(candidate, range(start, start+segment_length))\n        insert_pos = random.randint(0, len(candidate))\n        candidate = np.insert(candidate, insert_pos, segment)\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective insertion-based heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by carefully selecting and inserting nodes to maintain a valid tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:i+1], [candidate[j]], candidate[i+1:j], candidate[j+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7290491934263137,
            2.101354885101318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:i+1], [candidate[j]], candidate[i+1:j], candidate[j+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment insertion heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to insert elsewhere\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, min(start + 2, n - 1))\n    segment = new_solution[start:end+1]\n\n    # Remove the segment from its current position\n    temp_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Select a new position to insert the segment\n    insert_pos = random.randint(0, len(temp_solution))\n\n    # Insert the segment back into the solution\n    candidate = np.concatenate([temp_solution[:insert_pos], segment, temp_solution[insert_pos:]])\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n    candidate_cost = calculate_cost(candidate)\n\n    # Accept the candidate if it's better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7953317390845405,
            2.9934000372886658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment insertion heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to insert elsewhere\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, min(start + 2, n - 1))\n    segment = new_solution[start:end+1]\n\n    # Remove the segment from its current position\n    temp_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Select a new position to insert the segment\n    insert_pos = random.randint(0, len(temp_solution))\n\n    # Insert the segment back into the solution\n    candidate = np.concatenate([temp_solution[:insert_pos], segment, temp_solution[insert_pos:]])\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n    candidate_cost = calculate_cost(candidate)\n\n    # Accept the candidate if it's better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and normalized improvement potential, then applies a multi-objective 3-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    max_sum = max(objective_sums) if objective_sums else 1.0\n    selection_probs = [(1.0 - (sum_val / max_sum)) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7025438959284572,
            3.6130772113800047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    max_sum = max(objective_sums) if objective_sums else 1.0\n    selection_probs = [(1.0 - (sum_val / max_sum)) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously, intelligently relocating a segment of the tour to a new position while ensuring feasibility and potentially improving at least one objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Find a new position to insert the segment\n    k = random.randint(0, n - len(segment))\n    candidate = new_solution.copy()\n    candidate = np.concatenate((candidate[:i], candidate[j+1:]))\n    candidate = np.insert(candidate, k, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7592108613611563,
            3.081125831604004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Find a new position to insert the segment\n    k = random.randint(0, n - len(segment))\n    candidate = new_solution.copy()\n    candidate = np.concatenate((candidate[:i], candidate[j+1:]))\n    candidate = np.insert(candidate, k, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers all three objectives simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7570949136115581,
            2.969091844558716
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8397603990763274,
            2.8265401482582093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective node-segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by relocating a randomly selected segment of nodes to a new position.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    new_pos = random.randint(0, n - segment_length)\n    while new_pos >= start and new_pos <= end:\n        new_pos = random.randint(0, n - segment_length)\n\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:start], candidate[end:]])\n    candidate = np.insert(candidate, new_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7324598475673965,
            2.985410749912262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    new_pos = random.randint(0, n - segment_length)\n    while new_pos >= start and new_pos <= end:\n        new_pos = random.randint(0, n - segment_length)\n\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:start], candidate[end:]])\n    candidate = np.insert(candidate, new_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (combining diversity and objective values)\n    objective_weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    weighted_sums = [sum(w * val for w, val in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reversing a segment\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7436326211592844,
            3.2690826654434204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (combining diversity and objective values)\n    objective_weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    weighted_sums = [sum(w * val for w, val in zip(objective_weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reversing a segment\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Multi-objective node insertion heuristic\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while j == i or j == (i+1)%n:\n        j = random.randint(0, n-1)\n\n    candidate = new_solution.copy()\n    node = candidate[i]\n    candidate = np.delete(candidate, i)\n    candidate = np.insert(candidate, j, node)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8414667138216798,
            3.039013910293579
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Multi-objective node insertion heuristic\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while j == i or j == (i+1)%n:\n        j = random.randint(0, n-1)\n\n    candidate = new_solution.copy()\n    node = candidate[i]\n    candidate = np.delete(candidate, i)\n    candidate = np.insert(candidate, j, node)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]  # Swap two nodes\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7421021249244061,
            2.9728531718254088
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]  # Swap two nodes\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel 3-opt local search operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7621638147728358,
            3.027442193031311
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.758287408144916,
            2.51487283706665
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation operator that simultaneously considers all three distance matrices to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment rotation heuristic\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select a segment to rotate\n    segment_length = random.randint(3, min(5, n-2))\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate by rotating the segment\n    candidate = new_solution.copy()\n    rotation_amount = random.randint(1, segment_length-1)\n    segment = candidate[start:end]\n    rotated_segment = np.roll(segment, rotation_amount)\n    candidate[start:end] = rotated_segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7192161260290877,
            3.181681454181671
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment rotation heuristic\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select a segment to rotate\n    segment_length = random.randint(3, min(5, n-2))\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate by rotating the segment\n    candidate = new_solution.copy()\n    rotation_amount = random.randint(1, segment_length-1)\n    segment = candidate[start:end]\n    rotated_segment = np.roll(segment, rotation_amount)\n    candidate[start:end] = rotated_segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective 2-opt* local search that simultaneously considers all three distance matrices to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective 2-opt* heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by removing two non-adjacent edges and reconnecting\n    for _ in range(10):  # Try multiple times to find a good candidate\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n",
        "score": [
            -0.7895062736312091,
            2.9358317852020264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective 2-opt* heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by removing two non-adjacent edges and reconnecting\n    for _ in range(10):  # Try multiple times to find a good candidate\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    k = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7053573522090444,
            2.1821691393852234
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    k = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{This algorithm selects a solution from the archive based on objective diversity and applies a multi-objective 2-opt heuristic that simultaneously considers all three distance matrices to generate a neighbor solution while maintaining feasibility, using a weighted random selection to balance exploration and exploitation across objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection weights based on objective diversity and potential improvement\n    objective_weights = []\n    for obj in archive_objectives:\n        # Weight by inverse of the product of objectives (encourages diverse solutions)\n        weight = 1.0 / (obj[0] * obj[1] * obj[2] + 1e-6)\n        objective_weights.append(weight)\n\n    total_weight = sum(objective_weights)\n    selection_probs = [w / total_weight for w in objective_weights]\n\n    # Randomly select a solution based on weights\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-objective 2-opt heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select two random non-adjacent edges to swap\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7570572248250784,
            2.458538556098938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection weights based on objective diversity and potential improvement\n    objective_weights = []\n    for obj in archive_objectives:\n        # Weight by inverse of the product of objectives (encourages diverse solutions)\n        weight = 1.0 / (obj[0] * obj[1] * obj[2] + 1e-6)\n        objective_weights.append(weight)\n\n    total_weight = sum(objective_weights)\n    selection_probs = [w / total_weight for w in objective_weights]\n\n    # Randomly select a solution based on weights\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-objective 2-opt heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select two random non-adjacent edges to swap\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]  # Swap nodes\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8402417188586435,
            2.5200152158737184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]  # Swap nodes\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation operator that considers the three distance matrices simultaneously, ensuring feasibility by carefully maintaining the tour structure while exploring promising regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel segment relocation operator\n    segment_length = random.randint(2, min(4, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n\n    # Extract the segment\n    segment = new_solution[start:end]\n\n    # Remove the segment from the solution\n    candidate = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Insert the segment at a new random position\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n\n    # Calculate current and candidate costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n    candidate_cost = calculate_cost(candidate)\n\n    # Accept the candidate if it's better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7655234330558545,
            2.752211666107178
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel segment relocation operator\n    segment_length = random.randint(2, min(4, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n\n    # Extract the segment\n    segment = new_solution[start:end]\n\n    # Remove the segment from the solution\n    candidate = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Insert the segment at a new random position\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n\n    # Calculate current and candidate costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n    candidate_cost = calculate_cost(candidate)\n\n    # Accept the candidate if it's better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective 3-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6685858348873313,
            3.144392466545105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and their normalized distances to the ideal point, then applies a multi-objective 3-opt heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_values = np.array(archive_objectives)\n    ideal_point = np.min(objective_values, axis=0)\n    nadir_point = np.max(objective_values, axis=0)\n\n    normalized_distances = (objective_values - ideal_point) / (nadir_point - ideal_point + 1e-6)\n    weighted_sum = np.sum(normalized_distances * [0.4, 0.3, 0.3], axis=1)\n\n    selection_probs = 1.0 / (weighted_sum + 1e-6)\n    total_prob = np.sum(selection_probs)\n    selection_probs = selection_probs / total_prob\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.660947218657404,
            4.268802046775818
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_values = np.array(archive_objectives)\n    ideal_point = np.min(objective_values, axis=0)\n    nadir_point = np.max(objective_values, axis=0)\n\n    normalized_distances = (objective_values - ideal_point) / (nadir_point - ideal_point + 1e-6)\n    weighted_sum = np.sum(normalized_distances * [0.4, 0.3, 0.3], axis=1)\n\n    selection_probs = 1.0 / (weighted_sum + 1e-6)\n    total_prob = np.sum(selection_probs)\n    selection_probs = selection_probs / total_prob\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by rotating segments of the tour in a way that maintains tour validity and explores diverse structural changes across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three random positions for segment rotation\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Generate candidate by rotating segments\n    candidate = new_solution.copy()\n    segment1 = candidate[i:j]\n    segment2 = candidate[j:k]\n    candidate[i:k] = np.concatenate([segment2, segment1])\n\n    candidate_cost = calculate_cost(candidate)\n\n    # Accept if better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7433145129439089,
            2.870830476284027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection probabilities based on objective diversity\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three random positions for segment rotation\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Generate candidate by rotating segments\n    candidate = new_solution.copy()\n    segment1 = candidate[i:j]\n    segment2 = candidate[j:k]\n    candidate[i:k] = np.concatenate([segment2, segment1])\n\n    candidate_cost = calculate_cost(candidate)\n\n    # Accept if better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a multi-objective 3-opt exchange heuristic that simultaneously considers the three distance matrices to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7839383183020965,
            3.1944636702537537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a segment to rotate\n    i = random.randint(0, n - 1)\n    segment_length = random.randint(2, min(5, n - 1))\n    j = (i + segment_length) % n\n\n    if i < j:\n        segment = new_solution[i:j].copy()\n    else:\n        segment = np.concatenate([new_solution[i:], new_solution[:j]])\n\n    # Rotate the segment\n    rotation = random.randint(1, len(segment) - 1)\n    rotated_segment = np.roll(segment, rotation)\n\n    # Apply the rotation\n    candidate = new_solution.copy()\n    if i < j:\n        candidate[i:j] = rotated_segment\n    else:\n        candidate[i:] = rotated_segment[:n-i]\n        candidate[:j] = rotated_segment[n-i:]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7199402059458586,
            3.0673216938972474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a segment to rotate\n    i = random.randint(0, n - 1)\n    segment_length = random.randint(2, min(5, n - 1))\n    j = (i + segment_length) % n\n\n    if i < j:\n        segment = new_solution[i:j].copy()\n    else:\n        segment = np.concatenate([new_solution[i:], new_solution[:j]])\n\n    # Rotate the segment\n    rotation = random.randint(1, len(segment) - 1)\n    rotated_segment = np.roll(segment, rotation)\n\n    # Apply the rotation\n    candidate = new_solution.copy()\n    if i < j:\n        candidate[i:j] = rotated_segment\n    else:\n        candidate[i:] = rotated_segment[:n-i]\n        candidate[:j] = rotated_segment[n-i:]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective improvements and diversity, then applies a hybrid local search operator that considers all three objectives simultaneously using a probabilistic edge-swap approach with adaptive segment reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement scores considering all three objectives\n    weights = [0.4, 0.3, 0.3]  # Higher weight for the first objective\n    weighted_scores = [sum(w * v for w, v in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid multi-objective local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection based on objective improvements\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate multiple candidates and select the best one\n    best_candidate = new_solution.copy()\n    best_improvement = 0\n\n    for _ in range(5):  # Generate 5 candidates\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n        candidate_cost = calculate_cost(candidate)\n        improvement = sum(curr - c for c, curr in zip(candidate_cost, current_cost) if c < curr)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_candidate = candidate\n\n    if best_improvement > 0:\n        new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.738672137906365,
            3.16158527135849
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement scores considering all three objectives\n    weights = [0.4, 0.3, 0.3]  # Higher weight for the first objective\n    weighted_scores = [sum(w * v for w, v in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid multi-objective local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection based on objective improvements\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate multiple candidates and select the best one\n    best_candidate = new_solution.copy()\n    best_improvement = 0\n\n    for _ in range(5):  # Generate 5 candidates\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n        candidate_cost = calculate_cost(candidate)\n        improvement = sum(curr - c for c, curr in zip(candidate_cost, current_cost) if c < curr)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_candidate = candidate\n\n    if best_improvement > 0:\n        new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective hybrid local search that combines segment reversal with node insertion, considering all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid local search: segment reversal followed by node insertion\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Randomly select a node to insert elsewhere\n    k = random.randint(0, n-1)\n    node = candidate[k]\n    candidate = np.delete(candidate, k)\n    insert_pos = random.randint(0, n-2)\n    candidate = np.insert(candidate, insert_pos, node)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7599173435149447,
            3.169792914390564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid local search: segment reversal followed by node insertion\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Randomly select a node to insert elsewhere\n    k = random.randint(0, n-1)\n    node = candidate[k]\n    candidate = np.delete(candidate, k)\n    insert_pos = random.randint(0, n-2)\n    candidate = np.insert(candidate, insert_pos, node)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 3-opt local search operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three random edges to reconnect (ensuring feasibility)\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[l], sol[l+1]] for l in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[l], sol[l+1]] for l in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[l], sol[l+1]] for l in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]  # Reverse segment between i and j\n    candidate[j:k] = candidate[j:k][::-1]  # Reverse segment between j and k\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7762233829332248,
            2.885876512527466
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three random edges to reconnect (ensuring feasibility)\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[l], sol[l+1]] for l in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[l], sol[l+1]] for l in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[l], sol[l+1]] for l in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reconnecting edges\n    candidate = new_solution.copy()\n    candidate[i:j] = candidate[i:j][::-1]  # Reverse segment between i and j\n    candidate[j:k] = candidate[j:k][::-1]  # Reverse segment between j and k\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective node-swap-and-reverse hybrid heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select two random nodes and swap them\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Apply a segment reversal between the swapped nodes\n    if j - i > 1:\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7610892153347709,
            2.708015739917755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select two random nodes and swap them\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Apply a segment reversal between the swapped nodes\n    if j - i > 1:\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel hybrid local search operator that combines 2-opt with a multi-objective edge insertion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid local search: 2-opt + edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Edge insertion step\n    k, l = sorted(random.sample(range(n), 2))\n    if k != l:\n        candidate = np.concatenate((candidate[:k], candidate[l:], candidate[k:l]))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7298743715577152,
            3.1847265481948854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid local search: 2-opt + edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Edge insertion step\n    k, l = sorted(random.sample(range(n), 2))\n    if k != l:\n        candidate = np.concatenate((candidate[:k], candidate[l:], candidate[k:l]))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This heuristic selects a solution from the archive based on both objective diversity and potential for improvement, then applies a hybrid 2-opt and relocate move strategy that simultaneously considers all three distance matrices to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    move_type = random.choice(['2opt', 'relocate'])\n\n    if move_type == '2opt':\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n    else:\n        i, j = random.sample(range(n), 2)\n        candidate = new_solution.copy()\n        node = candidate[i]\n        candidate = np.delete(candidate, i)\n        candidate = np.insert(candidate, j, node)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7492309123581289,
            2.94457426071167
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    move_type = random.choice(['2opt', 'relocate'])\n\n    if move_type == '2opt':\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n    else:\n        i, j = random.sample(range(n), 2)\n        candidate = new_solution.copy()\n        node = candidate[i]\n        candidate = np.delete(candidate, i)\n        candidate = np.insert(candidate, j, node)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously, with a probability-based acceptance criterion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Probabilistic acceptance based on improvement in objectives\n    candidate_cost = calculate_cost(candidate)\n    improvement = sum(1 for c, curr in zip(candidate_cost, current_cost) if c < curr)\n    if improvement > 0:\n        # Higher probability if more objectives are improved\n        accept_prob = min(1.0, improvement / 3.0)\n        if random.random() < accept_prob:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6219086210436199,
            3.3101067304611207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Probabilistic acceptance based on improvement in objectives\n    candidate_cost = calculate_cost(candidate)\n    improvement = sum(1 for c, curr in zip(candidate_cost, current_cost) if c < curr)\n    if improvement > 0:\n        # Higher probability if more objectives are improved\n        accept_prob = min(1.0, improvement / 3.0)\n        if random.random() < accept_prob:\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and edge diversity, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted objective scores (higher weight for lower values)\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    objective_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in objective_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted objective scores\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7178726179621358,
            2.741080093383789
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted objective scores (higher weight for lower values)\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    objective_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in objective_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted objective scores\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential\n    weights = [0.4, 0.3, 0.3]  # Different weights for each objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reversing a segment\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7437427547574854,
            2.979909610748291
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential\n    weights = [0.4, 0.3, 0.3]  # Different weights for each objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by reversing a segment\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and edge diversity, then applies a multi-objective 2-opt local search that considers all three distance matrices simultaneously to generate an improved neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted objective scores (higher weight for worse objectives)\n    weights = [0.3, 0.5, 0.2]  # Example weights for three objectives\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted scores\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7212375239385276,
            3.4583106875419616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted objective scores (higher weight for worse objectives)\n    weights = [0.3, 0.5, 0.2]  # Example weights for three objectives\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in weighted_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted scores\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by intelligently relocating a random segment of the tour to a new position.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, n - 1)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Remove the segment from the solution\n    candidate = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n    # Insert the segment at a random new position\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7383111584962351,
            2.9793094992637634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, n - 1)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Remove the segment from the solution\n    candidate = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n    # Insert the segment at a random new position\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j]\n    candidate = np.concatenate([candidate[:i], candidate[j:], segment])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.69605070148657,
            1.9754294514656068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j]\n    candidate = np.concatenate([candidate[:i], candidate[j:], segment])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a segment to relocate\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, min(seg_start + 5, n - 1))\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a new position to insert the segment\n    insert_pos = random.randint(0, n - len(segment))\n    if insert_pos >= seg_start:\n        insert_pos += len(segment)\n\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7594419129564579,
            2.1622250080108643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a segment to relocate\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, min(seg_start + 5, n - 1))\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a new position to insert the segment\n    insert_pos = random.randint(0, n - len(segment))\n    if insert_pos >= seg_start:\n        insert_pos += len(segment)\n\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment relocation operator\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Randomly select a segment and a new position\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, min(seg_start + 3, n - 1))\n    new_pos = random.randint(0, n - (seg_end - seg_start + 1))\n\n    # Generate candidate solution\n    candidate = new_solution.copy()\n    segment = candidate[seg_start:seg_end+1]\n    candidate = np.concatenate([candidate[:seg_start], candidate[seg_end+1:]])\n    candidate = np.insert(candidate, new_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7638979969996188,
            3.061116576194763
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate diversity and improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment relocation operator\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Randomly select a segment and a new position\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, min(seg_start + 3, n - 1))\n    new_pos = random.randint(0, n - (seg_end - seg_start + 1))\n\n    # Generate candidate solution\n    candidate = new_solution.copy()\n    segment = candidate[seg_start:seg_end+1]\n    candidate = np.concatenate([candidate[:seg_start], candidate[seg_end+1:]])\n    candidate = np.insert(candidate, new_pos, segment)\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously, moving a randomly selected segment to a new position while ensuring feasibility and potentially improving multiple objectives at once.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n-3)\n    seg_end = random.randint(seg_start+1, n-1)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n-1)\n    if new_pos >= seg_start and new_pos <= seg_end:\n        new_pos = (new_pos + seg_end - seg_start + 1) % n\n\n    # Create candidate solution\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:new_pos],\n        segment,\n        new_solution[new_pos:]\n    ])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.749476595092303,
            2.312966752052307
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n-3)\n    seg_end = random.randint(seg_start+1, n-1)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n-1)\n    if new_pos >= seg_start and new_pos <= seg_end:\n        new_pos = (new_pos + seg_end - seg_start + 1) % n\n\n    # Create candidate solution\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:new_pos],\n        segment,\n        new_solution[new_pos:]\n    ])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted combination of objective values and their standard deviations, then applies a multi-objective 3-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objectives = np.array(archive_objectives)\n    obj_weights = np.std(objectives, axis=0)\n    obj_weights = obj_weights / np.sum(obj_weights) if np.sum(obj_weights) > 0 else np.ones(3) / 3\n\n    weighted_scores = np.dot(objectives, obj_weights)\n    selection_probs = 1.0 / (weighted_scores + 1e-6)\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    for _ in range(3):\n        i, j, k = sorted(random.sample(range(n), 3))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        candidate[j:k+1] = candidate[j:k+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n",
        "score": [
            -0.7679079648280078,
            2.8557945847511292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objectives = np.array(archive_objectives)\n    obj_weights = np.std(objectives, axis=0)\n    obj_weights = obj_weights / np.sum(obj_weights) if np.sum(obj_weights) > 0 else np.ones(3) / 3\n\n    weighted_scores = np.dot(objectives, obj_weights)\n    selection_probs = 1.0 / (weighted_scores + 1e-6)\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    for _ in range(3):\n        i, j, k = sorted(random.sample(range(n), 3))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        candidate[j:k+1] = candidate[j:k+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a hybrid 2-opt and insertion heuristic that considers all three objectives simultaneously to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted sum of objectives (prioritizing diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate weighted objective sums (weights can be adjusted)\n    weights = [0.4, 0.3, 0.3]  # Example weights for three objectives\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n\n    # Select solution with highest weighted sum (more diverse potential)\n    selected_idx = np.argmax(weighted_sums)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid heuristic: 2-opt with objective-aware insertion\n    i = random.randint(0, n - 2)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try 2-opt move\n    candidate = new_solution.copy()\n    if i < j:\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n    else:\n        candidate[i:] = candidate[i:][::-1]\n        candidate[:j+1] = candidate[:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n\n    # If 2-opt doesn't improve, try insertion\n    if not any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        candidate = new_solution.copy()\n        node = candidate[i]\n        candidate = np.delete(candidate, i)\n        insert_pos = random.randint(0, n - 2)\n        candidate = np.insert(candidate, insert_pos, node)\n        candidate_cost = calculate_cost(candidate)\n\n    # Accept if better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7132523781860172,
            2.136776626110077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted sum of objectives (prioritizing diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate weighted objective sums (weights can be adjusted)\n    weights = [0.4, 0.3, 0.3]  # Example weights for three objectives\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n\n    # Select solution with highest weighted sum (more diverse potential)\n    selected_idx = np.argmax(weighted_sums)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid heuristic: 2-opt with objective-aware insertion\n    i = random.randint(0, n - 2)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try 2-opt move\n    candidate = new_solution.copy()\n    if i < j:\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n    else:\n        candidate[i:] = candidate[i:][::-1]\n        candidate[:j+1] = candidate[:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n\n    # If 2-opt doesn't improve, try insertion\n    if not any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        candidate = new_solution.copy()\n        node = candidate[i]\n        candidate = np.delete(candidate, i)\n        insert_pos = random.randint(0, n - 2)\n        candidate = np.insert(candidate, insert_pos, node)\n        candidate_cost = calculate_cost(candidate)\n\n    # Accept if better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective hybrid local search operator that combines node insertion and edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid local search: node insertion followed by edge reversal\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    node = candidate[i]\n    candidate = np.delete(candidate, i)\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, node)\n\n    # Reverse a segment to create additional diversity\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 1)\n    candidate[k:l+1] = candidate[k:l+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.771826423682627,
            3.0888064742088317
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Hybrid local search: node insertion followed by edge reversal\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    node = candidate[i]\n    candidate = np.delete(candidate, i)\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.insert(candidate, insert_pos, node)\n\n    # Reverse a segment to create additional diversity\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 1)\n    candidate[k:l+1] = candidate[k:l+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective improvements and diversity, then applies a hybrid local search operator that combines 2-opt moves with multi-objective edge insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (weighted combination of normalized objectives)\n    normalized_objectives = []\n    for obj in archive_objectives:\n        norm_obj = [obj[i] / (sum(obj) + 1e-6) for i in range(3)]\n        normalized_objectives.append(norm_obj)\n\n    selection_weights = [sum(norm_obj) for norm_obj in normalized_objectives]\n    total_weight = sum(selection_weights)\n    selection_probs = [w / total_weight for w in selection_weights]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt move with multi-objective edge insertion\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by performing 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n    else:\n        # If no improvement, try edge insertion\n        k = random.randint(0, n-1)\n        m = random.randint(0, n-1)\n        if k != m and abs(k - m) > 1:\n            candidate = new_solution.copy()\n            candidate[k], candidate[m] = candidate[m], candidate[k]\n            candidate_cost = calculate_cost(candidate)\n            if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n                new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7648265241362033,
            3.2596166491508485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (weighted combination of normalized objectives)\n    normalized_objectives = []\n    for obj in archive_objectives:\n        norm_obj = [obj[i] / (sum(obj) + 1e-6) for i in range(3)]\n        normalized_objectives.append(norm_obj)\n\n    selection_weights = [sum(norm_obj) for norm_obj in normalized_objectives]\n    total_weight = sum(selection_weights)\n    selection_probs = [w / total_weight for w in selection_weights]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt move with multi-objective edge insertion\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by performing 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n    else:\n        # If no improvement, try edge insertion\n        k = random.randint(0, n-1)\n        m = random.randint(0, n-1)\n        if k != m and abs(k - m) > 1:\n            candidate = new_solution.copy()\n            candidate[k], candidate[m] = candidate[m], candidate[k]\n            candidate_cost = calculate_cost(candidate)\n            if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n                new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by relocating a random segment of nodes to a new position in the tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n-2)\n    seg_end = random.randint(seg_start+1, n-1)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n-1)\n    if new_pos > seg_start:\n        new_pos -= (seg_end - seg_start + 1)\n\n    candidate = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:seg_start],\n        new_solution[seg_end+1:]\n    ])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.681847798011022,
            2.116270697116852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n-2)\n    seg_end = random.randint(seg_start+1, n-1)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n-1)\n    if new_pos > seg_start:\n        new_pos -= (seg_end - seg_start + 1)\n\n    candidate = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:seg_start],\n        new_solution[seg_end+1:]\n    ])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously, moving entire segments of the tour to different positions while ensuring feasibility and potentially improving multiple objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n-3)\n    seg_end = random.randint(seg_start+1, n-2)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a random new position\n    new_pos = random.randint(0, n-1)\n    while new_pos >= seg_start and new_pos <= seg_end:\n        new_pos = random.randint(0, n-1)\n\n    # Create candidate solution\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:new_pos+1],\n        segment,\n        new_solution[new_pos+1:]\n    ])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8032740755040256,
            1.844494593143463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n-3)\n    seg_end = random.randint(seg_start+1, n-2)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a random new position\n    new_pos = random.randint(0, n-1)\n    while new_pos >= seg_start and new_pos <= seg_end:\n        new_pos = random.randint(0, n-1)\n\n    # Create candidate solution\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:new_pos+1],\n        segment,\n        new_solution[new_pos+1:]\n    ])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6795315779383557,
            1.7343960285186768
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    for _ in range(10):\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n",
        "score": [
            -0.8274234830605609,
            2.914636290073395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    for _ in range(10):\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment rotation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7823815728942595,
            2.8726325631141663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:k+1], segment, candidate[k+1:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a multi-objective 2-opt heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted objective score (higher weights for better objectives)\n    weights = [0.6, 0.3, 0.1]  # Weight for each objective\n    objective_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in objective_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted score\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by performing 2-opt move\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7244733680486622,
            3.323638689517975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted objective score (higher weights for better objectives)\n    weights = [0.6, 0.3, 0.1]  # Weight for each objective\n    objective_scores = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (score + 1e-6) for score in objective_scores]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted score\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by performing 2-opt move\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution by strategically swapping nodes in a way that balances improvement across all objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Multi-objective node-swap heuristic\n    i, j = random.sample(range(n), 2)\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n    else:\n        # If no improvement, try a different node pair\n        k, l = random.sample(range(n), 2)\n        candidate = new_solution.copy()\n        candidate[k], candidate[l] = candidate[l], candidate[k]\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8514296790214821,
            2.4390843749046325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Multi-objective node-swap heuristic\n    i, j = random.sample(range(n), 2)\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n    else:\n        # If no improvement, try a different node pair\n        k, l = random.sample(range(n), 2)\n        candidate = new_solution.copy()\n        candidate[k], candidate[l] = candidate[l], candidate[k]\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt local search that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7514168248890628,
            2.733320474624634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a multi-objective 2-opt heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8014572356027552,
            2.353683352470398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7355664413957523,
            2.7503204107284547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment insertion heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to insert elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Remove the segment from the solution\n    candidate = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert the segment at a random position\n    insert_pos = random.randint(0, len(candidate) - 1)\n    candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n    candidate_cost = calculate_cost(candidate)\n\n    # Check if the candidate is better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7404878334980347,
            2.8281246781349183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment insertion heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to insert elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Remove the segment from the solution\n    candidate = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert the segment at a random position\n    insert_pos = random.randint(0, len(candidate) - 1)\n    candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n    candidate_cost = calculate_cost(candidate)\n\n    # Check if the candidate is better in at least one objective\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt heuristic that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection scores based on objective diversity and improvement potential\n    objective_means = np.mean([sum(obj) for obj in archive_objectives])\n    selection_scores = [(1.0 / (sum(obj) + 1e-6)) * (sum(obj) / objective_means) for obj in archive_objectives]\n    total_score = sum(selection_scores)\n    selection_probs = [s / total_score for s in selection_scores]\n\n    # Randomly select a solution based on the scores\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.76734255201689,
            3.4042816877365114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate selection scores based on objective diversity and improvement potential\n    objective_means = np.mean([sum(obj) for obj in archive_objectives])\n    selection_scores = [(1.0 / (sum(obj) + 1e-6)) * (sum(obj) / objective_means) for obj in archive_objectives]\n    total_score = sum(selection_scores)\n    selection_probs = [s / total_score for s in selection_scores]\n\n    # Randomly select a solution based on the scores\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment and a new position to relocate it\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n    insert_pos = random.randint(0, n - segment_length - 1)\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    segment = candidate[start:end]\n    candidate = np.concatenate([candidate[:start], candidate[end:]])\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.725106658305666,
            3.0572785258293154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment and a new position to relocate it\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n    insert_pos = random.randint(0, n - segment_length - 1)\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    segment = candidate[start:end]\n    candidate = np.concatenate([candidate[:start], candidate[end:]])\n    candidate = np.insert(candidate, insert_pos, segment)\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a novel 2-opt* local search operator that considers all three objectives simultaneously, balancing improvements across all objectives while ensuring feasibility through a multi-criteria acceptance criterion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3))\n    weighted_sums = objectives @ weights\n    selected_idx = np.argmax(weighted_sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # 2-opt* with multi-objective acceptance\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return np.array([cost1, cost2, cost3])\n\n    current_cost = calculate_cost(base_solution)\n    best_cost = current_cost.copy()\n    best_solution = base_solution.copy()\n\n    # Try multiple random 2-opt moves\n    for _ in range(min(10, n)):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i <= 1:\n            continue\n\n        candidate = base_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n        candidate_cost = calculate_cost(candidate)\n\n        # Multi-criteria acceptance\n        if (np.sum(candidate_cost < best_cost) >= 2) or (np.sum(candidate_cost <= best_cost) == 3):\n            best_cost = candidate_cost\n            best_solution = candidate\n\n    return best_solution\n\n",
        "score": [
            -0.6828769720240356,
            3.803542363643646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3))\n    weighted_sums = objectives @ weights\n    selected_idx = np.argmax(weighted_sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # 2-opt* with multi-objective acceptance\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return np.array([cost1, cost2, cost3])\n\n    current_cost = calculate_cost(base_solution)\n    best_cost = current_cost.copy()\n    best_solution = base_solution.copy()\n\n    # Try multiple random 2-opt moves\n    for _ in range(min(10, n)):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i <= 1:\n            continue\n\n        candidate = base_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n        candidate_cost = calculate_cost(candidate)\n\n        # Multi-criteria acceptance\n        if (np.sum(candidate_cost < best_cost) >= 2) or (np.sum(candidate_cost <= best_cost) == 3):\n            best_cost = candidate_cost\n            best_solution = candidate\n\n    return best_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt* local search that considers the three distance matrices simultaneously, where it randomly selects two non-adjacent edges and reinserts them in a way that minimizes the total tour length across all objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two non-adjacent edges at random\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) <= 1:\n        j = random.randint(0, n - 1)\n\n    # Ensure i < j for simplicity\n    if i > j:\n        i, j = j, i\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate by reinserting edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8189658007415378,
            2.755884897708893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two non-adjacent edges at random\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) <= 1:\n        j = random.randint(0, n - 1)\n\n    # Ensure i < j for simplicity\n    if i > j:\n        i, j = j, i\n\n    # Calculate current cost\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate by reinserting edges\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 3-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7166072576013838,
            2.7785159230232237
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective node insertion heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select a random node to remove and reinsert\n    node_to_remove = random.randint(0, n - 1)\n    removed_node = new_solution[node_to_remove]\n\n    # Remove the node from the solution\n    candidate = np.delete(new_solution, node_to_remove)\n\n    # Calculate current costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-2)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-2)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-2)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(candidate)\n\n    # Find the best insertion position for the removed node\n    best_position = -1\n    best_cost = current_cost\n\n    for i in range(n-1):\n        # Insert the node at position i\n        temp_solution = np.insert(candidate, i, removed_node)\n        temp_cost = calculate_cost(temp_solution)\n\n        # Check if the candidate is better in at least one objective\n        if any(c < curr for c, curr in zip(temp_cost, current_cost)):\n            best_position = i\n            best_cost = temp_cost\n            break\n\n    if best_position != -1:\n        new_solution = np.insert(candidate, best_position, removed_node)\n\n    return new_solution\n\n",
        "score": [
            -0.6848858663627041,
            2.2874736189842224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective node insertion heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select a random node to remove and reinsert\n    node_to_remove = random.randint(0, n - 1)\n    removed_node = new_solution[node_to_remove]\n\n    # Remove the node from the solution\n    candidate = np.delete(new_solution, node_to_remove)\n\n    # Calculate current costs\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-2)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-2)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-2)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(candidate)\n\n    # Find the best insertion position for the removed node\n    best_position = -1\n    best_cost = current_cost\n\n    for i in range(n-1):\n        # Insert the node at position i\n        temp_solution = np.insert(candidate, i, removed_node)\n        temp_cost = calculate_cost(temp_solution)\n\n        # Check if the candidate is better in at least one objective\n        if any(c < curr for c, curr in zip(temp_cost, current_cost)):\n            best_position = i\n            best_cost = temp_cost\n            break\n\n    if best_position != -1:\n        new_solution = np.insert(candidate, best_position, removed_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation operator that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by carefully selecting and relocating segments of the tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Select a new position to insert the segment\n    k = random.randint(0, n - len(segment) - 1)\n    if k >= i:\n        k += len(segment)\n\n    # Create candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    candidate = np.concatenate([candidate[:k], segment, candidate[k:]])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7830859634435815,
            2.7810839414596558
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Select a new position to insert the segment\n    k = random.randint(0, n - len(segment) - 1)\n    if k >= i:\n        k += len(segment)\n\n    # Create candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    candidate = np.concatenate([candidate[:k], segment, candidate[k:]])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by carefully relocating segments between random positions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    if i == 0:\n        start = n - 1\n    else:\n        start = i - 1\n    end = j + 1 if j < n - 1 else 0\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7549370186431734,
            3.1641508817672728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    if i == 0:\n        start = n - 1\n    else:\n        start = i - 1\n    end = j + 1 if j < n - 1 else 0\n\n    candidate = new_solution.copy()\n    segment = candidate[i:j+1]\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    insert_pos = random.randint(0, len(candidate))\n    candidate = np.concatenate([candidate[:insert_pos], segment, candidate[insert_pos:]])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This heuristic selects a solution from the archive based on objective diversity and applies a novel 3-opt local search that simultaneously optimizes all three objectives by considering edge swaps that improve at least one objective while minimally affecting the others.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_diversity = [sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(i+1, 3)) for obj in archive_objectives]\n    selection_probs = [div + 1e-6 for div in objective_diversity]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6942948107504731,
            3.9599923491477966
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_diversity = [sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(i+1, 3)) for obj in archive_objectives]\n    selection_probs = [div + 1e-6 for div in objective_diversity]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j, k = sorted(random.sample(range(n), 3))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate[j:k+1] = candidate[j:k+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective 2-opt heuristic that considers the three distance matrices simultaneously, using a weighted combination of improvements to guide the search while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential using weighted combination of objectives\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7533527941465465,
            3.1460280895233153
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential using weighted combination of objectives\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted score (diversity + improvement potential)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    diversity_scores = [1.0 / (1 + np.std([o[i] for o in archive_objectives])) for i in range(3)]\n    weighted_scores = [0.4 * (1.0 / (sum_val + 1e-6)) + 0.6 * sum(diversity_scores) for sum_val in objective_sums]\n    total_score = sum(weighted_scores)\n    selection_probs = [s / total_score for s in weighted_scores]\n\n    # Randomly select a solution based on weighted score\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7864135412891635,
            3.845092248916626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted score (diversity + improvement potential)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    diversity_scores = [1.0 / (1 + np.std([o[i] for o in archive_objectives])) for i in range(3)]\n    weighted_scores = [0.4 * (1.0 / (sum_val + 1e-6)) + 0.6 * sum(diversity_scores) for sum_val in objective_sums]\n    total_score = sum(weighted_scores)\n    selection_probs = [s / total_score for s in weighted_scores]\n\n    # Randomly select a solution based on weighted score\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a novel 3D segment reversal local search that considers all three objectives simultaneously to generate an improved neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted objective diversity score\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    normalized_objectives = []\n    for obj in archive_objectives:\n        norm_obj = [obj[i] / sum(obj) for i in range(3)]\n        weighted_score = sum(norm_obj[i] * weights[i] for i in range(3))\n        normalized_objectives.append(weighted_score)\n\n    # Select based on both diversity and improvement potential\n    selection_probs = [1.0 / (score + 1e-6) for score in normalized_objectives]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # 3D segment reversal local search\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select a random segment to reverse\n    start = random.randint(0, n - 5)\n    length = random.randint(3, min(5, n - start - 1))\n    end = start + length\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution\n    candidate = new_solution.copy()\n    candidate[start:end+1] = candidate[start:end+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7598260122206125,
            4.332212078571319
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted objective diversity score\n    weights = [0.4, 0.3, 0.3]  # Weight for each objective\n    normalized_objectives = []\n    for obj in archive_objectives:\n        norm_obj = [obj[i] / sum(obj) for i in range(3)]\n        weighted_score = sum(norm_obj[i] * weights[i] for i in range(3))\n        normalized_objectives.append(weighted_score)\n\n    # Select based on both diversity and improvement potential\n    selection_probs = [1.0 / (score + 1e-6) for score in normalized_objectives]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # 3D segment reversal local search\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select a random segment to reverse\n    start = random.randint(0, n - 5)\n    length = random.randint(3, min(5, n - start - 1))\n    end = start + length\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution\n    candidate = new_solution.copy()\n    candidate[start:end+1] = candidate[start:end+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    }
]