[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective 3-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt heuristic\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select three distinct points to perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solutions by reversing segments\n    candidates = []\n    # Case 1: Reverse segment between a and b\n    candidate1 = new_solution.copy()\n    candidate1[a:b+1] = candidate1[a:b+1][::-1]\n    candidates.append(candidate1)\n    # Case 2: Reverse segment between b and c\n    candidate2 = new_solution.copy()\n    candidate2[b:c+1] = candidate2[b:c+1][::-1]\n    candidates.append(candidate2)\n    # Case 3: Reverse segment between a and c\n    candidate3 = new_solution.copy()\n    candidate3[a:c+1] = candidate3[a:c+1][::-1]\n    candidates.append(candidate3)\n    # Case 4: Reverse segments between a and b, and b and c\n    candidate4 = new_solution.copy()\n    candidate4[a:b+1] = candidate4[a:b+1][::-1]\n    candidate4[b:c+1] = candidate4[b:c+1][::-1]\n    candidates.append(candidate4)\n\n    # Evaluate all candidates and select the best one\n    best_candidate = new_solution\n    best_cost = current_cost\n    for candidate in candidates:\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, best_cost)):\n            best_candidate = candidate\n            best_cost = candidate_cost\n\n    return best_candidate\n\n",
        "score": [
            -0.7553992794412739,
            2.6026203632354736
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 3-opt heuristic\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select three distinct points to perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solutions by reversing segments\n    candidates = []\n    # Case 1: Reverse segment between a and b\n    candidate1 = new_solution.copy()\n    candidate1[a:b+1] = candidate1[a:b+1][::-1]\n    candidates.append(candidate1)\n    # Case 2: Reverse segment between b and c\n    candidate2 = new_solution.copy()\n    candidate2[b:c+1] = candidate2[b:c+1][::-1]\n    candidates.append(candidate2)\n    # Case 3: Reverse segment between a and c\n    candidate3 = new_solution.copy()\n    candidate3[a:c+1] = candidate3[a:c+1][::-1]\n    candidates.append(candidate3)\n    # Case 4: Reverse segments between a and b, and b and c\n    candidate4 = new_solution.copy()\n    candidate4[a:b+1] = candidate4[a:b+1][::-1]\n    candidate4[b:c+1] = candidate4[b:c+1][::-1]\n    candidates.append(candidate4)\n\n    # Evaluate all candidates and select the best one\n    best_candidate = new_solution\n    best_cost = current_cost\n    for candidate in candidates:\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, best_cost)):\n            best_candidate = candidate\n            best_cost = candidate_cost\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted combination of objective diversity and potential for improvement, then applies a multi-objective segment insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all objectives)\n    weights = [0.4, 0.3, 0.3]  # Weighting for the three objectives\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment insertion heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to insert elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Find insertion point\n    k = random.randint(0, n - 1)\n    while k in range(i, j+1):\n        k = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by inserting the segment\n    candidate = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6570506235128979,
            2.1749151825904844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential (considering all objectives)\n    weights = [0.4, 0.3, 0.3]  # Weighting for the three objectives\n    weighted_sums = [sum(w * o for w, o in zip(weights, obj)) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in weighted_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on weighted improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment insertion heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to insert elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Find insertion point\n    k = random.randint(0, n - 1)\n    while k in range(i, j+1):\n        k = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by inserting the segment\n    candidate = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective 3-opt local search that considers all three objectives simultaneously while maintaining feasibility, using a probabilistic acceptance criterion to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_objectives = [obj for sol, obj in archive]\n    objective_diversity = [np.std([obj[i] for obj in archive_objectives]) for i in range(3)]\n    selection_weights = [1.0 / (div + 1e-6) for div in objective_diversity]\n    total_weight = sum(selection_weights)\n    selection_probs = [w / total_weight for w in selection_weights]\n\n    # Randomly select an objective to focus on\n    selected_obj = np.random.choice(3, p=selection_probs)\n\n    # Select the solution with the best value in the selected objective\n    best_idx = np.argmin([obj[selected_obj] for sol, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # 3-opt local search with multi-objective consideration\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three random edges to reconnect\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Generate candidate solution\n    candidate = new_solution.copy()\n    candidate[b:a:-1] = new_solution[a:b]\n    candidate[c:b:-1] = new_solution[b:c]\n\n    candidate_cost = calculate_cost(candidate)\n\n    # Probabilistic acceptance based on multi-objective improvement\n    improvement = sum((curr - c) / curr for curr, c in zip(current_cost, candidate_cost) if curr > c)\n    if improvement > 0 or random.random() < np.exp(improvement):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7043607073628342,
            1.180601716041565
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_objectives = [obj for sol, obj in archive]\n    objective_diversity = [np.std([obj[i] for obj in archive_objectives]) for i in range(3)]\n    selection_weights = [1.0 / (div + 1e-6) for div in objective_diversity]\n    total_weight = sum(selection_weights)\n    selection_probs = [w / total_weight for w in selection_weights]\n\n    # Randomly select an objective to focus on\n    selected_obj = np.random.choice(3, p=selection_probs)\n\n    # Select the solution with the best value in the selected objective\n    best_idx = np.argmin([obj[selected_obj] for sol, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # 3-opt local search with multi-objective consideration\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three random edges to reconnect\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Generate candidate solution\n    candidate = new_solution.copy()\n    candidate[b:a:-1] = new_solution[a:b]\n    candidate[c:b:-1] = new_solution[b:c]\n\n    candidate_cost = calculate_cost(candidate)\n\n    # Probabilistic acceptance based on multi-objective improvement\n    improvement = sum((curr - c) / curr for curr, c in zip(current_cost, candidate_cost) if curr > c)\n    if improvement > 0 or random.random() < np.exp(improvement):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective diversity and normalized improvement potential, then applies a multi-objective 3-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    min_sum, max_sum = min(objective_sums), max(objective_sums)\n    normalized_sums = [(s - min_sum) / (max_sum - min_sum + 1e-6) for s in objective_sums]\n    diversity_weights = [np.std([obj[i] for obj in archive_objectives]) for i in range(3)]\n    total_diversity = sum(diversity_weights)\n    diversity_weights = [w / total_diversity for w in diversity_weights] if total_diversity > 0 else [1/3, 1/3, 1/3]\n\n    selection_scores = [0.7 * (1 - norm_sum) + 0.3 * sum(dw * obj[i] for i, dw in enumerate(diversity_weights))\n                        for norm_sum, obj in zip(normalized_sums, archive_objectives)]\n    total_score = sum(selection_scores)\n    selection_probs = [s / total_score for s in selection_scores]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Multi-objective 3-opt local search\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three random edges to reconnect\n    a, b, c = sorted(random.sample(range(n), 3))\n    candidates = [\n        np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a], new_solution[c:b-1:-1], new_solution[a:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]])\n    ]\n\n    for candidate in candidates:\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8033155521482938,
            4.362651789188385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate weighted improvement potential\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    min_sum, max_sum = min(objective_sums), max(objective_sums)\n    normalized_sums = [(s - min_sum) / (max_sum - min_sum + 1e-6) for s in objective_sums]\n    diversity_weights = [np.std([obj[i] for obj in archive_objectives]) for i in range(3)]\n    total_diversity = sum(diversity_weights)\n    diversity_weights = [w / total_diversity for w in diversity_weights] if total_diversity > 0 else [1/3, 1/3, 1/3]\n\n    selection_scores = [0.7 * (1 - norm_sum) + 0.3 * sum(dw * obj[i] for i, dw in enumerate(diversity_weights))\n                        for norm_sum, obj in zip(normalized_sums, archive_objectives)]\n    total_score = sum(selection_scores)\n    selection_probs = [s / total_score for s in selection_scores]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Multi-objective 3-opt local search\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select three random edges to reconnect\n    a, b, c = sorted(random.sample(range(n), 3))\n    candidates = [\n        np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a], new_solution[c:b-1:-1], new_solution[a:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]])\n    ]\n\n    for candidate in candidates:\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of crowding distance and objective diversity, then applies a multi-objective 2-opt heuristic that simultaneously considers all three distance matrices to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate crowding distance for each objective\n    def calculate_crowding(obj_values):\n        n = len(obj_values)\n        if n <= 2:\n            return [float('inf')] * n\n\n        sorted_indices = np.argsort(obj_values)\n        crowding = [0.0] * n\n        crowding[sorted_indices[0]] = float('inf')\n        crowding[sorted_indices[-1]] = float('inf')\n\n        for i in range(1, n-1):\n            crowding[sorted_indices[i]] = (obj_values[sorted_indices[i+1]] - obj_values[sorted_indices[i-1]])\n\n        return crowding\n\n    # Calculate combined crowding distance\n    crowding_distances = []\n    for i in range(3):\n        obj_values = [obj[i] for obj in archive_objectives]\n        crowding = calculate_crowding(obj_values)\n        crowding_distances.append(crowding)\n\n    # Combine crowding distances and improvement potential\n    combined_scores = []\n    for i in range(len(archive_solutions)):\n        obj_sum = sum(archive_objectives[i])\n        crowding_sum = sum(crowding_distances[j][i] for j in range(3))\n        combined_score = crowding_sum / (obj_sum + 1e-6)\n        combined_scores.append(combined_score)\n\n    # Select solution with highest combined score\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try multiple 2-opt moves\n    for _ in range(min(10, n)):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i <= 1:\n            continue\n\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.49211501668098967,
            3.133423936367035
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate crowding distance for each objective\n    def calculate_crowding(obj_values):\n        n = len(obj_values)\n        if n <= 2:\n            return [float('inf')] * n\n\n        sorted_indices = np.argsort(obj_values)\n        crowding = [0.0] * n\n        crowding[sorted_indices[0]] = float('inf')\n        crowding[sorted_indices[-1]] = float('inf')\n\n        for i in range(1, n-1):\n            crowding[sorted_indices[i]] = (obj_values[sorted_indices[i+1]] - obj_values[sorted_indices[i-1]])\n\n        return crowding\n\n    # Calculate combined crowding distance\n    crowding_distances = []\n    for i in range(3):\n        obj_values = [obj[i] for obj in archive_objectives]\n        crowding = calculate_crowding(obj_values)\n        crowding_distances.append(crowding)\n\n    # Combine crowding distances and improvement potential\n    combined_scores = []\n    for i in range(len(archive_solutions)):\n        obj_sum = sum(archive_objectives[i])\n        crowding_sum = sum(crowding_distances[j][i] for j in range(3))\n        combined_score = crowding_sum / (obj_sum + 1e-6)\n        combined_scores.append(combined_score)\n\n    # Select solution with highest combined score\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try multiple 2-opt moves\n    for _ in range(min(10, n)):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i <= 1:\n            continue\n\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 306,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective node relocation and inversion hybrid heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility by strategically relocating and inverting segments of the tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment and relocate it\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Find the best insertion point for the segment\n    best_pos = -1\n    best_cost = current_cost\n\n    for pos in range(n):\n        if pos >= i and pos <= j:\n            continue  # Skip positions within the original segment\n\n        candidate = new_solution.copy()\n        candidate = np.concatenate([candidate[:pos], segment, candidate[pos:]])\n        candidate = np.delete(candidate, range(i, j+1))  # Remove original segment\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            if sum(candidate_cost) < sum(best_cost):\n                best_pos = pos\n                best_cost = candidate_cost\n\n    if best_pos != -1:\n        candidate = new_solution.copy()\n        candidate = np.concatenate([candidate[:best_pos], segment, candidate[best_pos:]])\n        candidate = np.delete(candidate, range(i, j+1))\n        new_solution = candidate\n\n    # Apply segment inversion with probability 0.5\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6842160655669611,
            2.8343607902526857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment and relocate it\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Find the best insertion point for the segment\n    best_pos = -1\n    best_cost = current_cost\n\n    for pos in range(n):\n        if pos >= i and pos <= j:\n            continue  # Skip positions within the original segment\n\n        candidate = new_solution.copy()\n        candidate = np.concatenate([candidate[:pos], segment, candidate[pos:]])\n        candidate = np.delete(candidate, range(i, j+1))  # Remove original segment\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            if sum(candidate_cost) < sum(best_cost):\n                best_pos = pos\n                best_cost = candidate_cost\n\n    if best_pos != -1:\n        candidate = new_solution.copy()\n        candidate = np.concatenate([candidate[:best_pos], segment, candidate[best_pos:]])\n        candidate = np.delete(candidate, range(i, j+1))\n        new_solution = candidate\n\n    # Apply segment inversion with probability 0.5\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n"
    }
]