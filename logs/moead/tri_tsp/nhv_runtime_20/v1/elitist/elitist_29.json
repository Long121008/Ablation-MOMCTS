[
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7075858936603054,
            2.2624062061309815
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously, moving entire segments of the tour to different positions while ensuring feasibility and potentially improving multiple objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n-3)\n    seg_end = random.randint(seg_start+1, n-2)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a random new position\n    new_pos = random.randint(0, n-1)\n    while new_pos >= seg_start and new_pos <= seg_end:\n        new_pos = random.randint(0, n-1)\n\n    # Create candidate solution\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:new_pos+1],\n        segment,\n        new_solution[new_pos+1:]\n    ])\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8032740755040256,
            1.844494593143463
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution by strategically swapping nodes in a way that balances improvement across all objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Multi-objective node-swap heuristic\n    i, j = random.sample(range(n), 2)\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n    else:\n        # If no improvement, try a different node pair\n        k, l = random.sample(range(n), 2)\n        candidate = new_solution.copy()\n        candidate[k], candidate[l] = candidate[l], candidate[k]\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8514296790214821,
            2.4390843749046325
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective 2-opt* local search operator that considers the three distance matrices simultaneously while ensuring feasibility by maintaining tour connectivity and node uniqueness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt* heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select four distinct random indices\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Generate candidate solution by reordering edges\n    candidate = new_solution.copy()\n    candidate[a:b+1] = candidate[a:b+1][::-1]\n    candidate[c:d+1] = candidate[c:d+1][::-1]\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8579913641298663,
            2.66614693403244
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt exchange heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8766099731719228,
            2.67718391418457
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation operator that considers the three distance matrices simultaneously, ensuring feasibility by always relocating segments while maintaining valid TSP tours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 4)\n    seg_end = random.randint(seg_start + 2, n - 2)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n - len(segment))\n\n    # Remove the segment and insert it at the new position\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:],\n        segment\n    ])\n\n    # Insert the segment at the new position\n    candidate = np.concatenate([\n        candidate[:new_pos],\n        segment,\n        candidate[new_pos:]\n    ])\n\n    # Verify the solution remains valid (no duplicates)\n    if len(np.unique(candidate)) == n:\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.699679353962122,
            0.7773993015289307
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility, by strategically moving segments of the tour to potentially better positions across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    if not archive_solutions:\n        return np.array([])\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment relocation heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Try to insert the segment in a different position\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        new_pos = random.randint(0, n - segment_length)\n        if new_pos >= start and new_pos <= start + segment_length - 1:\n            continue  # Skip if the segment would be inserted in its original position\n\n        candidate = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:start],\n            new_solution[start+segment_length:]\n        ])\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7931252123891792,
            1.5524226784706117
        ]
    }
]