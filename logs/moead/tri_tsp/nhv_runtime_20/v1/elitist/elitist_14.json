[
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective edge-swap heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random edges to swap (ensuring feasibility)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by swapping edges\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse the segment\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7075858936603054,
            2.2624062061309815
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective 2-opt heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8346759507023986,
            2.6662267684936523
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation operator that considers the three distance matrices simultaneously, ensuring feasibility by always relocating segments while maintaining valid TSP tours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    seg_start = random.randint(0, n - 4)\n    seg_end = random.randint(seg_start + 2, n - 2)\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Select a new position to insert the segment\n    new_pos = random.randint(0, n - len(segment))\n\n    # Remove the segment and insert it at the new position\n    candidate = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:],\n        segment\n    ])\n\n    # Insert the segment at the new position\n    candidate = np.concatenate([\n        candidate[:new_pos],\n        segment,\n        candidate[new_pos:]\n    ])\n\n    # Verify the solution remains valid (no duplicates)\n    if len(np.unique(candidate)) == n:\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.699679353962122,
            0.7773993015289307
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective segment relocation heuristic that considers all three objectives simultaneously, ensuring feasibility by carefully relocating a segment of the tour to a new position while maintaining tour validity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relocation heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Select a new position to insert the segment\n    k = random.randint(0, n - 1)\n    while k >= i and k <= j:\n        k = random.randint(0, n - 1)\n\n    # Calculate current and potential costs for all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Generate candidate solution by relocating the segment\n    candidate = new_solution.copy()\n    candidate = np.concatenate([candidate[:i], candidate[j+1:]])\n    if k == 0:\n        candidate = np.concatenate([segment, candidate])\n    else:\n        candidate = np.concatenate([candidate[:k], segment, candidate[k:]])\n\n    # Check if the candidate is better in at least one objective\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8199001925169045,
            2.655721068382263
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a novel multi-objective segment relocation heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility, by strategically moving segments of the tour to potentially better positions across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    if not archive_solutions:\n        return np.array([])\n\n    # Calculate improvement potential (inverse of objective sum)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    # Randomly select a solution based on improvement potential\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment relocation heuristic\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Select a random segment to relocate\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Try to insert the segment in a different position\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        new_pos = random.randint(0, n - segment_length)\n        if new_pos >= start and new_pos <= start + segment_length - 1:\n            continue  # Skip if the segment would be inserted in its original position\n\n        candidate = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:start],\n            new_solution[start+segment_length:]\n        ])\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7931252123891792,
            1.5524226784706117
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a multi-objective node insertion heuristic that considers the three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    selection_probs = [1.0 / (sum_val + 1e-6) for sum_val in objective_sums]\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    candidate = new_solution.copy()\n    candidate = np.insert(candidate, i, candidate[j])\n    candidate = np.delete(candidate, j + (1 if j > i else 0))\n\n    candidate_cost = calculate_cost(candidate)\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8655725195160876,
            2.80710883140564
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective diversity and improvement potential, then applies a multi-objective 2-opt local search that considers all three distance matrices simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_objectives = [obj for sol, obj in archive]\n\n    # Calculate normalized objective values\n    max_obj1 = max(obj[0] for obj in archive_objectives)\n    max_obj2 = max(obj[1] for obj in archive_objectives)\n    max_obj3 = max(obj[2] for obj in archive_objectives)\n\n    # Calculate selection weights (inverse of normalized objectives)\n    weights = []\n    for obj in archive_objectives:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 1.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 1.0\n        norm_obj3 = obj[2] / max_obj3 if max_obj3 > 0 else 1.0\n        weight = 1.0 / (norm_obj1 + norm_obj2 + norm_obj3 + 1e-6)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    selection_probs = [w / total_weight for w in weights]\n\n    # Randomly select a solution based on weighted probabilities\n    selected_idx = np.random.choice(len(archive_solutions), p=selection_probs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective 2-opt local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try random 2-opt moves\n    for _ in range(min(10, n)):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == i + 1 or (i == 0 and j == n - 1):\n            continue\n\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        candidate_cost = calculate_cost(candidate)\n        if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n            new_solution = candidate\n            current_cost = candidate_cost\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8155338491122228,
            2.458009123802185
        ]
    }
]